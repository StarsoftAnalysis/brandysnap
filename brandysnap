#!/usr/bin/perl
# vim:tabstop=4 softtabstop=4 shiftwidth=4 expandtab 

#########################################################################
# brandysnap: rsync-based backup snapshot creation and management       #
# Copyright (C) 2011  Chris Dennis, chris@starsoftanalysis.co.uk        #
#                                                                       #
# This program is free software: you can redistribute it and/or modify  #
# it under the terms of the GNU General Public License as published by  #
# the Free Software Foundation, either version 3 of the License, or     #
# (at your option) any later version.                                   #
#                                                                       #
# This program is distributed in the hope that it will be useful,       #
# but WITHOUT ANY WARRANTY; without even the implied warranty of        #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         #
# GNU General Public License for more details.                          #
#                                                                       #
# You should have received a copy of the GNU General Public License     #
# along with this program.  If not, see <http://www.gnu.org/licenses/>. #
#########################################################################

# Coding style:
# CONSTANTS in upper case
# Globals with a leading capital
# otherVariables in camelCase (except for some frequently used things like @S)
# Formatting this file:
# vim:tabstop=4 softtabstop=4 shiftwidth=4 expandtab 
# and limit lines to 100 characters
# Keep it neat and tidy!

use 5.10.1;         
use strict;
use warnings;

use Time::Local;
use POSIX qw(ceil floor strftime);
use Date::Manip;    # see http://search.cpan.org/~sbeck/Date-Manip-6.23/lib/Date/Manip/DM6.pod
use Getopt::Long qw(:config ignore_case auto_abbrev);
use Math::Combinatorics;
use Config::General qw(ParseConfig);
use File::Path qw(remove_tree);
use File::Glob qw(:glob); 
use File::Find;
use File::Temp qw(tempfile tempdir);
use File::Spec::Functions qw(rel2abs splitdir catfile catdir);
use File::Basename;
use Fcntl qw(:flock);
use Filesys::Df;    
use Scalar::Util qw(looks_like_number);
use IPC::Open3;
use Symbol qw(gensym);
use IO::File;

# get a stack trace: (may get turned off later)
use Carp;
$SIG{__DIE__} = sub { Carp::confess(@_) };

# Prototyped subs: (which of these are needed?)
use subs qw(printit logit printlog debug warning
    mergeOpts snapshotName status
    processOptions validateOptions displayOptions
    fmtRange snapshotsInPeriod
    showHelp showLicence
    snapshotInfo snapshotInfoRemote
    testSuite run
    runRsync
    arrayDiff
    absPath safeAbsPath
);

# Globals and constants ============================================================================

my $Script = 'brandysnap';

# Make this script robust against interruptions.
# $Quitting becomes true if the script has been interrupted
my $Quitting = 0;
# Set the process group so that we can tidy up child processes:
setpgrp(0, 0);
# Ignore signals here; see also runRsync() systemCall() 
$SIG{HUP}  = 'IGNORE';
$SIG{INT}  = 'IGNORE';
$SIG{QUIT} = 'IGNORE';
$SIG{ABRT} = 'IGNORE';
$SIG{TERM} = 'IGNORE';

# turn off buffering on STDOUT to get full error messages
$| = 1;

# version of this script
my $Version = '0.1.12-renaming';

# A copy of @ARG before it gets shifted
my @ARGVcopy = @ARGV;

# Exit codes
use constant EXITOK     => 0;
use constant EXITCONFIG => 1;   # Configuration/option error
use constant EXITSPECS  => 2;   # Spec error
use constant EXITRSYNC  => 3;   # Error running rsync
use constant EXITINT    => 4;   # Interrupted
my $ExitCode = EXITOK;

#my $SymlinkExists = eval { symlink("",""); 1 };  not used

# Options -- need some options to start with
my %Opt = ();   
$Opt{debug}    = 0;
$Opt{verbose}  = 1;
$Opt{loglevel} = 1;

# Template for snapshot directory names --  the date part:
# (if you change this, existing snapshots will not be found!)
use constant STAMPFMT => "%Y%m%d-%H%M%S";

# Date/time constants and globals 

# A value that will be bigger than any value of 'time' or any total of lots of 'time's
use constant MAXTIME => 2**53;  # according to http://www.perlmonks.org/?node_id=718414

# An 'unlimited' number of snapshots
use constant UNLIMITED => 99999;

# Days in the month (ignoring leap years)
my @DiM = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);

# Datecalc deltas for each period:
my @PrevP = (
    '-0:0:-0:0:1:0:0',  # h 
    '-0:0:-0:1:0:0:0',  # d
    '-0:0:-1:0:0:0:0',  # w
    '-0:1:-0:0:0:0:0',  # m
#   '-0:3:-0:0:0:0:0',  # q
    '-1:0:-0:0:0:0:0',  # y
);

# Date::Manip's period identifiers
# (see http://search.cpan.org/~sbeck/Date-Manip-6.24/lib/Date/Manip/Delta.pod#PRINTF_DIRECTIVES)
# indexed by periodn
my @DMperiod = ('h', 'd', 'w', 'M', 'y');

# For converting e.g. 'd' to 1
my %Level = (h => 0, d => 1, w => 2, m => 3, y => 4);

my @LevelName = ('hour', 'day', 'week', 'month', 'year');

# Number of hours in periods at each level
# (approximate for months and years)
my @Hours = (1, 24, 24*7, 24*7*4, 24*7*4*12);   

# Periods in seconds:
use constant MINUTE => 60;
use constant HOUR   => MINUTE * 60;
use constant DAY    => HOUR * 24;
use constant WEEK   => DAY * 7;
# months and years aren't fixed in terms of seconds!

# Total number of snapshots required by specs
my $TotalSnapshots = 0; 

# An empty temporary directory for use in deleteSnapshot() and mkdirRsync()
# (yes, I know, this is a bit of a kludge)
my $EmptyDir = tempdir(CLEANUP => 1);

# Arrays defining types of options
# All options
my @AllOpt = qw(
    debug verbose loglevel test
    hbest dbest wbest mbest ybest
    safe calendar strict
    config destination spec template source
    snapshot delete delete-cp
    dry-run version help
    stacktrace weekstart
    logfile lockfile logfile-temp
    rsync-cmd rsync-opts remote-rsync-cmd
    include include-from exclude exclude-from
    expire-old
    bwlimit-in bwlimit-out
    status compress restart
    allow-restart ldcount
    );
my %AllOpt = (map {$_ => 1} @AllOpt);
# Required options (not including those that have a default value)
my @ReqOpt = qw(destination source template lockfile spec);
# Multi-value options (are also all string options)
my %MultiOpt = qw(source 1  include 1  include-from 1  
    exclude 1  exclude-from 1  destination 1);
# Boolean options
my @BoolOpt  = qw(safe calendar snapshot delete delete-cp dry-run 
    stacktrace version expire-old status compress restart allow-restart);
# String options (NOT the multi-value ones)
my @StringOpt = qw(config lockfile logfile template rsync-cmd rsync-opts remote-rsync-cmd);
# Level options (take values 0..9)
my @LevelOpt = qw(verbose loglevel debug);

# Suffix used to indicate that a snapshot is incomplete
my $partialSuffix = 'p';

# Mainline code is at the end of this file

#===================================================================================================

# Useful stuff

sub min ($$) {
    my $a = shift;
    my $b = shift;
    return ($a < $b) ? $a : $b;
}
sub max ($$) {
    my $a = shift;
    my $b = shift;
    return ($a > $b) ? $a : $b;
}

#---------------------------------------------------------------------------------------------------

sub bytes ($) {
    # Simple routine for displaying a file size
    # (return '' if size is zero)
    my $n = shift;
    return '' if $n == 0;
    my $base = 1024;
    my @suffix = ('B', 'kiB', 'MiB', 'GiB', 'TiB');
    my $mult = 0;
    while (abs($n) > $base) {
        $n /= $base;
        $mult += 1;
    }
    return sprintf(
        ($n == floor($n)) ? "%s%d %s" : "%s%.2f %s", 
        ($n < 0) ? '-' : '', $n, $suffix[$mult]
    );
}

#---------------------------------------------------------------------------------------------------

sub combinations ($@) {
    # Return all ways of choosing $n items from @list
    my $n    = shift;  
    my @list = @_;
    my @combs;
    my $generator = Math::Combinatorics->new(count => $n, data => [@list],);
    while (my @combo = $generator->next_combination) {
        push @combs, [@combo];
    }
    return @combs;
}

#---------------------------------------------------------------------------------------------------

sub stripQuotes ($) {
    # If the user has enclosed the option in single or double quotes,  
    # we'll strip them off (and add single quotes later).
    # If there are more than one set, e.g. '"string"' or "'string'",
    # assume that the string is really supposed to have the inner
    # set as part of its value.
    # Any other quotes, such as abc'def or xyz" will also be treated
    # as part of the value.
    # And double quotes will be escaped, ready for the string to
    # be wrapped in double quotes when used in the rsync command.
    # Also strips surrounding white-space, e.g. | str ing  | -> |str ing|
    my $string = shift;
    my $temp = $string; # just for debugging
    $string =~ s/^\s+//;                # strip leading white-space
    $string =~ s/\s+$//;                # strip trailing white-space
    if (!($string =~ s/^'(.*)'$/$1/)) { # strip single quotes
        $string =~ s/^"(.*)"$/$1/;      # strip double quotes if no singles
    }
    $string =~ s/^\s+//;                # strip white-space again
    $string =~ s/\s+$//;
    $string =~ s/\"/\\\"/g;             # escape double quotes
    $string =~ s/\\#/#/g;               # UNescape # that had to be escaped for Config::General
    debug "sQ: |$temp| -> |$string|\n", 9;
    return $string;
}

#===================================================================================================
# Logging

sub printit ($;$) {
    # Print depending on the level of verbose
    # (trailing newline to be supplied)
    my $text  = shift;
    my $level = shift // 1;
    print $text if $Opt{verbose} >= $level;
}

# logit --------------------------------------------------------------------------------------------

sub logit ($;$) {
    # Simple logging to a text file,
    # preserving newlines in the text 
    # while adding a timestamp
    return if !defined $Opt{logfile};
    my $text  = shift;
    my $level = shift // 1;
    return if $Opt{loglevel} < $level;
    (my $leadingnl, $text) = ($text =~ m/^(\n*)(.*?)\n*$/s);
    $text =~ s/\n/\n                  /gs;
    my $now  = strftime "%y/%m/%d %H:%M:%S ", localtime;
    my $oldfh = select LOGFILE;
    $| = 1;
    open  LOGFILE, '>>', "$Opt{logfile}" or die "Unable to write to logfile $Opt{logfile}";
    print LOGFILE "${leadingnl}${now}${text}\n";
    close LOGFILE;
    select $oldfh;
}

# printlog -----------------------------------------------------------------------------------------

sub printlog ($;$$) {
    # Print and log depending on the level of verbose
    # (trailing newline to be supplied)
    my $text   = shift;
    my $plevel = shift // 1;
    my $llevel = shift // $plevel;
    print "$text" if $Opt{verbose} >= $plevel;
    logit $text, $llevel;
}

# debug --------------------------------------------------------------------------------------------

sub debug ($;$) {
    # Print debugging information to STDOUT and log
    # depending on the level of verbosity
    # (trailing new lines supplied if required)
    my $text  = shift;
    my $level = shift // 1;
    if ($Opt{debug} >= $level) {
        (my $leadingnl, $text) = ($text =~ m/^(\n?)(.*)$/s); 
        print "${leadingnl}dbg: $text";
        logit "${leadingnl}dbg: $text", 0; 
    }   
}

# warning ------------------------------------------------------------------------------------------
    
sub warning ($) {
    # Output a warning to STDERR and log
    my $text = shift;
    logit "WARNING: $text", 1;
    warn $text;
}

# Date/time routines ===============================================================================

sub fmtHours ($) {
    # pretty-print a time period given in hours
    my $hours = shift;
    my $delta = "0:0:0:0:$hours:0:0";
    debug "fH: hours=$hours delta=$delta\n", 9;
    $delta = DateCalc($delta, "0:0:0:0:0:0:0", 1);  # normalise it
    my ($y, $M, $w, $d, $h, $m, $s) = split /:/, $delta;
    my @bits = split /:/, $delta;
    my $result = '';
    $result .= "$y years "   if $y != 0;
    $result .= "$M months "  if $M != 0; 
    $result .= "$w weeks "   if $w != 0; 
    $result .= "$d days "    if $d != 0; 
    $result .= "$h hours "   if $h != 0; 
    $result .= "$m minutes " if $m != 0; 
    $result .= "$s seconds " if $s != 0; 
    substr($result, -1) = ''; # trim final space    
    return $result;
}

#---------------------------------------------------------------------------------------------------

sub time2date ($) {
    # Convert a Unix timestamp to a Date::Manip date
    my $ts = shift;
    return ParseDateString("epoch $ts");
}

#---------------------------------------------------------------------------------------------------

sub date2time ($) {
    # Convert a Date::Manip date to a Unix timestamp
    my $date = shift;
    return UnixDate($date, '%s');
}

#---------------------------------------------------------------------------------------------------

sub leapYear ($) {
    # Simple routine that assumes we're running sometime
    # between 2001 and 2099.
    # Returns 1 for a leap year, else 0
    my $moment = shift;
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($moment);
    return (($year+1900 % 4) == 0);
}

#---------------------------------------------------------------------------------------------------

sub daysInYearMonth ($$) {
    # Return the number of days in the month specified by year and month number (0..11)
    my $y = shift;
    my $m = shift;
    my $days = $DiM[$m];
    $days += 1 if ($m == 1 and leapYear($y));
    return $days;
}

#---------------------------------------------------------------------------------------------------

sub daysInMonth ($) {
    # Return the number of days in the month in which 
    # the specified moment falls
    my $moment = shift;
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($moment);
    return daysInYearMonth($year+1900, $mon);
}

#---------------------------------------------------------------------------------------------------

sub daysInYear ($) {
    # Return the number of days in the year 
    # in which the specified moment falls.
    my $moment = shift;
    return leapYear($moment) ? 366 : 365;
}

#---------------------------------------------------------------------------------------------------

sub aligned ($$) {
    # Return true if timesofar is a multiple
    # of the given period
    # (taking a month as 4 weeks)
    my $timesofar = shift;
    my $periodn   = shift;
    return ($timesofar % $Hours[$periodn]) == 0;
}

#---------------------------------------------------------------------------------------------------

# Timestamp format for snapshots is YYYYMMDD-hhmmss
# as hard-coded in the following two subroutines.

sub stamp2time ($) {
    # convert filename-type timestamp to Unix time
    my $stamp = shift;
    if ($stamp =~ /(?<Y>\d\d\d\d)(?<M>\d\d)(?<D>\d\d)-(?<h>\d\d)(?<m>\d\d)(?<s>\d\d)/) {
        return timelocal($+{s},$+{m},$+{h},$+{D},$+{M}-1,$+{Y});
    }
    debug "stamp2time: WARNING -- invalid stamp '$stamp' -- returning 0\n", 1;
    return 0;
}

#---------------------------------------------------------------------------------------------------

sub time2stamp ($) {
    # convert Unix time to filename timestamp
    my $time = shift;
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($time);
    return strftime(STAMPFMT, localtime($time));
}

#---------------------------------------------------------------------------------------------------

sub pair2range ($$) {
    # Convert a beginning/end pair of Unix times to
    # a readable range
    my $beg = shift;
    my $end = shift;
    return time2stamp($beg) . '--' . time2stamp($end);
}

#===================================================================================================

# Options 
# - defaults are in %defopt
# - then read command line options (including config file name)
# - then read config file (if any)
# - then merge defaults, config file, and command line options
# - then validate

sub readConfig ($) {
    my $cfile = shift;
    my %confopt = ();
    my $warning = '';
    if (-f -r $cfile) {
        local $SIG{__WARN__} = sub { $warning = "@_"; }; # or $_[0]
        %confopt = ParseConfig(
            -ConfigFile => $cfile,
            -LowerCaseNames => 1,
            -AutoTrue => 1,     # convert true,yes,on to 1; false,no,off to 0
        );
    }
    debug "readConfig WARNING: '$warning'\n", 9;
    debug "read options: " . join(' ', map {$_ . '=' . $confopt{$_}} sort keys %confopt) . "\n", 9;
    return %confopt;
}

#---------------------------------------------------------------------------------------------------

sub mergeOpts (@) {
    # Merge option hashes together
    my %Opt = %{(shift)};
    foreach my $nextoptref (@_) {
        foreach my $k (keys %$nextoptref) {
            $Opt{$k} = $nextoptref->{$k};
        }
    }
    return %Opt;
}

#---------------------------------------------------------------------------------------------------

sub processOptions () {

    # Default options hard-coded here
    # -------------------------------
    my %defopt = ();    # default options
    # output: for each of these, 0 means no (or minimal) output, 3 means lots, 
    # (higher values for debugging only)
    $defopt{debug}          = 0;
    $defopt{verbose}        = 1;
    $defopt{loglevel}       = 1;
    $defopt{test}           = 0;          # a non-zero value indicates which test to run
    # options to prefer one part of a period, e.g. 5pm, Fridays
    # defaults are at the end of the period 
    $defopt{hbest}          = 59;         # preferred time within an hour 0-59, integer
    $defopt{dbest}          = 23.99;      #                       a day 0-23.99, float
    $defopt{wbest}          = 7;          # preferred day within a week 1-7, integer, 1=Sun 7=Sat
    $defopt{mbest}          = 31;         # preferred day within a month 1-31  
    $defopt{ybest}          = 366;        # preferred day in the year
    # 
    $defopt{'allow-restart'} = 1;   
    $defopt{'bwlimit-in'}   = 0;        
    $defopt{'bwlimit-out'}  = 0;
    $defopt{calendar}       = 1;
    $defopt{compress}       = 1;
    $defopt{delete}         = 1;
    $defopt{'delete-cp'}    = 1;
    $defopt{'dry-run'}      = 0;
    $defopt{'expire-old'}   = 0;          # expire oldest S's to make room, even when not unlimited
    $defopt{help}           = 0;
    $defopt{ldcount}        = 1;          # no. of link-dest options to create
    $defopt{restart}        = 0;
    $defopt{'rsync-cmd'}    = 'rsync';    # Should it be '/usr/bin/rsync'?
    $defopt{'rsync-opts'}   = '--hard-links --numeric-ids --archive --one-file-system';
    $defopt{safe}           = 1;        
    $defopt{snapshot}       = 1;
    $defopt{stacktrace}     = 1;
    $defopt{status}         = 0;
    $defopt{strict}         = 0;
    $defopt{version}        = 0;
    $defopt{weekstart}      = 1;          # 1=Sunday
    # The following deliberately do not have defaults:
    #   template   source  lockfile   logfile   config  destination  spec
    #   include include-from exclude exclude-from
    #   remote-rsync-cmd

    my %confopt = ();   # config file options
    my %cmdopt = ();    # command line options

    # Trap warnings from GetOptions
    { # limit scope of SIGWARN override
        my $GOwarning = '';
        local $SIG{__WARN__} = sub { $GOwarning = "@_"; }; # or $_[0]
        my $GOok = GetOptions (\%cmdopt,
            'allow-restart!',
            'bwlimit-in=i',
            'bwlimit-out=i',
            'calendar!',
            'compress!',
            'config=s',
            'dbest=f',
            'debug=i',      
            'delete!',
            'delete-cp!',
            'destination=s@',
            'dry-run!',
            'exclude-from=s@',
            'exclude=s@',
            'expire-old!',
            'hbest=i',
            'help!',
            'include-from=s@',
            'include=s@',
            'ldcount=i',
            'lockfile=s',
            'logfile=s',
            'loglevel=i',
            'mbest=i',
            'restart!',
            'rsync-cmd=s',
            'rsync-opts=s',
            'remote-rsync-cmd=s',
            'safe!',
            'snapshot!',
            'source=s@',
            'spec=s',
            'stacktrace!',
            'status!',
            'strict!',
            'template=s',
            'test=i',
            'verbose=i',
            'version',
            'wbest=i',
            'weekstart=i',
            'ybest=i',
        );
        printlog "ERROR: $GOwarning\n", 1 if !$GOok;
        return 1 unless $GOok;  
    }

    debug "\%cmdopt: " . join(' ', map {$_ . '=>' . $cmdopt{$_}} sort keys %cmdopt) . "\n", 9;

    # If config file specified, make sure it's readable, and read it
    if ($cmdopt{config}) {
        $cmdopt{config} = absPath($cmdopt{config});
        if (-f -r $cmdopt{config}) {
            %confopt = readConfig($cmdopt{config});    
        } else {
            printlog "ERROR: configuration file '$cmdopt{config}' can not be read -- stopping\n", 1;
            return 1;
        }
    }
    debug "def  options: " . join(' ', 
        map {$_ . '=' . $defopt{$_}}  sort keys %defopt)  . "\n", 9;
    debug "conf options: " . join(' ', 
        map {$_ . '=' . $confopt{$_}} sort keys %confopt) . "\n", 9;
    debug "cmd  options: " . join(' ', 
        map {$_ . '=' . $cmdopt{$_}}  sort keys %cmdopt)  . "\n", 9;
    
    # Merge options, so that config file options override the defaults,
    # and command-line options override everything else;
    %Opt = mergeOpts \%defopt, \%confopt, \%cmdopt;
    
    debug "Unvalidated final options: " . join(' ', 
        map {$_ . '=' . $Opt{$_}} sort keys %Opt) . "\n", 9;
    
    # If user asked for help or version, or is running test mode,
    # don't do any more validation
    if ($Opt{help} or $Opt{version} or $Opt{test}) {
        return 0;
    }
    
    my $errorcount = 0;
    my $warningcount = 0;

    # Sneaky trick to avoid trying to use logfile before it's been validated:
    $Opt{'logfile-temp'} = $Opt{logfile} if defined $Opt{logfile};
    delete $Opt{logfile};

    # Check for missing options
    foreach my $ropt (@ReqOpt) {
        unless ($Opt{$ropt}) {
            printlog "ERROR: required option '$ropt' is missing\n", 1;
            $errorcount += 1;
        }
    }

    # Check for unknown options
    foreach my $opt (sort keys %Opt) {
        unless ($AllOpt{$opt}) {
            printlog "ERROR: unknown option '$opt' found\n", 1;
            # This is an error because it's probably a miss-spelled option, 
            # or the user doesn't know what they're doing
            $errorcount += 1;
        }
    }

    # Multi-value options
    foreach my $opt (sort keys %Opt) {
        if ($MultiOpt{$opt}) {
            # Make sure multiple options are always arrays (if they exist at all)
            #debug "$mopt is of type " . ref($Opt{$mopt}) . "\n";;
            if (!ref($Opt{$opt})) {
                $Opt{$opt} = [$Opt{$opt}];
            }
            # All multi-value options happen to be string options,
            # so strip any unnecessary quotes
            debug "mv option '$opt'...\n", 9;
            for my $i (0..$#{$Opt{$opt}}) {
                debug "...i=$i '${$Opt{$opt}}[$i]'\n", 9;
                ${$Opt{$opt}}[$i] = stripQuotes(${$Opt{$opt}}[$i]);
            }
        } else {
            # Make sure single options ARE single
            if (ref($Opt{$opt})) {
                printlog "ERROR: option '$opt' can not have more than one value\n", 1;
                $errorcount += 1;
            }
        }
    }

    # String options -- sort out any quotes
    foreach my $opt (@StringOpt) {
        $Opt{$opt} = stripQuotes($Opt{$opt}) if $Opt{$opt};
    }

    # Stop here after first phase of check 
    return $errorcount if $errorcount;

    # Validate options more thoroughly

    # Logging (check this first, so that we can log later errors)
    # logfile must be local
    $Opt{logfile} = $Opt{'logfile-temp'};
    delete $Opt{'logfile-temp'};
    if (!$Opt{logfile}) {
        # no logfile, so no logging
        $Opt{loglevel} = 0;
        delete $Opt{logfile};
    } else {
        $Opt{logfile} = absPath($Opt{logfile});
        # check that the logfile is a writable file, or if it does not
        # exist, will be in a writable directory
        unless (-f -w $Opt{logfile} or
                -d -w dirname($Opt{logfile})) {
            printit "ERROR: Logfile '$Opt{logfile}' (option 'logfile') can not be written\n", 1;
            delete $Opt{logfile};
            $Opt{loglevel} = 0;
            $errorcount += 1;
        }
    }

    # Add basic info to logfile
    logit "\n" . '-' x 80, 1;
    logit "\n$Script version $Version starting at " . (strftime "%H:%M:%S", localtime) . "\n", 1;
    logit "Command line: $0 @ARGVcopy\n", 3;

    # Lock file (must be local)
    if (!$Opt{lockfile}) {
        printlog "ERROR: Option 'lockfile' is missing, and must be specified\n", 1,1;
        $errorcount += 1;
    } else {
        $Opt{lockfile} = absPath($Opt{lockfile});
        # Check that the lockfile is in a writable directory
        # (if the file already exists, we won't have got this far)
        unless (-d -w dirname($Opt{lockfile})) {
            printlog "ERROR: Lockfile '$Opt{lockfile}' (option 'lockfile') can not be created\n", 1;
            $errorcount += 1;
        }
    }

    # Source(s) - at least one source must be readable
    if (!$Opt{source}) {
        printlog "ERROR: Option 'source' is missing, and must be specified\n", 1,1;
        $errorcount += 1;
    } else {
        my $readableSources = 0;
        my @tempSources = @{$Opt{source}};
        @{$Opt{source}} = ();
        foreach my $src (@tempSources) {
            $src = safeAbsPath($src);
            if (remote($src)) {
                printlog "NOTE: Source '$src' is on a remote computer: " . 
                "it will not be checked until rsync runs\n", 1;
                $readableSources += 1; 
                push @{$Opt{source}}, $src;
            } elsif (-r $src) {
                $readableSources += 1; 
                push @{$Opt{source}}, $src;
            } else {
                printlog "WARNING: Source '$src' (option 'source') can not be read\n", 1;
                $warningcount += 1;
            }
        }
        if ($readableSources == 0) {
            printlog "ERROR: None of the sources specified can be read\n", 1;
            $errorcount += 1;
        }
    }

    # Destination directories
    if (!$Opt{destination}) {
        printlog "ERROR: Option 'destination' is missing, and must be specified\n", 1,1;
        $errorcount += 1;
    } else {
        my $writableDests = 0;
        my @tempDests = @{$Opt{destination}};
        @{$Opt{destination}} = ();
        foreach my $dest (@tempDests) {
            my $absdest = safeAbsPath($dest);
            debug "destination: absdest=$dest\n", 9;
            if (remote($dest)) {
                printlog "NOTE: Destination '$dest' is on a remote computer: " . 
                    "it will not be checked until rsync runs\n", 1;
                $writableDests += 1;
                push @{$Opt{destination}}, $dest;
            } elsif (-d -w $absdest) {
                $writableDests += 1;
                push @{$Opt{destination}}, $absdest;
            } else {
                printlog "WARNING: Destination '$absdest' (option 'destination') is not available " .
                    "as a writable directory\n", 1;
                $warningcount += 1;
            }
        }
        if ($writableDests == 0) {
            printlog "ERROR: None of the destinations specified is available\n", 1;
            $errorcount += 1;
        }
    }
    
    # Cross-check sources and destinations -- they can't all be remote
    my $local = 0;
    foreach my $source (@{$Opt{source}}) {
        $local = 1 if !remote($source);
    }
    foreach my $dest (@{$Opt{destination}}) {
        $local = 1 if !remote($dest);
    }
    if (!$local) {
        printlog "ERROR: at least one source or destination must be local\n", 1;
        $errorcount += 1;
    }

    # Output levels
    sub checkOutput ($) {
        my $opt = shift;
        $Opt{$opt} = 1 if !defined $Opt{$opt};
        $Opt{$opt} = int($Opt{$opt});
        $Opt{$opt} = 0 if $Opt{$opt} < 0;
    }
    foreach my $opt (@LevelOpt) {
        checkOutput $opt;
    }

    # Boolean options
    # Config::General converts true/yes/on to 1, false/no/off to 0
    # Getopt::Log likewise
    sub checkBoolean ($) {
        my $opt = shift;
        if (!(0 ~~ $Opt{$opt} or 1 ~~ $Opt{$opt})) {
            printlog "ERROR: Invalid option: '$opt' must be true/yes/on/1 or false/no/off/0, " .
                "not '$Opt{$opt}'\n", 1,1;
            return 1;
        }
        return 0
    }
    foreach my $opt (@BoolOpt) {
        $errorcount += checkBoolean $opt;
    }

    # 'Best' options
    if ($Opt{hbest} and !($Opt{hbest} >= 0 and $Opt{hbest} <= 59)) {
        printlog "ERROR: Invalid option: 'hbest' must be a whole number between 0 and 59, " .
            "not '$Opt{hbest}'\n", 1;
        $errorcount += 1;
    }
    if ($Opt{dbest} and !($Opt{dbest} >= 0 and $Opt{dbest} < 24.0)) {
        printlog "ERROR: Invalid option: 'dbest' must be a number between 0 and 23.9, " .
            "not '$Opt{dbest}'\n", 1;
        $errorcount += 1;
    }
    if ($Opt{wbest} and !($Opt{wbest} >= 1 and $Opt{wbest} <= 7)) {
        printlog "ERROR: Invalid option: 'wbest' must be a whole number between 1 and 7 " .
            "(1=Sunday, 7=Saturday), not '$Opt{wbest}'\n", 1;
        $errorcount += 1;
    }
    if ($Opt{mbest} and !($Opt{mbest} >= 1 and $Opt{mbest} <= 31)) {
        # (31 gives the last day of any month)
        printlog "ERROR: Invalid option: 'mbest' must be a whole number between 1 and 31, " .
            "not '$Opt{mbest}'\n", 1;
        $errorcount += 1;
    }
    if ($Opt{ybest} and !($Opt{ybest} >= 1 and $Opt{ybest} <= 366)) {
        # (366 gives the last day of the year, whether a leap year or not)
        printlog "ERROR: Invalid option: 'ybest' must be a whole number between 1 and 366, " .
            "not '$Opt{ybest}'\n", 1;
        $errorcount += 1;
    }

    # Week start - an integer from 1=Sunday to 7=Saturday
    # (which is the same as $Opt{wbest} but different from localtime's $wday)
    $Opt{weekstart} = 1 if !defined $Opt{weekstart};
    $Opt{weekstart} = int($Opt{weekstart});
    $Opt{weekstart} = 1 if $Opt{weekstart} < 1;
    $Opt{weekstart} = 7 if $Opt{weekstart} > 7;

    # Link-dest count -- positive integer
    $Opt{ldcount} = int($Opt{ldcount});
    if ($Opt{ldcount} < 0) {
        printlog "ERROR: Invalid option: 'ldcount' must be a positive whole number, " .
            "not '$Opt{ldcount}'\n", 1;
        $errorcount += 1;
    } elsif ($Opt{ldcount} == 0) {
        printlog "WARNING: Option 'ldcount' is zero -- no hard-linking will be done, " .
            "and the snapshot created may be much larger than expected\n", 1;
    }

    # Band-width limits
    # (0 = unlimited)
    if (!looks_like_number($Opt{'bwlimit-in'}) or
        $Opt{'bwlimit-in'} < 0                    ) {
        printlog "ERROR: Invalid option: 'bwlimit-in' must be zero or a positive whole number (in kbps), " .
            "not '$Opt{'bwlimit-in'}'\n", 1;
        $errorcount += 1;
    } else {
        $Opt{'bwlimit-in'} = floor($Opt{'bwlimit-in'});
    }
    if (!looks_like_number($Opt{'bwlimit-out'}) or
        $Opt{'bwlimit-out'} < 0                    ) {
        printlog "ERROR: Invalid option: 'bwlimit-out' must be zero or a positive whole number " .
            "(in kbps), not '$Opt{'bwlimit-out'}'\n", 1;
        $errorcount += 1;
    } else {
        $Opt{'bwlimit-out'} = floor($Opt{'bwlimit-out'});
    }
    
    # include, include-from, exclude, exclude-from
    # - these are not checked at all, just passed to rsync

    # spec is checked later

    # Stop here after second phase of check 
    return $errorcount if $errorcount;

    debug "Validated final options: " . join(' ', 
        map {$_ . '=' . $Opt{$_}} sort keys %Opt) . "\n", 9;

    return $errorcount;
}

#---------------------------------------------------------------------------------------------------

sub printableOption ($) {
    # Return a printable version of an option
    my $opt = shift;
    if (ref($Opt{$opt}) eq 'ARRAY') {
        # multiple option -- which happen to be all strings
        return join(', ', map {"'$_'"} @{$Opt{$opt}}); 
    }
    if (grep {$_ eq $opt} @BoolOpt) {
        # boolean options
        return $Opt{$opt} ? 'yes' : 'no';
    }
    if (grep {$_ eq $opt} @StringOpt) {
        # string option
        return "'$Opt{$opt}'";
    }
    # else it's numeric
    return "$Opt{$opt}";
}

#---------------------------------------------------------------------------------------------------

sub displayOptions () {
    my $optSummary = "\nOptions summary:";
    my $max = 80;
    my $pos = 0;
    foreach my $opt (sort keys %Opt) {
        my $key = "$opt";
        my $text = sprintf("%16s - %s", $key, printableOption($opt)); 
        # one per line for now
        if (1) {    #$pos and ($pos + length($text) > $max)) {
            $optSummary .= "\n";
            $pos = 0;
        }
        $optSummary .= $text;
        $pos += length($text);
    }
    printlog "$optSummary\n\n", 2,2;
}

#===================================================================================================

# Help

sub showHelp () {
    printit <<EOT;

Usage: $Script [option]...

Options can be specified on the command line or in the configuration file.
Main options
--config       file      configuration file name (optional)
--source       file/dir *local or remote file or directory to add to snapshot
                          (required)
--destination  dir      *local or remote snapshot destination (required)
--template     name      prefix for snapshot directories (required)
--spec         ...       snapshot-keeping specification (required)
--lockfile     file      lock-file (required)
--logfile      file      file used for logging (optional)
Tuning options
--calendar     yes/no    use calendar mode (default: yes)
--safe         yes/no    use safe mode (default: yes)
--hbest        0..59     favoured time within hour (default: 59)
--dbest        0..23.9   favoured time within day in hours (default: 23.9)
--mbest        1..31     favoured day within month (default: 31)
--wbest        1..7      favoured day within week, 1=Sunday (default: 1)
--ybest        1.366     favoured day within year (default: 366)
--weekstart    1..7      first day of week, 1=Sunday (default: 1)
Helpful options
--help         yes/no    display this help message (default: no)
--version      yes/no    display version number only (default: no)
--verbose      0..3      amount of output displayed (default: 1)
--loglevel     0..3      amount of logging information (default: 1)
--dry-run      yes/no    make no actual changes (default: no)
Rsync options
--rsync-cmd    file      location of the rsync programme (default: rsync)
--compress     yes/no    enable rsync compression for remote transfers 
                          (default: yes)
--include      pattern  *rsync inclusion (see rsync documentation)
--include-from file     *rsync inclusions
--exclude      pattern  *rsync exclusion
--exclude-from file     *rsync exclusions 
--bwlimit-in   n         bandwidth limit for receiving in kbps (default: 0)
                          (set to 0 for no limit)
--bwlimit-out  n         bandwidth limit for sending in kbps (default: 0)
                          (set to 0 for no limit)
--rsync-opts   options   extra options to pass to rsync 
                          (default: -aHx --numeric-ids)
--remote-rsync-cmd file  location of the rsync programme on the remote
                          computer (optional, no default)
Advanced options
--delete       yes/no    delete no-longer-required snapshots (default: yes)
--delete-cp    yes/no    delete even in current period (default: yes)
--expire-old   yes/no    delete oldest snapshots when disk is full (default: no)
--ldcount      n         number of --link-dest options to created (default: 1)
--restart      yes/no    continue previous snapshot (default: no)
--snapshot     yes/no    create new snapshots (default: yes)
--status       yes/no    print a status report only (default: no)
--strict       yes/no    use strict mode (default: no)
--allow-restart yes/no   keep the unfinished snapshot if brandysnap was
                          interrupted (e.g. by ctrl-C or system shutdown)
                          (default: yes)
Development options
--debug        0..3      amount of debugging information (default: 0)
--stacktrace   yes/no    print a stack trace on error (default: yes)
--test         n         run test case 'n' 
Options marked with '*' can be specified more than once

Please see the $Script documentation for full details.

EOT
    showLicence;
}

#---------------------------------------------------------------------------------------------------

sub showLicence () {
    printit <<EOT;
rsync-based backup snapshot creation and management        
Copyright (C) 2011  Chris Dennis, chris\@starsoftanalysis.co.uk        
                                                                       
This program is free software: you can redistribute it and/or modify  
it under the terms of the GNU General Public License as published by  
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.                              
                                                                  
This program is distributed in the hope that it will be useful,     
but WITHOUT ANY WARRANTY; without even the implied warranty of     
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        
GNU General Public License for more details.                          
                                                                      
You should have received a copy of the GNU General Public License     
along with this program.  If not, see <http://www.gnu.org/licenses/>. 

EOT
}

#===================================================================================================
# Filing system stuff

sub remote ($) {
    # Returns 'true' if the path is considered by rsync to be remote
    # (via daemon or just ssh)
    # (See rsync's man page re the significance of ':')
    my $path = shift;
    return index($path, ':') > -1;
}

#---------------------------------------------------------------------------------------------------

sub remoteDaemon ($) {
    # Returns 'true' if the path is considered by rsync to be remote
    # via the rsync daemon
    # (See rsync's man page re the significance of '::' and 'rsync://')
    my $path = shift;
    return 1 if $path =~ m|^rsync://|;
    return index($path, '::') > -1;
}

#---------------------------------------------------------------------------------------------------

sub absPath ($) {
    # Convert a file or directory name into an absolute
    # path, with '~' (home directory) expansion.
    my $path = shift;
    # NOTE: This is Unix-specific
    # See http://stackoverflow.com/questions/4404628/abs-path-with-the-home-directory
    # and http://docstore.mik.ua/orelly/perl4/cook/ch07_04.htm
    $path =~ s{^~([^/]*)}{$1?(getpwnam($1))[7]:($ENV{HOME} || $ENV{LOGDIR} || (getpwuid($<))[7])}ex;
    return rel2abs($path);
}

#---------------------------------------------------------------------------------------------------

sub safeAbsPath ($) {
    # A version of absPath that does not change the path at all
    # if it contains a ':', i.e. if it's an rsync-style remote path
    my $path = shift;
    return $path if remote($path);
    return absPath($path);
}

#---------------------------------------------------------------------------------------------------

sub sourceDir ($) { 
    # Remote sources require an enclosing directory on the destination
    # to ensure that there is no overlap.
    # For example, two sources chris@example.com:~/home and fred@example.com:~/home
    # would both put files into /home on the destination without this.
    #
    # rsync deals with remote sources in the following formats:
    #   [USER@]HOST:SRC                 
    #   [USER@]HOST::SRC                
    #   rsync://[USER@]HOST[:PORT]/SRC  
    # In each case, the enclosing directory will be [USER-at-]HOST
    my $source = shift;
    return '' if !remote($source);
    my $dir;
    if ($source =~ m{^(rsync://|)(?<u>[^@]*)@(?<h>[^:/]+)}) {  
        $dir = "$+{u}-at-$+{h}";
    } elsif ($source =~ m{^(rsync://|)(?<h>[^:/]+)}) {  
        $dir = $+{h};
    }
    return $dir;
}

#---------------------------------------------------------------------------------------------------

sub snapshotInfo ($$) {
    # Get the amount of space that would be freed by deleting a file or directory.
    # The value returned is a number of blocks, which ought to be 512 bytes each.
    # Because of hard links, deleting a file may not free any space.
    # So this routine only counts files whose link count is 1.
    # Hard links /within/ the directory in question will 
    # give an underestimate of the amount of space that will be freed.
    # We'll assume that most of the links are between snapshots, not within them.

    # TODO could use 'du', which gives very similar results for
    # most snapshots, but picks one as the 'complete' one -- why?

    my $dest     = shift;
    my $snapshot = shift;   # Unix date of snapshot dir

    if (remote($dest)) {
        return (0, snapshotInfoRemote($dest, $snapshot));
    }

    # Now we're dealing with a local snapshot
    my $snapshotPath = snapshotPath($dest, $snapshot);
    debug "sI: snapshotPath = $snapshotPath\n", 7;

    # These totals have 'state' because otherwise Perl gives warnings
    # about sharing, not because we want them to retain their value.
    state $DStotalBlocks;
    state $AStotalBlocks;
    $DStotalBlocks = 0;
    $AStotalBlocks = 0;

    if (!-d $snapshotPath) {
        return (0,0);
    }

    # Use 'find' to traverse the directory, and accumulate totals
    find({ wanted => \&processItem, no_chdir => 1 }, $snapshotPath); 
    debug "\nDSTotal blocks: $DStotalBlocks    that's ". $DStotalBlocks*512 . " bytes\n", 7;

    sub processItem {
        # called from find().  $_ is the file name
        my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
            $atime,$mtime,$ctime,$blksize,$blocks) = stat($_);
        if (-f _) {
            debug "file: $_  n=$nlink  size=$size  blocks=$blocks\n", 7;
            $DStotalBlocks += $blocks if $nlink == 1;
            $AStotalBlocks += $blocks;
        } elsif (-d _) {
            debug "dir : $_  n=$nlink  size=$size  blocks=$blocks\n", 7;
            # dirs are never hard-linked, so always count them
            $DStotalBlocks += $blocks;
            $AStotalBlocks += $blocks;
        }
        # (ignore anything other than files and directories)
    }

    # Assume block size is 512  # FIXME
    return ($DStotalBlocks * 512, $AStotalBlocks * 512);
}

#---------------------------------------------------------------------------------------------------

sub snapshotInfoRemote0 ($$) {  # old version
    # Recursively get snapshot information for a remote destination via rsync.
    # rsync returns directory listings thusly (even for recent dates):
    #    -rwxr-xr-x         149 2008/06/13 13:56:30 textsmart
    #    drwxr-xr-x        4096 2011/05/07 17:41:48 40dnamer
    # and gives return code 23 if the directory is not found
    # 255 for wrong password, unknown host etc.
    # Note the lack of nlink information, so we can't calculate 'delete size'.

    my $dest = shift;
    my $dir  = shift;  # name of subfolder (initially the snapshot name)
    my $path = "$dest/$dir";    # not catdir!
    debug "sIR: path=$path\n", 9;

    my $totalSize = 0;

    # Get rsync listing
    my @items;
    my ($rc, $rc2) = systemcall($Opt{'rsync-cmd'}, "--bwlimit=$Opt{'bwlimit-in'} '$path/'", 9,9, \@items);
    if ($rc) {
        debug "sIR: rc=$rc rc2=$rc2\n", 9;
        return (0, 0);
    }

    debug "sIR: items: @items", 9;
    # Recursively process the items
    # Note, since this directory was created by this script on a previous run,
    # we'll assume we've got read access to everything (for now)
    foreach my $item (@items) {
        debug "sIR: item = $item\n", 9;
        # matching e.g.: 'drwxr-xr-x        4096 2011/05/07 17:41:48 40dnamer'
        if ($item =~ m|^(?<t>.)(?<p>.{9})\s+(?<size>\d+)\s\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2}\s(?<name>.*)$|) {
            next if $+{name} eq '.';
            next if $+{name} eq '..';
            if ($+{t} eq 'd') {
                debug "sIR: dir: t=$+{t} size=$+{size} name=$+{name} $item\n", 9;
                # directory -- recurse
                my $ast = snapshotInfoRemote($path, $+{name});
                debug "sIR: unrecursing, ast=$ast\n", 9;
                $totalSize += $ast;
            } elsif ($+{t} eq '-' or $+{t} eq 'l') {
                # file or symbolic link
                # (we're not following the symbolic link, just counting the space of the link itself)
                debug "sIR: file: t=$+{t} size=$+{size} name=$+{name} item=$item\n", 9;
                $totalSize += ceil($+{size} / 512) * 512; # a function for this TODO
            } else {
                # (ignore anything other than files and directories)
            }
        } else {
            # (ignore any non-matching lines)
            debug "sIR: ignoring $item\n", 3;
        }
    }

    return $totalSize;
}

#---------------------------------------------------------------------------------------------------

sub snapshotInfoRemote ($$) {
    # Get snapshot information for a remote destination via rsync.
    # rsync returns directory listings thusly (even for recent dates):
    #    -rwxr-xr-x         149 2008/06/13 13:56:30 textsmart
    #    drwxr-xr-x        4096 2011/05/07 17:41:48 40dnamer
    # and gives return code 23 if the directory is not found
    # 255 for wrong password, unknown host etc.
    # Note the lack of nlink information, so we can't calculate 'delete size'.

    my $dest = shift;
    my $dir  = shift;  # name of subfolder (initially the snapshot name)
    my $path = "$dest/$dir";    # not catdir!
    debug "sIR: path=$path\n", 3;

    my $totalSize = 0;

    # Get rsync listing into a temporary file
    my @items;
    my ($fh, $filename) = tempfile(UNLINK => 1);
    my ($rc, $rc2) = systemcall($Opt{'rsync-cmd'}, 
        "--recursive --bwlimit=$Opt{'bwlimit-in'} '$path/'", 3,3, $fh);
    debug "sIR: rc=$rc rc2=$rc2 filename=$filename\n", 3;
    if ($rc) {
        return (0, 0);
    }

    seek $fh, 0, 0;
    while (my $item = readline $fh) {
        debug "sIR: item = $item", 9;
        # matching e.g.: 'drwxr-xr-x        4096 2011/05/07 17:41:48 40dnamer'
        if ($item =~ m|^(?<t>.)(?<p>.{9})\s+(?<size>\d+)\s\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2}\s(?<name>.*)$|) {
            next if $+{name} eq '.';
            next if $+{name} eq '..';
            if ($+{t} eq '-' or $+{t} eq 'l' or $+{t} eq 'd') {
                # file or symbolic link or directory
                # (we're not following the symbolic link, just counting the space of the link itself)
                # (and we're counting the directory itself, not its contents)
                debug "sIR: t=$+{t} size=$+{size} name=$+{name}\n", 9;
                $totalSize += ceil($+{size} / 512) * 512; # a function for this TODO
            } else {
                # (ignore anything other than files and directories)
            }
        } else {
            # (ignore any non-matching lines)
            debug "sIR: ignoring $item\n", 3;
        }
    }

    return $totalSize;
}

#===================================================================================================

sub status ($\%;\@) {
    # Print a status report on existing snapshots
    my $dest   = shift;
    my %S      = %{(shift)};
    my @cSpecs;
    @cSpecs    = @{(shift)} if @_;
    my $count  = 0;
    my $totald = 0;
    my $totala = 0;
    my $ci = 0; # index into @cSpecs

    my $plevel = 2;
    my $llevel = 2;
    if ($Opt{status}) {
        # User has asked for status, so make sure it's printed and not logged
        $plevel = 0;
        $llevel = 9;
    }

    printlog "\nStatus report for $dest\n", $plevel,$llevel;
    printlog   '------------------' . '-' x length($dest) . "\n", $plevel,$llevel;
    if (!%S) {
        printlog "No snapshots found\n", $plevel,$llevel;
    }
    else {
        #my $nameLength = max(length(snapshotName($S[0])), 35);
        my $nameLength = max(length($Opt{template}) + 18, 35);
        printlog sprintf("%-*s   %13s %13s   %s\n", $nameLength, 'Snapshot (most recent first)', 
            'Delete Size', 'Real Size', @cSpecs ? 'Spec' : ''), $plevel,$llevel;
        printlog sprintf("%-*s   %13s %13s   %s\n", $nameLength, '-'x$nameLength, 
            '-----------', '-----------', @cSpecs ? '-----' : ''), $plevel,$llevel;
        foreach my $s (reverse sort keys %S) {
            my $name = snapshotName($s);
            $name .= "-$partialSuffix" if $S{$s};
            my ($dsize, $asize) = snapshotInfo($dest, $name);
            # find which cSpec applies
            while (@cSpecs and $cSpecs[$ci]->{beg} > $s) { 
                $ci += 1; 
            }; 
            my $label = '';
            $label = $cSpecs[$ci]->{label} if @cSpecs;
            printlog sprintf("%-*s   %13s %13s   %s\n", $nameLength, $name, 
                bytes($dsize), bytes($asize), $label), $plevel,$llevel;
            $count += 1;
            $totald += $dsize;
            $totala += $asize;
        }
        printlog sprintf("%-*s   %13s %13s\n", $nameLength, '-'x$nameLength, 
            '-----------', '-----------'), $plevel,$llevel;
        printlog sprintf("%8s %*d   %13s %13s\n", 'Totals: ', $nameLength-9, $count, 
            '', bytes($totala)), $plevel,$llevel;
        if ($count > 0) {
            my $averaged = floor($totald/$count);
            my $averagea = floor($totala/$count);
            printlog sprintf("%-*s   %13s %13s\n", $nameLength, 'Averages:', 
                bytes($averaged), bytes($averagea)), $plevel,$llevel;
        }
        if (!remote($dest)) {
            my $ref = df($dest, 1);
            if (defined($ref)) {
                printlog sprintf("%-*s     %13s\n", $nameLength+12, 
                    'Disk space used (not just by these snapshots):', bytes($ref->{used})), $plevel,$llevel;  
                printlog sprintf("%-*s     %13s\n", $nameLength+12, 
                    'Disk space available:', bytes($ref->{bfree})), $plevel,$llevel;
                printlog sprintf("%-*s     %13s\n", $nameLength+12, 
                    'Disk size:', bytes($ref->{blocks})), $plevel,$llevel;
            } else {
                printlog "Couldn't get disk space for $dest\n", $plevel,$llevel;
            }
        }
    }
}

#===================================================================================================
# 'periods'

# NB periods end on the beginning of the next one

sub getPeriod ($$) {
    # Return the beginning and end of the period containing
    # the moment specified
    # e.g. if the period is 1 ('d'), return the midnights
    # before and after the moment
    # (If $moment is already the beginning of the period,
    # then stay in that period - don't skip back one)
    # Note: this is for use in calendar mode only
    my $moment  = shift; # as Unix time
    my $periodn = shift;
    my ($beg, $end);
    debug "gP: periodn=$periodn moment=$moment (" . time2stamp($moment) . ")\n", 4;
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($moment);
    given ($periodn) {
        when (0) {
            $beg = timelocal(0,0,$hour,$mday,$mon,$year+1900);
            $end = $beg + HOUR;
        } 
        when (1) {
            $beg = timelocal(0,0,0,$mday,$mon,$year+1900);
            $end = $beg + DAY;
        } 
        when (2) {
            # localtime() returns weekday as 0=Sunday, 6=Saturday
            # $opt{weekstart} is 1..7
            $beg = timelocal(0,0,0,$mday,$mon,$year+1900);  # beginning of today
            my $beg1 = $beg; # for debugging only
            $beg -= (($wday- ($Opt{weekstart}-1) + 7) % 7) * DAY;   # adjust for weekday
            $end = $beg + DAY*7;
            debug "gP: mday=$mday mon=$mon year=$year wday=$wday ws=$Opt{weekstart} beg1=$beg1/" . 
                time2stamp($beg1) . " beg=$beg/" . time2stamp($beg) . 
                " end=$end/" . time2stamp($end) ."\n", 9;
        } 
        when (3) {
            $beg = timelocal(0,0,0,1,$mon,$year+1900);
            $end = date2time(DateCalc(time2date($beg), '0:1:0:0:0:0:0')); # +1month
        } 
        when (4) {
            $beg = timelocal(0,0,0,1,0,$year+1900);
            $end = timelocal(0,0,0,1,0,$year+1901);
        } 
        default {
            die "Invalid period number '$periodn' passed to getPeriod";
        }
    }
    return ($beg, $end);
}

#---------------------------------------------------------------------------------------------------

sub prevPeriod ($$) {
    # Given the beginning of one period, 
    # and the period number of the previous one, 
    # return the beginning and end of the previous one.
    # Note: this does not 'align' the period to whole weeks or months etc.,
    # e.g. month before 20110622-234400 is 20110522-234400--20110622-234400
    my $beg     = shift;
    my $periodn = shift;
    my $end = $beg;
    # subtract the delta for the relevant period:
    my $beg2 = date2time(DateCalc(time2date($beg), $PrevP[$periodn]));
    debug "pP: $LevelName[$periodn] before " . time2stamp($beg) . " is " . 
        pair2range($beg2, $end) . "\n", 9;
    return ($beg2, $end);
}

#---------------------------------------------------------------------------------------------------

sub fullPeriod ($$$) {
    # Returns true if the beg,end pair given are a full period
    # Note: this does not 'align' the period to whole weeks or months etc.,
    # e.g. 20110522-234400--20110622-234400 is a full month
    my $beg     = shift;
    my $end     = shift;
    my $periodn = shift;
    # Subtract the delta for the relevant period
    # from the end, and see if it matches the beginning
    my $beg2 = date2time(DateCalc(time2date($end), $PrevP[$periodn]));
    debug 'fP: ' . pair2range($beg, $end) . ' is' . (($beg == $beg2) ? '' : ' not') .
        " a full $LevelName[$periodn]\n", 9;
    return $beg == $beg2;
}

#---------------------------------------------------------------------------------------------------

sub fmtRange ($$) {
    # Format a timestamp range to make it readable
    my $beg = shift;
    my $end = shift;
    my $range = $end - $beg;
    my $begStamp = time2stamp($beg);
    debug "fR: range is " . pair2range($beg, $end) . "\n", 9;
    if ($range == HOUR) {
        return "hour from " . $begStamp;
    } elsif ($range == DAY) {
        return "day from " . $begStamp;
    } elsif ($range == WEEK) {
        return "week from " . $begStamp;
    }
    my $delta = DateCalc(time2date($beg), time2date($end), 9);
    debug "fR: delta is $delta\n", 9;
    if ($delta eq '+0:1:+0:0:0:0:0') {
        return "month from " . $begStamp;
    } elsif ($delta eq '+1:0:+0:0:0:0:0') {
        return "year from " . $begStamp;
    } else {
        return "period " . time2stamp($beg) . " to " . time2stamp($end);
    }
    # TODO expand this for multiple periods?
}

#---------------------------------------------------------------------------------------------------

sub countPeriods ($$$) {
    # Return the number of periods between two dates
    # (which may not be an integer)
    my $beg     = shift;
    my $end     = shift;
    my $periodn = shift;
    my $delta = DateCalc(time2date($beg), time2date($end));
    my $count = Delta_Format($delta, "%$DMperiod[$periodn]ys");
    return sprintf(($count == floor($count)) ? "%d" : "%.1f", $count);  # 1dp if not an integer
}

#===================================================================================================

# Filing system stuff 

sub snapshotName ($) {
    # Derive the snapshot name from its date
    my $stamp = shift;
    return "$Opt{template}-" . time2stamp($stamp);
}

#---------------------------------------------------------------------------------------------------

sub snapshotPath ($$) {
    # Derive the full snapshot path name from its date
    # (NOT using catdir because that would mess up remote rsync paths)
    my $dest     = shift;
    my $snapshot = shift;   # either name or Unix date
    return "$dest/" . snapshotName($snapshot) if (looks_like_number($snapshot));
    return "$dest/$snapshot";
}

#---------------------------------------------------------------------------------------------------

sub deleteSnapshot ($$) {
    # Delete a snapshot directory, returning
    # the number of errors encountered.
    my $dest     = shift; 
    my $snapshot = shift; # directory name
    debug "deleteSnapshot: doing $dest/$snapshot\n", 3;
    if ($Opt{'dry-run'}) {
        printlog "Dry run: would have deleted '$snapshot'\n", 1;
        return 0;
    }
    if (!$Opt{delete}) {
        printlog "Not deleting snapshot $snapshot' because of option 'delete=no'\n", 1;
        return 0;
    }
    if (remote($dest)) {
        # Destination is remote -- use some rsync trickery to delete the snapshot
        # (gleaned from http://lists.samba.org/archive/rsync/2010-October/025723.html)
        # This involves copying an empty directory onto the snapshot, and
        # removing the snapshot directory itself with filter cleverness.
        my @output;
        debug "dS: deleting snapshot the new way\n", 3;
        #my $cmd = "$Opt{'rsync-cmd'} --dirs -f 'R /$snapshot/**' -f '-!r /$snapshot' --delete $EmptyDir/ $dest/";
        my ($rc, $rc2) = systemcall($Opt{'rsync-cmd'}, 
            " --dirs -f 'R /$snapshot/**' -f '-!r /$snapshot' --delete $EmptyDir/ $dest/", 9,9, \@output);
        #debug "dS: delete cmd: '$cmd'\n", 3;
        #my $output = `$cmd`;
        debug "dS: rsync output: \n@output", 3;
        debug "dS: rsync returned $rc, $rc2\n", 3;
        # This returns no error if the snapshot didn't exist, which is fine
        if ($rc) {
            printlog "ERROR: failed to delete remote snapshot '$snapshot' from '$dest' (code $rc)", 1,1;
            return 1;
        }
        return 0;
    }
    # From here on, we're dealing with a local destination
    my $snapshotPath = catdir($dest, $snapshot);
    if (!-e $snapshotPath) {
        # doesn't exist - no worries
        return 0;
    } 
    if (!-d $snapshotPath) {    
        debug " it's not a directory!\n", 3;
        return 1;
    }
    remove_tree($snapshotPath, {error => \my $err});
    if (@$err) {
        printlog "ERROR: failed to delete snapshot $snapshot\n", 1,1;
        for my $diag (@$err) {
            my ($file, $message) = %$diag;
            if ($file eq '') {
                printlog "  general error: $message\n", 1,1;
            }
            else {
                printlog "  problem unlinking $file: $message\n", 1,1;
            }
        }
        # Rename the directory so that it's not considered in future runs
        rename($snapshotPath, "$snapshotPath-part-deleted");  
        return scalar @$err;
    }
    return 0;
}

#---------------------------------------------------------------------------------------------------

sub deleteSnapshots ($\@\@$) {
    # Delete the snapshots from the given list (latest first)
    my $dest      = shift;
    my @D         = @{(shift)};
    my @cSpecs    = @{(shift)};
    my $deleteNew = shift;
    my $ci = 0; # index into @cSpecs
    my $errors = 0;
    debug "dS: list is: " . (join(' ', map {time2stamp($_)} @D)) . "\n";
    foreach my $di (0..$#D) {
        my $d = $D[$di];
        while (@cSpecs and $cSpecs[$ci]->{beg} > $d) { 
            $ci += 1; 
        }; 
        if ($di == 0 and $deleteNew) {
            # Don't need to delete the new snapshot because we avoided creating it
            debug "dS: not deleting newest snapshot because it was not created\n", 3;
        } else {
           printlog "Deleting snapshot " . snapshotName($d) . 
                " because there are too many for spec " . $cSpecs[$ci]->{label} . "\n", 2;
           $errors += deleteSnapshot($dest, snapshotName($d));
        }
    }
    #printlog "Total of $errors errors while deleting snapshots!\n", 1; 
    return $errors;
}

#---------------------------------------------------------------------------------------------------

sub deleteOldSnapshots ($\@;$) {
    # Delete $n snapshots from the list of old ones
    # (oldest ones first)
    my $dest        = shift;
    my $expirablesR = shift;    # use ref, don't copy array, so that it gets popped
    my $n           = shift // 1;
    my $deleted = 0;
    debug "dOS: n=$n  expirables=@$expirablesR\n";
    while (@$expirablesR and $n > 0) {
        my $e = pop @$expirablesR;
        $n -= 1;
        my $snapshotName = snapshotName($e);
        printlog "Expiring old snapshot $snapshotName\n", 2;
        if (deleteSnapshot($dest, $snapshotName) == 0) {
            $deleted += 1;
        }
    }
    debug "dOS: deleted $deleted oldest snapshots\n", 3;
    return $deleted;
}

#---------------------------------------------------------------------------------------------------

sub renameOrDeleteSnapshot ($$) {
    # Rename or delete a snapshot, depending on options and errors.
    #
    # The standard thing to do is to rename a partially-complete snapshot
    # so that we know that it's not complete; if renaming can't be done,
    # then delete it.
    # It's all a balance between keeping files that have been backed up,
    # and not relying on snapshots that are incomplete.
    #
    # And it depends on whether the snapshot is local or remote: 
    # in particular there is no way to rename a snapshot via the rsync daemon.
    #
    # Returns 1 for renamed, 2 for deleted, 0 for error
    
    my $dest     = shift; 
    my $snapshot = shift; # directory name 
    my $rc = 0;

    if ($Opt{'dry-run'}) {
        printlog "Dry run: would have renamed '$snapshot' to '$snapshot-$partialSuffix'\n", 1;
        return 1;
    }

    if (remoteDaemon($dest)) {
        # Can't rename, just delete it
        $rc = deleteSnapshot($dest, $snapshot); 
        return $rc == 0 ? 2 : 0; 
    }

    if (remote($dest)) {
        # Use SSH to rename it 
        # (as usual, we're assuming passwords are taken care of elsewhere)
        my ($host, $path) = $dest =~ /^([^:]*):(.*)$/;
        my ($rc, $rc2) = systemcall('ssh', "$host mv '$path/$snapshot' '$path/$snapshot-$partialSuffix'", 1,1);
        # returns 0 for success
        printlog "rODS: remote: rc=$rc rc2=$rc2\n", 1;
        if ($rc) {
            # Renaming failed, try deleting
            # (because, for example, the user may have sudo permission for rsync but not for mv)
            $rc = deleteSnapshot($dest, $snapshot);
            return $rc == 0 ? 2 : 0; 
        }
        return $rc == 0 ? 1 : 0; 
    }

    # ...else, it's a local destination
    debug "rODS: local: rename '$dest/$snapshot', '$dest/$snapshot-$partialSuffix'\n", 3;
    $rc = rename "$dest/$snapshot", "$dest/$snapshot-$partialSuffix";
    # returns 1 for success
    # If renaming fails, deleting will too, so don't try.
    debug "rODS: rc=$rc\n", 3;
    return $rc == 1 ? 1 : 0; 
}

#===================================================================================================
# Handlings specs

sub calcPadding ($$$) {
    # Given a period level and a higher level and a timesofar,
    # return the number of low-levels needed to get to the next high-level
    # e.g. ('d', 'm', 23days) returns 5days
    # except that the levels are given numerically
    my $level1    = shift;
    my $level2    = shift;
    my $timesofar = shift;
    my $length1 = $Hours[$level1];
    my $length2 = $Hours[$level2];
    my $result = ($length2 - ($timesofar % $length2)) / $length1;
    debug "cP: l1=$level1 l2=$level2 tsf=$timesofar; returning $result\n", 3;
    if ($result != floor($result)) {
        debug "cP: auto-padded spec is not aligned!\n", 1;
    }
    return floor($result);
}

#---------------------------------------------------------------------------------------------------

sub parseSpecs ($) {
    # Parse the user's requested snapshot regime, 
    # e.g. '4d7,1d7,2w,1m6'
    #
    # The letter specifies a period, and can be
    #   h - hour 
    #   d - day
    #   w - week
    #   m - month
    #   y - year
    # The first number ('freq') specifies how many snapshots should occur
    # within the period, the second how many periods.
    # If the second number ('count') is omitted, it fills up the time
    # until the next spec; on the last spec, omitting the count
    # requests an 'unlimited' number of backups -- i.e. until the
    # backup disk is full.

    my $rawspec = lc(shift);
    debug "pS: rawspec = $rawspec\n", 2;

    my @rawspecs = split /,/, $rawspec;
    my @specs = ();
    my $warningcount = 0;
    my $errorcount   = 0;

    foreach my $spec (@rawspecs) {
        if ($spec =~ /^\s*(?<freq>\d+)\s*(?<period>[hdwmy])\s*(?<count>\d*)\s*$/) {
            my $freq = int($+{freq});
            my $period = $+{period};
            if ($freq == 0) {
                printlog "ERROR: Frequency 0 in spec '$spec' does not make sense\n", 1;
                $errorcount += 1;
                next;
            }
            my $count; 
            if ($+{count} ne '') { 
                $count = int($+{count});
                if ($count == 0) {
                    printlog "ERROR: Count 0 in spec '$spec' will make no snapshots\n", 1;
                    $errorcount += 1;
                    next;
                }
            } else {
                # no count specified -- will use padding; set to 0 for now
                $count = 0;
            }   
            push @specs, {
                rawspec => $spec, 
                freq    => $freq, 
                period  => $period, 
                periodn => $Level{$period}, # store $Level{$2} as well as $2 to avoid repeated look-ups
                count   => $count,
            };  
        } else {
            printlog "ERROR: Invalid spec '$spec'\n", 1;
            $errorcount += 1;
        }
    }

    return ($warningcount, $errorcount, @specs) if $errorcount;

    debug "Parsed spec:  " . join(',', map {$_->{freq}.$_->{period}.$_->{count}} @specs) . "\n", 3;

    # Check that the specs make sense
    debug "Checking specs...\n", 3;
    my $timesofar = 0; # in hours
    my $i = 0; # index into @specs
    foreach my $spec (@specs) {
        debug "Spec0: $spec->{freq} $spec->{period} $spec->{count}     \n", 4;
        if ($spec->{count} == 0) {
            # Pad spec to fill next period
            # e.g. 1d,1w4 -- the daily period gets padded to a week, i.e. 1d7,1w4
            # This is done even if --calendar is false.
            if ($i == @specs-1) {
                # last spec -- can't pad, so set count to lots
                printlog "NOTE: last spec padded forever\n", 3;
                $spec->{count} = UNLIMITED; 
            } elsif ($specs[$i+1]->{periodn} <= $spec->{periodn}) {
                printlog "WARNING: Can not pad spec $spec->{rawspec} because next spec is " .
                    "not at a higher level; count set to 1\n", 1;
                $warningcount += 1;
                $spec->{count} = 1;
            } else {
                my $padding = calcPadding($spec->{periodn}, $specs[$i+1]->{periodn}, $timesofar);
                debug "pS: padding $spec->{rawspec} to $LevelName[$specs[$i+1]->{periodn}]\n", 3;
                if ($padding == 0) {
                    # already at a multiple, so just do either 0 or a whole
                    # set of the next spec 
                    # leave at 0 for now
                    debug "No padding -- stay at 0\n", 3;
                } else {
                    # timesofar is not a whole multiple of speclevel+1, add some padding
                    # need to know how much padding -- so calcPadding should return that
                    debug "pS: padding by setting count to $padding\n", 3;
                    $spec->{count} = $padding;
                }
            }
        }
        debug "Spec1: $spec->{freq} $spec->{period} $spec->{count}\n", 9;
        # Check alignment
        if (!aligned($timesofar, $spec->{periodn})) {
            printlog "WARNING: Spec at $LevelName[$spec->{periodn}] level is not aligned - " 
                . " it starts at " . fmtHours($timesofar) . "\n", 1;
            $warningcount += 1;
        }
        $i += 1;
    }

    # Check that interval increases 
    my $lastint  = 0;
    $i = 0;
    foreach my $spec (@specs) {
        my $int = $Hours[$spec->{periodn}] / $spec->{freq};
        if ($int < $lastint) {
            printlog "WARNING: Interval is smaller for spec " . ($i+2) . 
                " ($spec->{rawspec}) than for " .  "previous one ($specs[$i-1]->{rawspec})\n", 3;
            $warningcount += 1;
        }
        $lastint = $int;
        $i += 1;
    }

    if (!$errorcount) {
        printlog "Validated specs: " . join(',', 
            map {$_->{freq}.$_->{period}.$_->{count}} @specs) . "\n", 3;
        $TotalSnapshots = 0; 
        foreach my $spec (@specs) {
            $TotalSnapshots += $spec->{freq} * $spec->{count};
        }
        if ($specs[-1]->{count} == UNLIMITED) {
            printlog "which will create an unlimited number of snapshots\n", 3;
        } else {
            printlog "which will create a total of $TotalSnapshots snapshots\n", 3;
        }
    }
    debug "Frequencies: " . join(', ', map {$_->{freq} / $Hours[$_->{periodn}]} @specs) . "\n", 9;

    return $warningcount, $errorcount, @specs;  
}

#---------------------------------------------------------------------------------------------------

sub processSpecs () {
    # Validate the specs given 
    my ($warnings, $errors, @specs) = parseSpecs($Opt{spec}); 
    if ($errors) {
        printlog "ERROR: One or more specs is invalid -- stopping\n", 1;
        exit EXITSPECS;
    }
    if ($warnings and $Opt{strict}) {
        printlog "ERROR: Warnings when parsing specs, and strict mode in effect -- stopping\n", 1;
        exit EXITSPECS;
    }
    if (!@specs) {
        printlog "ERROR: No valid specs found -- stopping\n", 1;
        exit EXITSPECS;
    }
    return @specs;
}

#===================================================================================================

sub getSList ($) { # obsolete!  FIXME
    # Read in the existing snapshots, 
    # returning a list of snapshot dates extracted from their directory names.
    # Uses rsync in case the destination is remote.
    my $dir = shift;
    my $template = $Opt{template};  
    my @S;
    debug "gSL: dir=$dir template=$Opt{template}\n", 9;
    my @listing;
    my ($rc, $rc2) = systemcall($Opt{'rsync-cmd'}, 
        "--bwlimit=$Opt{'bwlimit-in'} '$dir/'", 9,9, \@listing);    
    debug "gsL: rc=$rc listing: @listing n=" . scalar @listing ."\n", 9;
    return @S if $rc;
    foreach (@listing) {
        chomp;
        #debug "_: $_\n";
        if (/($template)-(?<Y>\d{4})(?<M>\d{2})(?<D>\d{2})-(?<h>\d{2})(?<m>\d{2})(?<s>\d{2})/) {
            next if $+{M} < 1;
            next if $+{M} > 12;
            next if $+{D} < 1;
            next if $+{D} > daysInYearMonth($+{Y}, $+{M}-1);
            next if $+{h} > 23;
            next if $+{m} > 59;
            next if $+{s} > 59;
            push @S, stamp2time($_);
        }
    }
    return reverse sort @S;
}

sub getSnapshotList ($) {
    # Read in the existing snapshots, 
    # returning a list of snapshot dates extracted from their directory names
    # as a hash, with flags indicating partial snapshots
    # Uses rsync in case the destination is remote.
    my $dir = shift;
    my $template = $Opt{template};  
    my %S;
    debug "gSL: dir=$dir template=$Opt{template}\n", 9;
    my @listing;
    my ($rc, $rc2) = systemcall($Opt{'rsync-cmd'}, 
        "--bwlimit=$Opt{'bwlimit-in'} '$dir/'", 9,9, \@listing);    
    debug "gsL: rc=$rc listing: @listing n=" . scalar @listing ."\n", 9;
    return %S if $rc;
    foreach (@listing) {
        chomp;
        # Skip over any template with an invalid date (shouldn't happen)
        if (/($template)-(?<Y>\d{4})(?<M>\d{2})(?<D>\d{2})-(?<h>\d{2})(?<m>\d{2})(?<s>\d{2})(?<ps>-$partialSuffix)?/) {
            next if $+{M} < 1;
            next if $+{M} > 12;
            next if $+{D} < 1;
            next if $+{D} > daysInYearMonth($+{Y}, $+{M}-1);
            next if $+{h} > 23;
            next if $+{m} > 59;
            next if $+{s} > 60;
            $S{stamp2time($_)} = ($+{ps} ? 1 : 0);
        }
    }
    return %S;
}

#---------------------------------------------------------------------------------------------------

sub visualise ($$$$@) {
    # Draw a pretty picture of the actual and ideal snapshots
    # given pairs of (label, array)
    my $beg        = shift;
    my $end        = shift;
    my $showPeriod = shift;
    my $best       = shift // 0; 
    my $labelwidth = 5;
    #my ($columns, $rows) = Term::Size::chars *STDOUT{IO};
    #$columns = max($columns, 132); # minimum, and also if there's no tty
    my $columns = 80;
    my $size = $columns - $labelwidth - 3;  # - 18; # -18 for log timestamp
    my $scale = ceil(($end - $beg) / $size);    
    debug "visualise: beg=$beg end=$end (" . fmtRange($beg,$end) . ") size=$size scale=$scale\n", 6;

    while (@_ > 1) {
        my $label = pack("A$labelwidth", shift);    # force label to specified width
        my @a     = @{(shift)};
        my @points = (0) x ($size+1);
        foreach my $a (@a) {
            my $pos = floor(($a - $beg) / $scale);
            if ($pos < 0 or $pos > $size) {
                debug "vis: out of range: $pos should be >= 0 and <= $size, a=$a (" . 
                    time2stamp($a) . ")\n", 1;
            }   
            if ($label eq 'Ideal' and !$points[$pos] and $best == $a) {
                $points[$pos] = 'B';  # this is a nasty hack! what if it later does 'B'+1 ?
            }
            else {
                $points[$pos] += 1;
            }
        }
        my $period = '';
        $period = fmtRange($beg, $end) if $showPeriod;
        printlog "$label|" . join('', 
            map {
                !defined($_) ? '.' : 
                ($_ eq 'B')  ? 'B' :            # 'best' if label is 'Ideal' 
                ($_ < 1)     ? '.' : 
                ($_ > 9)     ? '*' : 
                               $_
            } 
            @points) . "| $period\n", 1;
    }
}

#---------------------------------------------------------------------------------------------------

sub arrayDiff (\@\@) {
    # Return elements of X that aren't in Y.
    # This doesn't work if there are duplicates in either array!
    # (That's OK, 'cos we're only using it for arrays of snapshot
    # timestamps which are required to be unique.)
    my @X = @{(shift)};
    my @Y = @{(shift)};
    my %Y = map {$_=>1} @Y; # hash version of @Y
    return grep(!defined $Y{$_}, @X);
}

#---------------------------------------------------------------------------------------------------

sub getDeleteList (\@\@;$) {
    # Given a list S of existing snapshots as a list of timestamps,
    # return a list of the ones to be deleted
    # by checking against the list of cSpecs.
    my @S      = @{(shift)};
    my @cSpecs = @{(shift)};
    my $plevel = shift // 3;    # optional to override print level

    my @allMatches;
    my @D;
    my $firstbeg = MAXTIME; 
    my $lastend = 0;

    debug "\ngetDeleteList: no. of snapshots = " . @S . ", no of cspecs = " . @cSpecs . "\n", 9;

    foreach my $c (@cSpecs) {

        my $beg = $c->{beg};
        my $end = $c->{end};
        debug "\ngDL processing cSpec $c->{label} beg=$beg end=$end\n", 9;

        # find S's in that period
        my @C; # candidates, just identified by timestamp
        foreach my $s (@S) {
            if ($s >= $beg and
                $s <  $end    ) {
                push @C, $s;
            }
        }
        debug " candidates: @C total: " . @C . "\n", 9;
        if (@C) {
            # there are snapsnots in this period, so adjust the overall range
            $firstbeg = $beg if $beg < $firstbeg;
            $lastend  = $end if $end > $lastend;
        }
        if (!@C) {
            # no candidates found
            debug " no candidates found to match $c->{label} for period " . 
                time2stamp($beg) . '...' . time2stamp($end) . "\n", 9;
        } elsif (@C <= $c->{freq}) {
            debug " no more candidates found than required for $c->{label}\n", 9;
            push @allMatches, @C;
        } else {
            my @I = getMatchingSnapshots($beg, $end, $c->{best}, $c->{freq}, \@C, \@S);
            push @allMatches, @I;
            push @D, arrayDiff(@C, @I);
            debug "storing keepers and deleters:\n\@C:   " . join(' ', sort @C) . "\n\@I:   " . 
                join(' ', sort @I) . "\ndiff: " . join(' ', sort(arrayDiff(@C, @I))) . "\n", 9;
            debug "\@D is now: " . join(' ', sort @D) . "\n", 9;
        }

    } # foreach spec

    # Summarise keepers and deleters over whole period
    printlog "\nSummary of all existing snapshots: " . time2stamp($firstbeg) . ' - ' . 
        time2stamp($lastend) . "\n", $plevel; 
    printlog "--------------------------------------------------------------------\n", $plevel;
    #printlog "Snapshots: " . @S . ": @S\n", $plevel;
    #printlog "Keepers:   " . @allMatches . ": @allMatches\n", $plevel;
    #printlog "Deleters:  " . @D . ": @D\n", $plevel;
    printlog @S . ' snapshots, ' . @allMatches . ' to be kept, ' . @D . " to be deleted\n", $plevel;
    visualise($firstbeg, $lastend, 0, 0, 'Snap' => \@S, 'Keep' => \@allMatches, 'Del' => \@D)
        if ($Opt{verbose} >= $plevel);

    return @D;  # list of timestamps of snapshots to delete
}

#---------------------------------------------------------------------------------------------------

sub snapshotAfter ($$) {
    # Return the snapshot after the one given (if any)
    my $this = shift;   # the snapshot to compare 
    my $sR   = shift;   # array ref of all snapshots in descending order
    my $prevs = 0; # If none found, return 0 which will test as false
    foreach my $s (@$sR) {
        return $prevs if $s <= $this;
        $prevs = $s;
    }
    return $$sR[-1];
}

#---------------------------------------------------------------------------------------------------

sub snapshotBefore ($$) {
    # Return the snapshot before the one given (if any)
    my $this = shift;   # the snapshot to compare 
    my $sR   = shift;   # array ref of all snapshots in descending order
    foreach my $s (@$sR) {
        return $s if $s < $this;
    }
    return 0;   # None found, return 0 which will test as false
}

#---------------------------------------------------------------------------------------------------

sub getMatchingSnapshots ($$$$\@\@) {
    # Get a list of snapshots in the given period that
    # are the best match for the ideal/expected snapshots
    my $beg    = shift;         # beginning of period 
    my $end    = shift;         # end of period
    my $best   = shift;         # seconds from $beg to preferred snapshot time
    my $freq   = shift;         # number of snapshots in period
    my @S      = @{(shift)};    # array of timestamps of existing snapshots (just those in range)
                                # in descending order
    my $allSR  = shift;         # array ref of ALL existing snapshots
                                # also in descending order

    my $range  = $end - $beg;   # the length of the period in seconds
    debug "getMatchingSnapshots: beg=$beg end=$end best=$best freq=$freq\n", 4;
    debug " (first S = $S[0]    last S = $S[-1]  -- in descending order)\n", 9;

    # Special case: if freq is zero, delete all snapshots (i.e. keep none)
    if ($freq == 0) {
        debug "gMS: freq==0 -- deleting all\n", 4;
        return ();
    }

    # Special case: if freq is -1, keep all snapshots
    if ($freq == -1) {
        debug "gMS: freq==-1 -- keeping all\n", 4;
        return @S;
    }

    # Calculate closeness factor for each snapshot
    # from formula closeness=r/(p+n)
    # where p = distance to previous snapshot (or r if none)
    #       n = distance to next snapshot (or n if none)
    #       r = range (see above)
    # possible tuning:
    #      - set p or n to less than r if being on the end gets too much weight
    #       = we're currently trying r/2
    #       - could even make it an option
    my @closeness;
    my $endfactor1 = 0.5;
    my $endfactor2 = 0.5; #20;
    my $totalC = 0;
    for my $s (0..$#S) {
        # Get distance to previous/next snapshot 
        # (may be beyond current period)
        my $previous = snapshotBefore($S[$s], $allSR);
        my $next     = snapshotAfter($S[$s], $allSR);
        # If previous/next don't exist, calculate a closeness value
        # that is scaled to $range with a tuning factor
        my $p = $previous ? abs($S[$s] - $previous) : $range * $endfactor1;
        my $n = $next     ? abs($next  - $S[$s])    : $range * $endfactor2;
        debug "gMS: previous=$previous next=$next p=$p n=$n\n", 6;
        # Check if they're infinitely close! 
        # (shouldn't happen because snapshots can't share a date)
        push @closeness, ($p+$n == 0) ? 9999999999 : $range/($p+$n);
        $totalC += $closeness[-1];
    }
    my $averageC = $totalC / scalar @S;
    
    my $bestTime = $beg + $best;    # best as Unix time, not offset from $beg

    my $oldBeg = $beg;
    my $oldEnd = $end;

    # 'Shelf-bracket factor' is the size of the extra space
    # between the bracket and the end of the shelf, as
    # a proportion of the distance between brackets:
    #            
    # Shelf:     ====================================
    # Brackets:       \/          \/          \/
    #            <-f1-><----i----->            <-f2->
    # 
    # In terms of snapshots, the shelf represents the range
    # under consideration, and the ideal snapshot times are the brackets.
    #
    # Set each factor to 1/2, assuming the other half will appear
    # in the adjoining period:
    my $sbFactor1 = 0.5;
    my $sbFactor2 = 0.5;

    # Adust beg...end range around a 'close' group of snapshots
    # (i.e. ones that are not near snapshots in previous and next periods)
    # for better spacing of the 'ideals'.
    # A sequence of snapshots is considered a 'group' if either
    # the first or last has a closeness less than 50% (tunable)
    # of the average closesness.
    my $groupFactor = 0.50;     # tuning 
    # (don't forget that @closeness is in descending order by time)
    if ($closeness[0] < ($averageC * $groupFactor)) {
        # Adjust end of range 
        # (+1 to make sure last snapshot is IN the range)
        $end = $S[0];
        debug "gMS: adjusting end of range for closeness, now $end (" . time2stamp($end) . ")\n", 4;
        $sbFactor2 = 0;
    }
    if ($closeness[-1] < ($averageC * $groupFactor)) {
        # Adjust beginning of range
        $beg = $S[-1];
        debug "gMS: adjusting beg of range for closeness, now $beg (" . time2stamp($beg) . ")\n", 4;
        $sbFactor1 = 0;
    }

    # Make sure best isn't out of range
    # (this is needed sometimes even if the closeness adjustment above isn't used)
    # (the -1 is to make sure $best is IN the range)
    $bestTime = $beg   if $bestTime <  $beg;
    $bestTime = $end-1 if $bestTime >= $end;
    debug "gMS: bestTime is now $bestTime (" . time2stamp($bestTime) . ")\n", 4;

    # Recalculate $best as offset into beg..end range
    $best = $bestTime - $beg;
    # and recalculate $range accordingly
    $range = $end - $beg;   # the length of the period in seconds
    debug "gMS: best is now $best, range is now $range, best/range is now ".$best/$range."\n", 4;

    # Initially space out the ideal snapshots evenly
    # (these values are used if there is no 'best' time)
    my @I;
    for my $i (0..$freq-1) {
        $I[$i] = $beg + ($i+0.5) * $range/$freq;
    }

    # Then take into account the h/d/w/m/ybest options
    @I = ();
    # put the best one in first
    $I[0] = $bestTime;
    debug "gMB: best=$I[0]\n", 8;
    if ($freq > 1) {  # more than one ideal to place, not just the best one
        my $strategy = 1;
        #my $offset = $best % $interval;
        #debug "interval = $interval, best=$best, offset=$offset\n";
        if ($strategy == 1) {
            # better: calculate how many should go before and after,
            # then spread them out.
            #my $bbyr = $best / $range;
            my $befores = floor(($best              / $range) * $freq);
            my $afters  = floor((($range-1 - $best) / $range) * $freq);
            # (the '-1' above is to avoid fence-post errors:
            # we don't want to consider the final second of the period)
            debug "gMS: strategy 1:  befores=$befores  afters=$afters\n", 9;
            if ($befores > 0) {
                # befores
                my $interval = floor($best / ($befores + $sbFactor1));
                debug "gMS: s1: befores: interval=$interval\n";
                my $ptr = $beg + $best;
                for my $i (1..$befores) {
                    $ptr -= $interval;
                    debug "gMS: B - i=$i ideal = $ptr " . time2stamp($ptr) . "\n";                                         
                    unshift @I, $ptr;
                }
            }
            if ($afters > 0) {
                # afters
                my $interval = floor(($range-$best) / ($afters + $sbFactor2));
                debug "gMS: s1: afters : interval=$interval\n";
                my $ptr = $beg + $best;
                for my $i (1..$afters) {
                    $ptr += $interval;
                    debug "gMS: A - i=$i ideal = $ptr " . time2stamp($ptr) . "\n";
                    push @I, $ptr;
                }
            }
            # - that calc works, but is it really better??  
        } else {
            # FIXME make this an option, or (probably) delete it
            # Strategy 2
            my $interval = floor($range / $freq);   # time between snapshots to nearest second
            # add more before the best one
            my $ptr = $beg + $best - $interval;
            while ($ptr >= $beg and @I < $freq) {   # 2nd test to avoid fence-post error
                unshift @I, $ptr;
                debug "gMS: before best=$I[0]\n", 8;
                $ptr -= $interval;
            }
            # add more after the best one
            $ptr = $beg + $best + $interval;
            while ($ptr < $end and @I < $freq) {
                push @I, $ptr;
                debug "gMS: after best=$I[0]\n", 8;
                $ptr += $interval;
            }
        }
    }

    debug " ideals: @I total: " . @I . "\n";

    # Generate all combinations of the ideal number of snapshots
    # out of the existing snapshots, then calculate a score for each
    # and choose the one with the best score
    # FIXME -- maybe we should leave first and last fixed if they're already aligned
    my @combs = combinations(scalar @I, 0..$#S); 
    my $minct = MAXTIME;
    my $mincti = 0;
    my $ci = 0; # or use while/each ?
    foreach my $comb (@combs) {
        my $combtotal = 0;
        # Note: ideals are already in ascending order, need to sort the comb
        # (in descending order of indexes, i.e. ascending order of dates)
        @$comb = sort {$b <=> $a} @$comb;
        if ($ci < 2) {
            debug "comparing these ideals: \n", 9;
            debug "  @I\n", 9;
            debug " with these snapshots:\n", 9;
            debug "  " . join(' ', map {$S[$_]} @$comb) . "\n", 9;
        }
        foreach my $i (0..$#I) {
            $combtotal += abs($I[$i] - $S[$$comb[$i]]) * $closeness[$$comb[$i]];
        }
        if ($combtotal < $minct) {
            $minct = $combtotal;
            $mincti = $ci;
        }
        $ci += 1;
    }
    debug " " . @combs . " combinations tested\n", 3;
    #debug "    best combination, with total $minct/$combtotal[$mincti], is " . 
    #   join(' ', sort {$combs[$mincti]}) . "\n";
    debug " best combination, with total $minct, is " . 
        join(' ', sort {$b <=> $a} @{$combs[$mincti]}) . "\n", 3;
    my @bestMatches = sort(map {$S[$_]} @{$combs[$mincti]});    # convert indexes back to snapshots 
    debug " best matches: @bestMatches total: " . @bestMatches . "\n", 3;
    debug " closeness (old to new): " . join(' ', (map {sprintf("%.2f", $_)} reverse @closeness)) . 
        ", average: $averageC\n", 3;
    visualise($oldBeg, $oldEnd, 1, $bestTime, 
        'Snap'  => \@S, 
        'Ideal' => \@I, 
        'Match' => \@bestMatches) if $Opt{debug} >= 3;

    return @bestMatches;
}   # getMatchingSnapshots;

#---------------------------------------------------------------------------------------------------

sub bestOffset {
    # Returns the 'best' option for a period as
    # the offset in seconds from the beginning
    # of the period.
    my $period = shift;
    my $time   = shift; # a time within the period
    my $best = undef;   # default - no best time specified

    if ($period eq 'h' and $Opt{hbest}) {
        # Best is a minute from 0-59
        $best = $Opt{hbest} * MINUTE;
    } elsif ($period eq 'd' and $Opt{dbest}) {
        # Best is specified as an hour from 0-23.99
        # so calculate the fraction of day
        $best = $Opt{dbest} * HOUR;
    } elsif ($period eq 'w' and $Opt{wbest}) {
        # Best is a number from 1 to 7 indicating
        # the day.  Choose the middle of the day (is that OK?)
        # TODO allow e.g. 'Friday 5pm' as supplied by Date::Manip
        $best = ($Opt{wbest}-0.5) * DAY;
    } elsif ($period eq 'm' and $Opt{mbest}) {
        # Best is the day of the month -- assume noon.
        my $mbest = min($Opt{mbest}, daysInMonth($time));
        $best = ($mbest-0.5) * DAY;
    } elsif ($period eq 'y' and $Opt{ybest}) {
        # Best is the day of the year -- assume noon
        my $ybest = min($Opt{ybest}, daysInYear($time));
        $best = ($ybest-0.5) * DAY;
    } else {
        die "invalid period in bestOffset";
    }
    return $best;
}

#---------------------------------------------------------------------------------------------------

sub snapshotsInPeriod (\@$$;$) {
    # Given a list of snapshot dates in descending order,
    # and a period (beginning and end dates),
    # return the number of snapshots in the period
    # or an array of said snapshots, depending on the last parameter.
    # (Can't use wantarray, because this often gets
    # called in list context even when just the count is needed)
    my @S = @{(shift)};
    my $beg = shift;
    my $end = shift;
    my $returnArray = shift // 0;
    my $count = 0;
    my @SIP;
    foreach my $s (@S) {
        last if $s < $beg;
        $count += 1 if $s < $end;
        push @SIP, $s if ($s < $end and $returnArray);
    }
    debug "snapshotsInPeriod $beg..$end " . time2stamp($beg) . '..' . time2stamp($end) . 
        " = $count\n", 9;
    return @SIP if $returnArray;
    return $count;
}

#---------------------------------------------------------------------------------------------------

sub nextOldestSnapshot ($\@) {
    # Return the first snapshot before the given date
    # or 'undef' if there is no such snapshot
    my $time = shift;
    my @S    = @{(shift)};
    my $nextOldest;
    foreach my $s (@S) {
        debug "nOS(" . time2stamp($time) . ") returning " . time2stamp($s) . "\n", 3 if $s < $time;
        return $s if $s < $time;
    }
        debug "nOS(" . time2stamp($time) . ") returning undef\n", 3;
    return undef;
}

#===================================================================================================

sub findGoodPeriods ($$$\@) {
    # Starting with period ($beg, $end) and working backwards in time, 
    # check for $count periods each with at least $freq snapshots.
    # Return the [beginning, end, good?, snapshots-in-period, period-count] for each period
    # (including the gaps between the 'good' periods).
    # This version keeps periods aligned to calendar days/weeks/months etc.
    # The ($beg, $end) of the last one is then where we're up to.
    my $beg  = shift;
    my $end  = shift;
    my $spec = shift;
    my @S    = @{(shift)};

    my $gpCount = 0;
    my @good;
    if (!@S) {
        # No snapshots, so no good periods
        debug "fGP: \@S is empty!\n", 3;
        return ($gpCount, @good);
    }
    my $oldestSnapshot = $S[-1];
    debug "fGP: range=" . pair2range($beg, $end) . " freq=$spec->{freq} periodn=$spec->{periodn} " . 
        "count=$spec->{count} oldestS=" . time2stamp($oldestSnapshot) . "\n", 3;

    # Special case:
    # if this is an 'unlimited' spec, then its count will be (effectively) infinite
    # -- we need to keep filling periods until there are no more snapshots
    # -- if any periods have less than freq, then relax, just treat them as full
    # This is all dealt with simply by the condition count==UNLIMITED below.

    my $lastPeriodGood = 1;
    while (($end     > $oldestSnapshot) and
           ($gpCount < $spec->{count} )     )  {
        my $sip = snapshotsInPeriod(@S, $beg, $end);
        if (($spec->{count} == UNLIMITED) or 
            ($sip >= $spec->{freq}      )    ) {
            push @good, [$beg, $end, 1, $sip, 1];
            $gpCount += 1;    # count it as good
            $lastPeriodGood = 1;
        } else {
            # This period does not have enough snapshots to be considered 'good'
            if (!$lastPeriodGood) {
                # last one was not good either -- combine them
                $good[-1][0]  = $beg;
                $good[-1][3] += $sip;
                $good[-1][4] += 1;
            } else {
                # this is the first bad one
                push @good, [$beg, $end, 0, $sip, 1];
            }
            $lastPeriodGood = 0;
        }
        ($beg, $end) = prevPeriod($beg, $spec->{periodn});
    }
    debug "fGP: returning c=$gpCount, " . (join(' ', 
        map {pair2range(@{$_}[0], @{$_}[1]) . "=@{$_}[2]:@{$_}[3]/@{$_}[4]"} @good)) . "\n", 3;
    return ($gpCount, @good);
}

#---------------------------------------------------------------------------------------------------

sub findGoodPeriodsNoCal ($$$\@) {
    # Starting with period ($beg, $end) and working backwards in time, 
    # check for $count periods each with at least $freq snapshots.
    # Return the [beginning, end, good?, snapshots-in-period, period-count] for each period
    # (including the gaps between the 'good' periods).
    # This version does not keep periods aligned to calendar days/weeks/months etc.
    # The ($beg, $end) of the last one is then where we're up to.
    my $beg  = shift;
    my $end  = shift;
    my $spec = shift;
    my @S    = @{(shift)};

    my $gpCount = 0;
    my @good;
    if (!@S) {
        # No snapshots, so no good periods
        debug "fGPnC: \@S is empty!\n", 3;
        return ($gpCount, @good);
    }
    my $oldestS = $S[-1];
    debug "\nfGPnC: range=" . pair2range($beg, $end) . " freq=$spec->{freq} periodn=$spec->{periodn} " . 
    "count=$spec->{count} oldestS=" . time2stamp($oldestS) . "\n", 3;

    # Special case:
    # if this is an 'unlimited' spec, then its count will be (effectively) infinite
    # -- we need to keep filling periods until there are no more snapshots
    # -- if any periods have less than freq, then relax, just treat them as full
    # This is all dealt with simply by the condition count==UNLIMITED below.

    while (($end > $oldestS) and
        ($gpCount < $spec->{count})   ) {
        debug "===fGPnC: looking for $spec->{freq} snapshots in one $spec->{period}\n", 3;
        my $sip = snapshotsInPeriod(@S, $beg, $end);
        # Look for a contiguous period first
        if (($spec->{count} == UNLIMITED) or 
            ($sip >= $spec->{freq}      )    ) {
            push @good, [$beg, $end, 1, $sip, 1];
            $gpCount += 1;    # count it as good
            debug "fGPnC: good one: range=" . pair2range($beg, $end) . " sip=$sip pc=1\n";
        } else {
            # No contiguous period --
            # find a group of freq snapshots within a period 
            # keeping track of the gap between that group and the last good period
            my $gapend = $end;
            my $skippedSnapshots = 0;
            my $nextS = $end;   # start search where we're up to
            while (($nextS = nextOldestSnapshot($nextS, @S))               and  # yes, '=' not '=='
                   (($beg, $end) = prevPeriod($nextS+1, $spec->{periodn})) and
                   (($sip = snapshotsInPeriod(@S, $beg, $end)) < $spec->{freq})) {
                # carry on looking
                $skippedSnapshots += 1;
                debug "fGPnC: skipping nextS=" . time2stamp($nextS) . ", skipped=$skippedSnapshots\n", 3;
            }
            my $pc = countPeriods($end, $gapend, $spec->{periodn});
            if ($nextS) {
                # found a $nextS which marks the end a good period
                push @good, [$end, $gapend, 0, $skippedSnapshots, $pc]; 
                debug "fGPnC: gap: range=" . pair2range($end, $gapend) . " skippedSnapshots=$skippedSnapshots pc=$pc\n";
                push @good, [$beg, $end, 1, $sip, 1];
                debug "fGPnC: good after gap: range=" . pair2range($beg, $end) . " sip=$sip pc=1\n";
                $gpCount += 1;
            } else {
                # ran out of snapshots
                push @good, [$oldestS, $gapend, 0, $skippedSnapshots, $pc];
                debug "fGPnC: gap to oldestS: range=" . pair2range($oldestS, $gapend) . " skippedSnapshots=$skippedSnapshots pc=$pc\n";
            }

        }
        ($beg, $end) = prevPeriod($beg, $spec->{periodn});
    }

    debug "fGPnC: returning c=$gpCount, " . (join(' ', 
        map {pair2range(@{$_}[0], @{$_}[1]) . "=@{$_}[2]:@{$_}[3]/@{$_}[4]"} @good)) . "\n", 3;
    return ($gpCount, @good);
}

#---------------------------------------------------------------------------------------------------

sub findAllPeriods ($$$\@) {
    # Expand a spec into a list of periods, starting with ($beg, $end).
    # Unlike findGoodPeriods, this doesn't care if the periods
    # have the expected number of snapshots
    my $beg  = shift;
    my $end  = shift;
    my $spec = shift;
    my @S    = @{(shift)};
    my @all;
    for my $c (1..$spec->{count}) {
        my $sip = snapshotsInPeriod(@S, $beg, $end);
        # each entry is: [beginning, end, good?, snapshots-in-period, period-count]
        push @all, [$beg, $end, 1, $sip, 1];
        ($beg, $end) = prevPeriod($beg, $spec->{periodn});
    }
    return ($spec->{count}, @all);
}   

#===================================================================================================
# Specs

sub compileSpecs ($\@\%;$) {  
    # 'Compile' the specs into a list that takes into account
    # the current date and existing snapshots.
    # Works backwards in time from 'now'.
    # TODO use the partial flags in %S
    my $now        = shift;
    my @specs      = @{(shift)};
    my %S          = %{(shift)};    
    my @S          = reverse sort keys %S;    # most recent first
    my $precompile = shift // 0;

    my $pl = 2;
    if ($precompile and !$Opt{debug}) {
        # In 'pre-compile' mode, override the print and log levels
        # so that the user doesn't see unnecessary messages
        # (there may only be debug messages here later) TODO
        $pl = 9;
    }    
    debug "compileSpecs: now=" . time2stamp($now) . " precompile=$precompile\n", 3;

    my $firstSpec = 1;  # first spec applies to the current period
    my @cSpecs;
    my $oldestS = @S ? $S[-1] : $now; # back to the oldestS idea

    my $end = $now + 1; # +1 to ensure 'now' is within the current period
    debug "cS: starting with oldestS=" . time2stamp($oldestS) . ", end=" . time2stamp($end) . "\n", 3;

    foreach my $spec (@specs) {

        my $beg;
        my $p = 1; # count the periods
        my @goodPeriods;
        my $gpCount = 0;

        if ($Opt{calendar}) {
            # beginning of period containing (end-1)  getPeriod(end, period)
            ($beg, undef) = getPeriod($end - 1, $spec->{periodn});
        } else {
            # period that ends now
            ($beg, undef) = prevPeriod($end, $spec->{periodn});
        }

        debug "cS: [1] spec=$spec->{rawspec} beg,end=" . pair2range($beg,$end) . "\n", 3;

        if (!fullPeriod($beg, $end, $spec->{periodn})) { 
            # This is a partial period -- either the current period (if it's the first spec),
            # or because of a change of period
            my $sip = snapshotsInPeriod(@S, $beg, $end);
            if ($firstSpec and $sip >= $spec->{freq}) {  # FIXME reverse this test and get rid of the else
                # This partial period can count as a good one -- do nothing here
                debug "cS: firstSpec and enough S's -- will count as good\n", 3;
            } else {
                push @cSpecs, {
                    beg       => $beg, 
                    end       => $end, 
                    freq      => ($firstSpec and !$Opt{'delete-cp'}) ? -1 : $spec->{freq},    # -1 means keep all
                    count     => $spec->{count},
                    period    => $spec->{period},
                    best      => min(bestOffset($spec->{period}, $beg), $end-$beg-1),  # limit best to partial period
                    label     => $spec->{rawspec} . ($firstSpec ? '-current' : '-partial'),
                    snapshots => $sip,
                };  
                # If $end>$oldestS, we should append 'empty' to the label 
                $cSpecs[-1]->{label} .= ' empty' if $end <= $oldestS;  # is this a nasty hack?  
                debug "cS: created cSpec [1] " . pair2range($cSpecs[-1]->{beg},$cSpecs[-1]->{end}) . " freq=$cSpecs[-1]->{freq} count=$cSpecs[-1]->{count} period=$cSpecs[-1]->{period} best=" . time2stamp($cSpecs[-1]->{beg}+$cSpecs[-1]->{best}) . " label=$cSpecs[-1]->{label} snapshots=$cSpecs[-1]->{snapshots}\n", 3;
                # move to previous complete period
                ($beg, $end) = prevPeriod($beg, $spec->{periodn});   
            }
        }

        debug "cS: [2] spec=$spec->{rawspec} beg,end=" . pair2range($beg,$end) . "\n", 3;

        # get list of good periods starting with beg,end
        if ($Opt{safe}) {
            if ($Opt{calendar}) {
                ($gpCount, @goodPeriods) = findGoodPeriods($beg, $end, $spec, @S);
            } else {
                ($gpCount, @goodPeriods) = findGoodPeriodsNoCal($beg, $end, $spec, @S);
            }
        } else {
            # no-safe mode, with or without calendar mode
            ($gpCount, @goodPeriods) = findAllPeriods($beg, $end, $spec, @S);
        }

        foreach my $gpRef (@goodPeriods) {
            ($beg, $end, my $good, my $sip, my $pCount) = @$gpRef;
            if (!$good) { # there's a gap -- either 1 or more incomplete periods, 
                # or (in no-calendar mode) a fractional number of incomplete periods
                push @cSpecs, {
                    beg       => $beg,
                    end       => $end,
                    freq      => -1,    # keep them all
                    period    => $spec->{period},
                    count     => $pCount,   # may be fractional
                    best      => 0,
                    label     => 'skipped - incomplete ' . $LevelName[$spec->{periodn}] . '(s)',   
                    snapshots => $sip, 
                };
                # FIXME if there are no more snapshots, then printing 'incomplete period'
                # (which may be for a fractional period) and then doing a list of 'empty' cSpecs
                # looks silly.  Possibly.
                debug "cS: created cSpec [3] " . pair2range($cSpecs[-1]->{beg},$cSpecs[-1]->{end}) . " freq=$cSpecs[-1]->{freq} count=$cSpecs[-1]->{count} period=$cSpecs[-1]->{period} best=" . time2stamp($cSpecs[-1]->{beg}+$cSpecs[-1]->{best}) . " label=$cSpecs[-1]->{label} snapshots=$cSpecs[-1]->{snapshots}\n", 3;
            } else { # it's a complete period
                push @cSpecs, {
                    beg       => $beg, 
                    end       => $end, 
                    # if this is the first period, apply the delete-cp option
                    freq      => (($end == $now+1) and !$Opt{'delete-cp'}) ? -1 : $spec->{freq}, 
                    period    => $spec->{period},
                    count     => $spec->{count},
                    best      => bestOffset($spec->{period}, $beg),
                    label     => $spec->{rawspec} . "-$p",
                    snapshots => $sip, 
                };  
                debug "cS: created cSpec [4] " . pair2range($cSpecs[-1]->{beg},$cSpecs[-1]->{end}) . " freq=$cSpecs[-1]->{freq} count=$cSpecs[-1]->{count} period=$cSpecs[-1]->{period} best=" . time2stamp($cSpecs[-1]->{beg}+$cSpecs[-1]->{best}) . " label=$cSpecs[-1]->{label} snapshots=$cSpecs[-1]->{snapshots}\n", 3;
                $p += 1;
            }
            # Move back a period beyond @goodPeriods
            ($beg, $end) = prevPeriod($beg, $spec->{periodn}); 
        } # foreach $gpRef

        debug "cS: [3] spec=$spec->{rawspec} beg,end=" . pair2range($beg,$end) . "\n", 3;

        # We'll get straight here for specs after the one with not enough good periods
        # (or possibly first time if there aren't any specs)
        # NOTE -- we're just accessing the scalar @goodPeriods
        # if count is UNLIMITED, potentially unlimited specs -- just do one for documentation
        my $count = ($spec->{count} == UNLIMITED) ? 1 : $spec->{count};
        debug "cS: any left over? gpCount=$gpCount, count=$count \n", 3;
        for my $i (($gpCount+1)..$count) {
            # HERE THERE ARE NO MORE SPECS!! WE'RE JUST ITERATING THE REMAINING PERIODS OF REMAINING SPECS
            push @cSpecs, {
                beg       => $beg,
                end       => $end,
                freq      => -1,
                period    => $spec->{period},
                count     => $spec->{count},    # or 0,  ?
                best      => 0,
                label     => $spec->{rawspec} . "-$p empty",
                snapshots => snapshotsInPeriod(@S, $beg, $end), # should always be 0 -- we'll check
            };  
            debug "cS: 'empty' cSpec is not empty!!!!!!!!!!!!!!!!!!!!\n", 1 if snapshotsInPeriod(@S, $beg, $end) > 0 ;
            debug "cS: created cSpec [5] " . pair2range($cSpecs[-1]->{beg},$cSpecs[-1]->{end}) . " freq=$cSpecs[-1]->{freq} count=$cSpecs[-1]->{count} period=$cSpecs[-1]->{period} best=" . time2stamp($cSpecs[-1]->{beg}+$cSpecs[-1]->{best}) . " label=$cSpecs[-1]->{label} snapshots=$cSpecs[-1]->{snapshots}\n", 3;
            $p += 1;
            ($beg, $end) = prevPeriod($beg, $spec->{periodn});
        }

        # At this point, beg,end is the next period to consider for the CURRENT spec
        # i.e. its end is OK, but its beg is wrong
        # that's fine, we're working back from that end, so
        # we don't even need now = end -- leave end as it is for next time round loop.

        $firstSpec = 0;

    } # for each spec

    # If there are any snapshots left, they're not needed by any of the specs,
    # and can all be deleted
    if ($end > $oldestS) {
        push @cSpecs, {
            beg       => $oldestS,
            end       => $end,
            freq      => 0,     # keep none of them
            period    => '',    # not a proper period
            count     => 1,     # there is 1 of these
            best      => 0,
            label     => "old",
            snapshots => snapshotsInPeriod(@S, $oldestS, $end), 
        };  
        debug "cS: created cSpec [6] " . pair2range($cSpecs[-1]->{beg},$cSpecs[-1]->{end}) . " freq=$cSpecs[-1]->{freq} count=$cSpecs[-1]->{count} period=$cSpecs[-1]->{period} best=" . time2stamp($cSpecs[-1]->{beg}+$cSpecs[-1]->{best}) . " label=$cSpecs[-1]->{label} snapshots=$cSpecs[-1]->{snapshots}\n", 3;
    }

    # Double check that it's ok
    my $lastbeg = $cSpecs[0]->{end};
    foreach my $c (@cSpecs) {
        if ($c->{end} != $lastbeg) {
            debug "      skipped " . fmtRange($c->{end}, $lastbeg) . ' with ' . 
            snapshotsInPeriod(@S, $c->{end}, $lastbeg) . " snapshots\n", 0;
            debug "      !!!!!!!!!!!!! This shouldn't happen any more!\n", 0; 
        }
        if ($c->{beg} > $c->{end}) {
            debug "      invalid cSpec -- beg > end: " . fmtRange($c->{beg}, $c->{end}) . "\n", 0; 
            debug "      !!!!!!!!!!!!! This shouldn't happen any more!\n", 0; 
        }
        $lastbeg = $c->{beg};
    }

    return @cSpecs;

} # compileSpecs

#---------------------------------------------------------------------------------------------------

sub displayCSpecs (\@;\@) {
    # Display the compiled specs
    my @cSpecs = @{(shift)};
    my @S;
    @S         = @{(shift)} if @_; # optional

    printlog "\nCompiled specs:\n", 2;  
    printlog   "---------------\n", 2;

    # e.g.  From              To                F  P      C  Comment               Ss    Ds
    #       20080101-111122 - 20090101-221111   0  d  99999  6d7.............30  9999  9999
    printlog sprintf("%-15s - %-15s  %2s  %1s  %5s  %-30s  %4s  %4s\n",
        'From', 'To', 'F', 'P', 'C', 'Comment', 'Ss', 'Ds'), 2;
    printlog sprintf("%-15s - %-15s  %2s  %1s  %5s  %-30s  %4s  %4s\n",
        '-'x15, '-'x15, '--', '-', '-----', '-'x30, '----', '----'), 2;
    my $totalS = 0;
    my $totalD = 0;
    foreach my $c (@cSpecs) { 
        printlog sprintf("%s - %s  %2d  %1s  %5s  %-30s  %4s  %4s\n",
            time2stamp($c->{beg}), 
            time2stamp($c->{end}),
            $c->{freq}, 
            $c->{period}, 
            $c->{count} eq UNLIMITED ? 'all' : $c->{count},
            $c->{label}, 
            $c->{snapshots},
            # calculate/predict no. of deletions as excess snapshots:
            ($c->{freq} > 0 and $c->{snapshots} > $c->{freq}) ? $c->{snapshots}-$c->{freq} : '',
        ), 2;
        $totalS += $c->{snapshots};
        $totalD += ($c->{freq} > 0 and $c->{snapshots} > $c->{freq}) ? $c->{snapshots}-$c->{freq} : 0;
    }
    printlog sprintf("%-15s   %-15s  %2s  %1s  %5s  %-30s  %4s  %4s\n",
        '', '', '', '', '', '-' x 30, '----', '----'), 3;
    printlog sprintf("%-15s   %-15s  %2s  %1s  %5s  %-30s  %4s  %4s\n",
        '', '', '', '', '', 'Totals:', $totalS, $totalD), 3;

    # Visualise each cSpec period
    if (@S) {
        printlog "\nDistribution of existing snapshots within each compiled spec\n", 2;
        printlog "------------------------------------------------------------\n", 2;
        foreach my $c (@cSpecs) {
            my @SiP = snapshotsInPeriod(@S, $c->{beg}, $c->{end}, 1);
            visualise($c->{beg}, $c->{end}, 1, 0, $c->{label} => \@SiP) if $Opt{verbose} >= 2;
        }
    }

}

#===================================================================================================

sub getExpirableSnapshots (\%\@\@$) {
    # Return a list of snapshots that are 'expirable'
    # because they fall within range of the last 'unlimited' spec,
    # or because the expire-old option allows it
    my %S      = %{(shift)};
    my @S      = reverse sort keys %S;
    my @specs  = @{(shift)};
    my @cSpecs = @{(shift)};
    my $now    = shift;

    debug "gES: \@S=@S \@specs=@specs \$now=$now\n", 3;
    my @expirable;
    # The current snapshot and any that we're linking to
    # are never expirable, so shift them off the local copy of @S
    for my $i (0..$Opt{ldcount}) {
        shift @S; 
    }
    if (!@S) {
        debug "gES: no \@S, so no expirables\n", 3;
        return @expirable;
    }
    # Put partial snapshots on the list first
    foreach my $s (@S) {
        if ($S{$s}) {
            unshift @expirable, $s;
            delete $S{$s};  
        }
    }
    debug "gES: expiring partials: " . join(' ', map {time2stamp($_)} @expirable) . "\n", 3;
    @S = reverse sort keys %S;  # now with no partial snapshots
    # Return if there are none left
    return @expirable if !@S;
    if ($Opt{'expire-old'}) {
        # Any snapshot is expirable so return @S in oldest-first order.
        push @expirable, reverse @S;
        debug "gES: expire-old: they're all expirable EXCEPT the first two: \n", 3;
        debug "       " . join(' ', map {time2stamp($_)} @expirable) . "\n", 3;
        return @expirable;
    }
    my $lastSpec = $specs[-1];
    if ($lastSpec->{count} == UNLIMITED) {
        my $lastraw = $lastSpec->{rawspec};
        my $i = $#cSpecs;
        # Pick out snapshots in the 'unlimited' cSpecs, which are always at the end
        while (($i >= 0) and ($cSpecs[$i]->{label} =~ /^($lastraw)/)) {
            debug "gES: lastC is unlimited, getting expirables\n", 9; 
            unshift @expirable, snapshotsInPeriod(@S, $cSpecs[$i]->{beg}, $cSpecs[$i]->{end}, 1);
            $i -= 1;
        }
    }
    debug "gES: returning expirables: " . join(' ', map {time2stamp($_)} @expirable) . "\n", 3;
    return @expirable;
}

#===================================================================================================

sub newSnapshotTime ($) {
    # Generate snapshot name from template and current time,
    # making sure that a directory with the corresponding
    # name doesn't already exist.
    my $dest = shift;
    my $snapshotTime = time;
    my $snapshotDir = snapshotPath($dest, $snapshotTime);
    # ...may have to wait a second
    while (-e $snapshotDir) {
        debug "Sleeping for a second...\n", 3;
        # Yes, we could just add 1 to $snapshotTime,
        # but then we might end up in the future...
        sleep 1;
        $snapshotTime = time;
        $snapshotDir = snapshotPath($dest, $snapshotTime);
    }
    return $snapshotTime;
}

#---------------------------------------------------------------------------------------------------

sub runRsync ($\@$\@) {
    # Run rsync.
    # If it fails for lack of disk space, delete expirable snapshots and try again.
    # Returns 1 for successful creation of a new snapshot.
    #my $ref = shift;
    my $dest               = shift;
    my @expirableSnapshots = @{(shift)};
    my $snapshotTime       = shift;
    my @S                  = @{(shift)};
    debug "runRsync: \@eS='@expirableSnapshots' sTime=$snapshotTime (" . 
        time2stamp($snapshotTime) .")\n", 3;

    my $snapshot = snapshotName($snapshotTime);

    # Set up verbosity option
    my $verbose = '';
    $verbose = '--verbose' if $Opt{verbose} > 2;
    $verbose .= ' --verbose --stats' if $Opt{verbose} > 3;  

    # Add the include/exclude options -- there may be several of each
    # Note that each file/directory is double-quoted to allow escapes to work
    # (see stripQuotes()).
    my $incExcOpts = '';
    foreach my $opt (qw(include include-from exclude exclude-from)) {
        $incExcOpts .= join(' ', map {"--$opt \"$_\""} @{$Opt{$opt}});
    }

    my $remoteDest = remote($dest);

    my $succeeded = 1;  # stays true if ALL sources are copied successfully

    my $deletionsAllSources = 0;

    # Loop through sources one at a time
    SOURCE:
    foreach my $source (@{$Opt{source}}) {

        printlog "\nCopying from source $source\n", 1;
        my $remoteSource = remote($source);
        my $destDir = "$dest/$snapshot";    # can't use catdir because it nobbles rsync:// URLs
        debug "dest '$dest'  destdir '$destDir'\n", 3;

        # Source and destination can not both be remote (rsync limitation)
        if ($remoteDest and $remoteSource) {
            printlog "WARNING: source '$source' and destination '$destDir' are both remote\n";
            printlog "         rsync can not do that -- combination has been skipped\n";
            next SOURCE;
        }

        my $subDir  = '';   # These two are for adjusting the link-dest path
        my $upDir   = '';

        if ($remoteSource) {
            # Destination directory includes a sub-directory if the source is remote
            $subDir = sourceDir($source);
            $upDir  = '../';
            $destDir = "$destDir/$subDir";  # can't use catdir because it nobbles rsync:// URLs
            # That extra directory level won't be created by rsync normally,
            # so we'll have to do one of them manually
            # (It may already be there if there is more than one destination)
            # Destination is local, so just we can just use mkdir
            if (!$Opt{'dry-run'}) {
                if (!-e "$dest/$snapshot" and !mkdir("$dest/$snapshot", 0755)) {
                    printlog "ERROR: Unable to create directory '$dest/$snapshot' ($!)\n";
                    # rsync will also fail
                }
            }
        }

        # Set up link-dest options if there are any previous snapshots
        # (as a relative path, which will work whether local or remote)
        my $ldi = 1;
        my $linkdest = '';
        debug "rR: ldi=$ldi ldcount=$Opt{ldcount} \$#S=$#S updDir=$upDir\n", 3;
        debug "rR: \@S: " . join(', ', map {time2stamp($_)} @S) . "\n", 3;
        while ($ldi <= $Opt{ldcount} and $ldi <= $#S) {
            $linkdest .= "--link-dest='$upDir../$Opt{template}-" . 
                time2stamp($S[$ldi]) . "/$subDir' ";
            $ldi += 1;
        }

        # Set compression option
        my $compression = '';
        $compression = '--compress' if $Opt{compress} and ($remoteSource or $remoteDest);

        # Set bandwidth limit, depending on the direction
        # (or none if dest and source are both local)
        my $bwlimit = '';
        $bwlimit = "--bwlimit=$Opt{'bwlimit-in'}"  if $remoteSource;
        $bwlimit = "--bwlimit=$Opt{'bwlimit-out'}" if $remoteDest;

        # Set remote rsync option
        my $rsyncPath = '';
        $rsyncPath = "--rsync-path '$Opt{'remote-rsync-cmd'}'"
            if ($Opt{'remote-rsync-cmd'} and ($remoteSource or $remoteDest));

        printlog "Running rsync from source '$source' to destination '$destDir'\n", 2;
        # Note that rsync-opts is put first -- 
        # our own required options will override the user's
        my $args = "$Opt{'rsync-opts'} $verbose $linkdest $incExcOpts $compression " . 
            "$bwlimit --relative $rsyncPath '$source' '$destDir'";

        { 
            # Wrap the call to rsync and associated houskeeping into a block
            # and trap interrupts so that the block becomes (sort of) atomic,
            # i.e. if rsync fails, the partial snapshot will be deleted
            # before we give up completely.
            local $SIG{INT}  = sub { $Quitting = 1; };
            local $SIG{QUIT} = sub { $Quitting = 1; };
            local $SIG{ABRT} = sub { $Quitting = 1; };
            local $SIG{TERM} = sub { $Quitting = 1; };

            my $maxTries = @expirableSnapshots + 1; 
            my $keepTrying = $maxTries;  
            my $deletions = 0;
            my $tries = 0;
            # Run rsync.
            # If it fails for lack of space, delete an old snapshot and try again
            while ($keepTrying and !$Quitting) {
                $tries += 1;
                $keepTrying -= 1;
                printlog "Running rsync -- try $tries of $maxTries\n", 2;
                my ($rc, $rc2) = systemcall($Opt{'rsync-cmd'}, $args, 2,2);
                debug "after rsync rc=$rc rc2='$rc2'\n", 3;
                given ($rc) {
                    # TODO better use of when() to reduce repeated code
                    # and split 'last SOURCE' errors from others
                    when (0) {
                        $keepTrying = 0;
                    }
                    when (1) {
                        printlog "ERROR: rsync failed complaining about options / usage\n", 1;
                        $snapshotTime = undef;
                        $keepTrying = 0;
                        $succeeded = 0;
                        last SOURCE;
                    }
                    when ([22, 23, 24]) {
                        # Errors on some files such as problems with permissions,
                        # or files that have vanished -- carry on
                        $keepTrying = 0;
                    }
                    when ($_ >= 1000) { # 1000 + signal
                        # rsync was interrupted -- don't delete the partial snapshot
                        # unless requested by the relevant option
                        if ($Opt{'allow-restart'}) {
                            printlog "ERROR: rsync was interrupted -- partial snapshot will be kept to allow restart\n", 1;
                        } else {
                            my $rc = renameOrDeleteSnapshot($dest, $snapshot);
                            if ($rc) {
                                printlog "ERROR: rsync was interrupted -- partial snapshot has been " .
                                    $rc == 1 ? 'renamed' : 'deleted' .
                                    "\n", 1;
                            }
                        } 
                        $keepTrying = 0;
                        $succeeded = 0;
                        $ExitCode = EXITINT;
                        last SOURCE;
                    }
                    when ([12]) {
                        # 12 e.g. snapshot dir not found or disk is full.
                        # See if the target disk is full, in which case
                        # delete some snapshots and try again
                        if ($rc2 eq 'diskfull') { 
                            if (!$keepTrying) {
                                # No space, and no more tries
                                debug "rR: no space and no more retries\n", 3;
                                continue;
                            } else {
                                # Try to make some space before having another go
                                printlog "WARNING: destination '$dest' is full -- will delete an old snapshot and try again\n";
                                my $deleted = deleteOldSnapshots($dest, @expirableSnapshots, 1);
                                if ($deleted < 1) {
                                    # No snapshots deleted, so stop trying
                                    printlog "ERROR: unable to delete old snapshot to make space\n", 1;
                                    continue;
                                } else {
                                    # More space freed, so try again
                                    printlog "NOTE: Old snapshot deleted successfully -- continuing\n";
                                    $deletions += $deleted;
                                    $deletionsAllSources += $deleted;
                                }
                            }
                        } else {
                            debug "rR: Disk is not full, apparently -- some other error\n", 3;
                            #printlog "ERROR: rsync reported a serious problem (3: $rc $rc2)\n", 1;
                            #$keepTrying = 0;
                            continue;
                        }
                    }
                    default {   # (note the 'continue's above)
                        # 11 e.g. include-from file not found
                        # 5 - failed to start rsyncd protocol
                        # 255, various, including wrong ssh password, 
                        # -1
                        printlog "ERROR: rsync reported a serious problem ($rc / '$rc2')\n", 1;
                        #deleteSnapshot($dest, $snapshot);
                        #printlog "ERROR: snapshot was not complete, and has been deleted\n", 1;
                        my $rc = renameOrDeleteSnapshot($dest, $snapshot);
                        if ($rc) {
                            printlog "ERROR: snapshot was not complete, and has been " .
                                $rc == 1 ? 'renamed' : 'deleted' .
                                "\n", 1;
                        }
                        $keepTrying = 0;
                        $succeeded = 0;
                        $ExitCode = EXITRSYNC;
                        last SOURCE;
                    }
                }
                debug "No more tries\n", 4 if $keepTrying <= 0;
            } # while

            if ($deletions) {
                printlog "NOTE: $deletions expirable snapshots were deleted while processing source '$source'\n", 2;
                printlog "(dry run: no snapshots actually deleted)\n", 2 if $Opt{'dry-run'};
            }

        } # block

    } # for each source

    if ($succeeded) {
        printlog "\nrsync successfully created new snapshot '$dest/$snapshot'\n", 1;  
        printlog "(dry run: no snapshot actually created)\n", 1 if $Opt{'dry-run'};
        if ($deletionsAllSources) {
            printlog "NOTE: $deletionsAllSources expirable snapshots were deleted from destination '$dest'\n", 2;
            printlog "(dry run: no snapshots actually deleted)\n", 2 if $Opt{'dry-run'};
        }
    } else {
        printlog "\nWARNING: rsync did NOT create a new snapshot on destination '$dest'\n", 1;
    }

    return $succeeded;
}

#---------------------------------------------------------------------------------------------------

sub run ($\@) {
    # Do the processing for a single destination
    my $dest  = shift;      
    my @specs = @{(shift)};

    # Get list of existing snapshots
    my %S = getSnapshotList($dest);
    my @S = reverse sort keys %S;

    # If there are no previous snapshots, ignore the 'restart' option
    if ($Opt{restart} and !%S) {
        printlog "NOTE: No previous snapshots found, so 'restart' option will be ignored\n", 1;
        $Opt{restart} = 0;
    }

    my $snapshotTime;
    if ($Opt{restart}) {
        # Restarting the previous snapshot
        $snapshotTime = $S[0];
        printlog "NOTE: Restarting snapshot " . snapshotName($snapshotTime) . "\n", 1;
    } else {
        # Normal run, creating a new snapshot.
        # Get time stamp for this run...
        $snapshotTime = newSnapshotTime($dest);
        # ...and include it in the list (and the hash)
        unshift @S, $snapshotTime if ($Opt{snapshot});
        $S{$snapshotTime} = 0;
    }
    debug "run: got list of " . @S . " snapshots\n", 4;

    printlog "\nCreating snapshot " . snapshotName($snapshotTime) . " on destination $dest\n", 1;
    printlog '-' x (50 + length($dest) + length($Opt{template})) . "\n", 1;

    # 'Compile' the specs taking account of current time and existing snapshots
    my @cSpecs;
    @cSpecs = compileSpecs($snapshotTime, @specs, %S);
    displayCSpecs(@cSpecs, @S);
    
    # Get the list of snapshots to be deleted
    my @D = getDeleteList(@S, @cSpecs);

    # See if the new snapshot would be one of the ones deleted
    my $deleteNew = grep {$_ == $snapshotTime} @D;

    if ($Opt{snapshot}) {
        if ($deleteNew and $Opt{delete} and $Opt{'delete-cp'}) {
            printlog "NOTE: new snapshot would be immediately deleted, so rsync will NOT be run\n", 1;
        } else {
            my @expirableSnapshots = getExpirableSnapshots(%S, @specs, @cSpecs, $snapshotTime);
            my $rsyncOK = runRsync($dest, @expirableSnapshots, $snapshotTime, @S);  
            if (!$rsyncOK) {
                # Failed to create a new snapshot, so re-do the list of deletions
                @S = grep {$_ != $snapshotTime} @S;
                @D = getDeleteList(@S, @cSpecs, 9);
            }
        }
    } else {
        printlog "Option 'no-snapshot' given -- no new snapshot will be created\n", 2;
    }

    return if ($Quitting);

    if ($Opt{delete}) {
        deleteSnapshots($dest, @D, @cSpecs, $deleteNew);
        # Get new snapshot list after deletions
        %S = getSnapshotList($dest);
    } else {
        printlog "Option 'no-delete' given, so no existing snapshots will be deleted\n", 2;
    }

    # Display the current situation
    status($dest, %S, @cSpecs);

}

#---------------------------------------------------------------------------------------------------
    
sub systemcall ($$$$;$$) {
    # Run a system command, given as a program name and argument string.
    # Return the command's return code and extra info if possible.
    # Elaborate scheme for catching STDOUT and STDERR taken from the PERL FAQ 
    # http://perldoc.perl.org/perlfaq8.html#How-can-I-capture-STDERR-from-an-external-command?
    my $cmd         = shift;
    my $args        = shift;    # as a string
    my $stdoutLevel = shift;
    my $stderrLevel = shift;
    my $stdoutRef   = shift;    # if specified, it's an array reference that will receive lines 
                                # from stdout OR a file handle to store stdout lines in
    my $stderrRef   = shift;    # ditto for stderr
    my $rc = 0;
    my $rc2 = '';
    if ($Opt{'dry-run'}) {
        if ($cmd eq $Opt{'rsync-cmd'}) {
            # Special case: if cmd is 'rsync', pass dry-run to rsync and really run it
            # (added at the beginning because of source and dest)
            $args = '--dry-run ' . $args;
        } else {
            printlog "Dry-run: would have run '$cmd $args'\n", 1;
            return 0;
        }
    }
    debug "systemcall: cmd=|$cmd| args=|$args|\n", 5;
    printlog "Running command: $cmd $args\n", $stdoutLevel;
    {
        # Get the return code instead of stopping if $cmd is interrupted
        sub killgroup {
            # Make sure all child processes are killed too.
            my $sig = shift;
            local $SIG{$sig} = 'IGNORE'; # don't kill ourselves again
            $Quitting = 1; 
            kill($sig, -$$);
        };
        local $SIG{INT}  = \&killgroup;
        local $SIG{QUIT} = \&killgroup;
        local $SIG{ABRT} = \&killgroup;
        local $SIG{TERM} = \&killgroup;
        local *CATCHERR = IO::File->new_tmpfile;
        my $pid = open3(gensym, \*CATCHOUT, ">&CATCHERR", "$cmd $args");
        # Deal with stdout from $cmd
        printlog "$cmd output:\n", $stdoutLevel unless $stdoutRef;
        while (<CATCHOUT>) {
            if (ref($stdoutRef) eq 'ARRAY') {
                push @$stdoutRef, $_; 
            } elsif (ref($stdoutRef) eq 'GLOB') {
                print $stdoutRef $_;
            } else {
                printlog $_, $stdoutLevel;
            }
        }
        waitpid($pid, 0);
        $rc = $?;
        $rc2 = '';
        # Deal with stderr from $cmd
        seek CATCHERR, 0, 0;
        printlog "$cmd errors:\n", $stderrLevel unless $stderrRef;
        while (<CATCHERR>) {
            # scan for specific errors
            if (/No space left on device/) {    # (this text is not always there)
                $rc2 = 'diskfull';
            }
            if (ref($stderrRef) eq 'ARRAY') {
                push @$stderrRef, $_; 
            } elsif (ref($stderrRef) eq 'GLOB') {
                print $stdoutRef $_;
            } else {
                printlog $_, $stderrLevel;
            }
        }
    }
    if ($rc == -1) {
        printlog "Failed to execute command '$cmd': $!\n", 1;
    } elsif ($rc & 127) {
        my $sig = $rc & 127;
        printlog "Command '$cmd' died with signal $sig\n", 1;
        #  ($? & 127),  ($? & 128) ? 'with' : 'without';
        $rc = ($rc & 127) + 1000;
    } else {
        $rc = $rc >> 8;
        printlog "Command '$cmd' exited with value $rc\n", 1 if $rc;
    }
    return ($rc, $rc2);
}

#===================================================================================================

# Test suite
# Code here can be called by running the script with the '--test n' option.
# This if for developers (i.e. me) only!

sub testSuite { 

    printlog "\nRunning test $Opt{test}\n";
    printlog   "===============\n";

    # Default options for testing
    $Opt{source}[0]      = '~/tmp/bstestsource';
    $Opt{destination}[0] = '~/tmp/bstestdest';
    $Opt{lockfile}       = '~/tmp/bstest.lock';
    $Opt{verbose}        = 3;
    my $now = stamp2time('20110529-230000');

    given ($Opt{test}) {

        when (1) {
            # parsing specs
            my @specs = (
            '4d2,1d,2w3,1m6',
            '4d2,1d,1m6',
            '2h6,1h,1d,1w',
            '1d7,2h3,1d,1w1',
            '2h3,1d,1w1',  # problem -- doesn't line up hours before lining up days
            '2h3,1w,1m1',  # likewise...
            '1h1,1d1,1h4,1w1,1d1,1h19,1d,1w1', # silly but valid
            '1d1,1w0',
            '1d1,0w1',
            '1d1,1w',
            '6d7,7w1,2w2,4m5,1m6,2y',
            'd1,1q3,abc,-1d1,1.3w2.9, 1d2 ', # check for invalid ones
            );
            foreach my $spec (@specs) {
                print "parsing $spec...\n";
                my ($w, $e, @ps) = parseSpecs($spec);
                print "...gives w=$w e=$e " . (join(',', map {"$_->{rawspec}"} @ps)) . "\n";
            }
        }

        when (2) {
            # 2
            my ($warnings, $errors, @specs) = parseSpecs('3d1');
            my @S = reverse sort(
                stamp2time('20110508-090000'),
                stamp2time('20110508-100000'),
                stamp2time('20110508-120000'),
                stamp2time('20110508-180000'),
            );
#            my @cSpecs = compileSpecs($now, @specs, @S);
#            displayCSpecs(@cSpecs, @S);
        }

        when (3) {
            # 3 
            my ($warnings, $errors, @specs) = parseSpecs('3d1');
            my @S = reverse sort(
                stamp2time('20110508-030000'),
                stamp2time('20110508-060000'),
                stamp2time('20110508-100000'),
                stamp2time('20110508-150000'),
                stamp2time('20110508-180000'),
            );
#            my @cSpecs = compileSpecs($now, @specs, @S);
#            displayCSpecs(@cSpecs, @S);
        }

        when (4) {
            # 4 - good test for combinations etc:
            my ($warnings, $errors, @specs) = parseSpecs('6d1');
            my @S = reverse sort(
                stamp2time('20110508-010000'),
                stamp2time('20110508-011000'),
                stamp2time('20110508-012000'),
                stamp2time('20110508-013000'),
                stamp2time('20110508-090000'),
                stamp2time('20110508-120000'),
                stamp2time('20110508-150000'),
                stamp2time('20110508-180000'),
                stamp2time('20110508-203000'),
                stamp2time('20110508-210000'),
            );
#            my @cSpecs = compileSpecs($now, @specs, @S);
#            displayCSpecs(@cSpecs, @S);
        }

        when (5) {
            # 5 - more than one day's worth
            my ($warnings, $errors, @specs) = parseSpecs('8d1,7d3,1d4');
            my @S = reverse sort(
                stamp2time('20110506-010000'),
                stamp2time('20110506-011000'),
                stamp2time('20110506-012000'),
                stamp2time('20110507-013000'),
                stamp2time('20110507-090000'),
                stamp2time('20110507-120000'),
                stamp2time('20110508-150000'),
                stamp2time('20110508-180000'),
                stamp2time('20110508-203000'),
                stamp2time('20110508-210000'),
            );
#            my @cSpecs = compileSpecs($now, @specs, @S);
#            displayCSpecs(@cSpecs, @S);
            # FIXED this doesn't give ideal result -- chooses B's that are too close together
            # FIXED: 1d1 -> middle one -- because of initial spacing
            #        2d1 -> first and one near the end -- why? because of initial spacing, so that's OK
        }

        when (6) {
            # Test 6 -- example of bad choice with close snapshots:  
            my ($warnings, $errors, @specs) = parseSpecs('3w1');
            my @S = reverse sort(
                stamp2time('20110426-050000'),
                stamp2time('20110427-050000'),
                stamp2time('20110428-050000'),
                stamp2time('20110428-060000'),
            );
#            my @cSpecs = compileSpecs($now, @specs, @S);
#            displayCSpecs(@cSpecs, @S);
        }

        when (7) {
            # Test 5 - testing goodPeriods
            my ($warnings, $errors, @specs) = parseSpecs('6d1,2d4,3w1');  # note total of 5d -- not run at w/e
            my @S = reverse sort(
                stamp2time('20110506-010000'),
                stamp2time('20110506-020000'),
                stamp2time('20110506-030000'),
                stamp2time('20110506-040000'),
                stamp2time('20110506-044000'),
                stamp2time('20110506-050000'),
                stamp2time('20110505-090000'),
                stamp2time('20110505-140000'),
                stamp2time('20110505-180000'),
                stamp2time('20110504-090000'),
                stamp2time('20110504-140000'),
                stamp2time('20110504-180000'),
                stamp2time('20110503-090000'),
                stamp2time('20110503-140000'),
                stamp2time('20110503-180000'),
                stamp2time('20110501-090000'),
                stamp2time('20110501-140000'),
                stamp2time('20110501-180000'),
                stamp2time('20110428-050000'),
                stamp2time('20110427-050000'),
                stamp2time('20110426-060000'),
                stamp2time('20110426-040000'),
                #   stamp2time('20100428-0500'),
            )   ;
#            my @cSpecs = compileSpecs($now, @specs, @S);
#            displayCSpecs(@cSpecs, @S);
        }

        when (8) {
            # Test 8 - wonky spec
            my ($warnings, $errors, @specs) = parseSpecs('2d7,3w1,1d1,2m1'); # 2d7,3w1,1d1,2m1
            my @S = reverse sort(
                stamp2time('20110529-090000'), stamp2time('20110529-120000'), stamp2time('20110529-180000'),  # current
                stamp2time('20110528-090000'), stamp2time('20110528-120000'), stamp2time('20110528-180000'),  # 2d7...
                stamp2time('20110527-090000'), stamp2time('20110527-120000'), stamp2time('20110527-180000'),
                stamp2time('20110526-090000'), stamp2time('20110526-120000'), stamp2time('20110526-180000'),
                stamp2time('20110525-090000'), stamp2time('20110525-120000'), stamp2time('20110525-180000'),
                stamp2time('20110524-090000'), stamp2time('20110524-120000'), stamp2time('20110524-180000'),
                stamp2time('20110523-090000'), stamp2time('20110523-120000'), stamp2time('20110523-180000'),
                stamp2time('20110522-090000'), stamp2time('20110522-120000'), stamp2time('20110522-180000'),  
                stamp2time('20110521-090000'), stamp2time('20110521-120000'), stamp2time('20110521-180000'),  # 3w1...
                stamp2time('20110518-090000'), stamp2time('20110518-120000'), stamp2time('20110518-180000'),
                stamp2time('20110515-090000'), stamp2time('20110515-120000'), stamp2time('20110515-180000'),  # 1d1
                stamp2time('20110512-090000'), stamp2time('20110512-090100'), stamp2time('20110512-090200'),  
                stamp2time('20110512-090300'), stamp2time('20110512-090400'), stamp2time('20110512-090400'),  
                stamp2time('20110512-090600'), stamp2time('20110512-090700'), stamp2time('20110512-090800'),  
                stamp2time('20110512-090900'), stamp2time('20110512-091000'), stamp2time('20110512-091100'),  
                stamp2time('20110403-090000'), stamp2time('20110403-120000'), stamp2time('20110403-180000'),  # 4m1
                stamp2time('20110301-125900'),
            );
            my $now = stamp2time('20110529-230000');
            debug "\nTest run on $now " . time2stamp($now) . "\n";
            my @cSpecs;
            debug "\nsafely, calendar:\n";
            $Opt{calendar} = 1;
            $Opt{safe} = 1;
#            @cSpecs = compileSpecs($now, @specs, @S);
            displayCSpecs(@cSpecs, @S);
            debug "\nand now unsafely, calendar:\n";
            $Opt{calendar} = 1;
            $Opt{safe} = 0;
#            @cSpecs = compileSpecs($now, @specs, @S);
            displayCSpecs(@cSpecs, @S);
            debug "\nand now safely, non-calendar:\n";
            $Opt{calendar} = 0;
            $Opt{safe} = 1;
#            @cSpecs = compileSpecs($now, @specs, @S);
            displayCSpecs(@cSpecs, @S);
            debug "\nand now unsafely, non-calendar:\n";
            $Opt{calendar} = 0;
            $Opt{safe} = 0;
#            @cSpecs = compileSpecs($now, @specs, @S);
#            displayCSpecs(@cSpecs, @S);
            #my @D = getDeleteList(@S, @cSpecs);
        }

        when (9) {
            sub genTests {
                my @S;
                my (undef, undef, @specs) = parseSpecs('6d1,2d4,3w3,8m1'); # note total of 5d -- not run at w/e
                # need enough snapshots to fill all specs and then some
                for (my $date = stamp2time('20110401-070000'); $date < stamp2time('20110501-000000'); $date += HOUR*3) {
                    printlog "\n" . '-' x 80;
                    printlog "\nTest run on $date " . time2stamp($date) . "\n";
                    unshift @S, $date;  # make snapshot
#                    my @cSpecs = compileSpecs $date+HOUR/2, @specs, @S;
#                    displayCSpecs(@cSpecs, @S);
#                    my @D = getDeleteList(@S, @cSpecs);
#                    @S = arrayDiff(@S, @D); # 'delete' them
                }   
            }
            genTests;
        }

        when (10) {
            # 24 -> 4
            # better matching: don't favour ends if evenly spaced throughout the day
            #   -- somehow measure evenness, and then reduce endness
            $Opt{logfile} = './bstest10.log';
            my (undef, undef, @specs) = parseSpecs('1h24,4d6');
            my @S = reverse sort(
                stamp2time('20110530-003000'), stamp2time('20110530-013000'), stamp2time('20110530-023000'),  
                stamp2time('20110530-033000'), stamp2time('20110530-043000'), stamp2time('20110530-053000'),  
                stamp2time('20110530-063000'), stamp2time('20110530-073000'), stamp2time('20110530-083000'),  
                stamp2time('20110530-093000'), stamp2time('20110530-103000'), stamp2time('20110530-113000'),  
                stamp2time('20110530-123000'), stamp2time('20110530-133000'), stamp2time('20110530-143000'),  
                stamp2time('20110530-153000'), stamp2time('20110530-163000'), stamp2time('20110530-173000'),  
                stamp2time('20110530-183000'), stamp2time('20110530-193000'), stamp2time('20110530-203000'),  
                stamp2time('20110530-213000'), stamp2time('20110530-223000'), stamp2time('20110530-233000'),  

                stamp2time('20110529-003000'), stamp2time('20110529-013000'), stamp2time('20110529-023000'),  
                stamp2time('20110529-033000'), stamp2time('20110529-043000'), stamp2time('20110529-053000'),  
                stamp2time('20110529-063000'), stamp2time('20110529-073000'), stamp2time('20110529-083000'),  
                stamp2time('20110529-093000'), stamp2time('20110529-103000'), stamp2time('20110529-113000'),  
                stamp2time('20110529-123000'), stamp2time('20110529-133000'), stamp2time('20110529-143000'),  
                stamp2time('20110529-153000'), stamp2time('20110529-163000'), stamp2time('20110529-173000'),  
                stamp2time('20110529-183000'), stamp2time('20110529-193000'), stamp2time('20110529-203000'),  
                stamp2time('20110529-213000'), stamp2time('20110529-223000'), stamp2time('20110529-233000'),  

                stamp2time('20110528-213000'), stamp2time('20110528-223000'), stamp2time('20110528-233000'),  
            )
            ;
            my $now = stamp2time('20110531-003000');
#            my @cSpecs = compileSpecs $now, @specs, @S;
#            displayCSpecs(@cSpecs, @S);
#            my @D = getDeleteList(@S, @cSpecs);
        }

        when (11) {
            # testing 'grouping'
            $Opt{logfile} = './bstest11.log';
            my (undef, undef, @specs) = parseSpecs('1h9,4d6');
            my @S = reverse sort(
                stamp2time('20110530-093000'), stamp2time('20110530-103000'), stamp2time('20110530-113000'),  
                stamp2time('20110530-123000'), stamp2time('20110530-133000'), stamp2time('20110530-143000'),  
                stamp2time('20110530-153000'), stamp2time('20110530-163000'), stamp2time('20110530-173000'),  

                stamp2time('20110529-093000'), stamp2time('20110529-103000'), stamp2time('20110529-113000'),  
                stamp2time('20110529-123000'), stamp2time('20110529-133000'), stamp2time('20110529-143000'),  
                stamp2time('20110529-153000'), stamp2time('20110529-163000'), stamp2time('20110529-173000'),  

                stamp2time('20110528-213000'), stamp2time('20110528-223000'), stamp2time('20110528-233000'),  
            )
            ;
            my $now = stamp2time('20110531-003000');
#            my @cSpecs = compileSpecs($now, @specs, @S);
#            displayCSpecs(@cSpecs, @S);
#            my @D = getDeleteList(@S, @cSpecs);
        }

        when (12) {
            # testing expirables  
            $Opt{lockfile} = '/home/chris/Dropbox/perlwork/brandysnap/bs.lock';
            $Opt{source} = ['/home/chris/Dropbox/perlwork', '/library/pictures/Fujical.jpg'];
            $Opt{snapshotdir} = '/home/chris/tmp/bstest12/';
            $Opt{template} = 'test12';
            $Opt{spec} = '2d';
            $Opt{debug} = 3;
            $Opt{verbose} = 2;
            $Opt{loglevel} = 3;
            $Opt{logfile} = '/home/chris/Dropbox/perlwork/brandysnap/bstest12.log';
            $Opt{test} = 12;
            $Opt{exclude}='*.log*';
            #$Opt{delete-cp} = 0;
            #$Opt{dry-run} = 0;
            ##$Opt{delete} = 1;
            #
            my @S = reverse sort(
                stamp2time('20110530-093000'), stamp2time('20110530-103000'), stamp2time('20110530-113000'),  
                stamp2time('20110529-123000'), stamp2time('20110529-133000'), stamp2time('20110529-143000'),  
                stamp2time('20110528-153000'), stamp2time('20110528-163000'), stamp2time('20110528-173000'),  

                stamp2time('20110527-093000'), stamp2time('20110527-103000'), stamp2time('20110527-113000'),  
                stamp2time('20110526-123000'), stamp2time('20110526-133000'), stamp2time('20110526-143000'),  
                stamp2time('20110525-153000'), stamp2time('20110525-163000'), stamp2time('20110525-173000'),  

                stamp2time('20110524-213000'), stamp2time('20110524-223000'), stamp2time('20110524-233000'),  
            )
            ;
            my $dest = ${$Opt{destination}}[0];
            # generate initial state
            foreach my $s (@S) {
                #        debug " mkdir snapshotPath($dest, $s)\n";
                mkdir snapshotPath($dest, $s);
            }
            my $now = stamp2time('20110531-003000');
            my ($warnings, $errors, @specs) = parseSpecs('2d'); 
#            my @cSpecs = compileSpecs($now, @specs, @S);
#            displayCSpecs(@cSpecs, @S);
#            my @D = getDeleteList(@S, @cSpecs);
            #run($dest, @specs);
        }

        when (13) {
            # low-level tests of date routines
            my ($beg, $end) = prevPeriod(stamp2time('20110622-234400'), 1);    # 1=day
            fullPeriod($beg, $end, 3);
            ($beg, $end) = prevPeriod(stamp2time('20110622-234400'), 3);    # 3=month
            fullPeriod($beg, $end, 3);
            ($beg, $end) = getPeriod(stamp2time('20110622-234400'), 2);    
            fullPeriod($beg, $end, 3);
            fullPeriod($beg, $end, 2);
        }

        when (14) {
            debug "Testing findGoodPeriods\n";
            # testing expirables  
            $Opt{spec} = '1d7,1w3,1m11,1y';
            $Opt{verbose} = 3;
            $Opt{loglevel} = 3;
            $Opt{debug} = 5;
            $Opt{calendar} = 1;
            #
            my @S = reverse sort(
                # just one will do
                stamp2time('20110627-093000'),
            )
            ;
            my $dest = ${$Opt{destination}}[0];
            my $now = stamp2time('20110627-133000');
            my ($warnings, $errors, @specs) = parseSpecs($Opt{spec}); 
#            my @cSpecs = compileSpecs($now, @specs, @S);
#            displayCSpecs(@cSpecs, @S);
        }

        when (15) {
            debug "Testing findGoodPeriodsNoCal\n";
            # testing expirables  
            $Opt{spec} = '3d2,3w1,99m1';
            $Opt{verbose} = 2;
            $Opt{loglevel} = 3;
            $Opt{calendar} = 0;
            #
            my @S = reverse sort(
                # a good day, then space, then a good day
                stamp2time('20110627-093000'), stamp2time('20110627-103000'), stamp2time('20110627-113000'),  
                stamp2time('20110626-123000'), stamp2time('20110625-133000'), stamp2time('20110624-143000'),  
                stamp2time('20110623-153000'), stamp2time('20110623-163000'), stamp2time('20110623-173000'),  

                # then space, then a good week
#                stamp2time('20110622-093000'), stamp2time('20110619-103000'), stamp2time('20110612-113000'),  
                stamp2time('20110604-143000'), stamp2time('20110604-133000'), stamp2time('20110604-123000'),  

                # then space forever...
                stamp2time('20110524-213000'), stamp2time('20110424-223000'), stamp2time('20110324-233000'),  
            )
            ;
            my $dest = ${$Opt{destination}}[0];
            my $now = stamp2time('20110627-133000');
            my ($warnings, $errors, @specs) = parseSpecs($Opt{spec}); 
#            my @cSpecs = compileSpecs($now, @specs, @S);
#            displayCSpecs(@cSpecs, @S);
        }

        when (16) {
            print "Testing renameOrDeleteSnapshot\n";
            $Opt{template} = 'test1';
            $Opt{destination} = '/home/chris/tmp';
            #renameOrDeleteSnapshot("/home/chris/tmp", "test1-20110716-164234");
            #renameOrDeleteSnapshot('chris@localhost:/home/chris/tmp', "test1-20110809-170104");
            my %S = getSnapshotList("/home/chris/tmp");
            print "%S: ";
            foreach my $s (reverse sort keys %S) {
                print "$s: $S{$s} ";
            }
            print "\n";
            status('/home/chris/tmp', %S);
        }
    }
}

#===================================================================================================

# Mainline is here

# Display basic info -- logging will happen later
printit "\n$Script version $Version starting at " . (strftime "%H:%M:%S", localtime) . "\n", 1;
printit "Command line: $0 @ARGV\n", 3;

# No options supplied -- display help and exit
if (@ARGV == 0) {
    showHelp;
    exit EXITCONFIG;
}

# Get and validate options
if (processOptions() > 0) {
    printlog "ERROR: Problems found in configuration -- stopping\n", 1;
    printlog "Try '$Script --help' or 'man $Script' for help.\n", 1;
    logit '-' x 80, 1;
    exit EXITCONFIG;
}

# Help requested - display and exit
if ($Opt{help}) {
    showHelp;
    exit EXITOK;
}

# Version requested - display and exit
if ($Opt{version}) {
    showLicence;
    exit EXITOK;
}

# Turn off stacktrace if not required
if ($Opt{stacktrace}) {
    $SIG{__DIE__} = sub { Carp::confess( @_ ) };
} else {
    $SIG{__DIE__} = 'DEFAULT';  
}

# Create a lock to prevent overlapping runs
open(LOCKFILE, '>', $Opt{lockfile}) 
    or die "Can not open lock-file '$Opt{lockfile}' for writing: $!\n";
flock(LOCKFILE, LOCK_EX | LOCK_NB) 
    or die <<ENDOFMESSAGE;
Can not lock lock-file '$Opt{lockfile}'.  
$Script is probably already running with that lock-file.  
If you're sure it isn't, delete the lock-file and try again.
ENDOFMESSAGE

displayOptions();

# This is where it all happens
if ($Opt{test}) {
    testSuite();
} elsif ($Opt{status}) {
    # Display the status of snapshots on each destination
    my $di = 0;
    while (!$Quitting and $di <= $#{$Opt{destination}}) {
        my $dest = ${$Opt{destination}}[$di];
        my %S = getSnapshotList($dest);
        status($dest, %S);
        $di += 1;
    }
} else {
    my @specs = processSpecs();
    # Run rsync to each of the destinations
    my $di = 0;
    while (!$Quitting and $di <= $#{$Opt{destination}}) {
        run(${$Opt{destination}}[$di], @specs);
        $di += 1;
    }
}

printlog "\n$Script stopping at " . (strftime "%H:%M:%S", localtime) . "\n", 1,1;
logit '-' x 80, 1;

# Free the lock
close(LOCKFILE);    # closing the file automatically unlocks it
unlink $Opt{lockfile};

exit $ExitCode;
# That's the end

#===================================================================================================

