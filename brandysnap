#!/usr/bin/perl
# 
#########################################################################
# brandysnap: rsync-based backup snapshot creation and management       #
# Copyright (C) 2011-2014 Chris Dennis, chris@starsoftanalysis.co.uk    #
#                                                                       #
# This program is free software: you can redistribute it and/or modify  #
# it under the terms of the GNU General Public License as published by  #
# the Free Software Foundation, either version 3 of the License, or     #
# (at your option) any later version.                                   #
#                                                                       #
# This program is distributed in the hope that it will be useful,       #
# but WITHOUT ANY WARRANTY; without even the implied warranty of        #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         #
# GNU General Public License for more details.                          #
#                                                                       #
# You should have received a copy of the GNU General Public License     #
# along with this program.  If not, see <http://www.gnu.org/licenses/>. #
#########################################################################

# Coding style:
# CONSTANTS in upper case
# Globals with a leading capital
# otherVariables in camelCase (except for some frequently used things like @S)
# Formatting this file -- see the 'vim:' line at the end,
# and limit lines to 100 characters if possible.
# Keep it neat and tidy!

# This version now includes code to work on Cygwin
# which has not been extensively tested yet.
# To do:
#   * IMPORTANT: detect non-NTFS, and warn re lack of hard links
#   * different defaults?
#   * is blocksize 512?
#   * sourceDir()
#   * tests for remoteness
#
# Known bugs and caveats with Cygwin:
#  - only works on NTFS -- FAT lacks hard links; other filing systems
#    may not work either.
#  - a remote host with a single-letter hostname will be treated as
#    a local drive letter.  If you've really got single-letter hosts,
#    use 'rsync://C/path' instead of 'C:/path'.
#  - conversely, a local drive-letter+pathname combination without
#    a slash or backslash, will be treated as a remote host.
#    So use 'P:/full/path' instead of 'P:path'
#    (the latter would be foolish in any case, because it would vary
#    according to whatever happened to be the current working directory
#    on drive P:)

# Mainline code is at the end of this file

use 5.10.1;         
use strict;
use warnings;

use Time::Local;
use POSIX qw(ceil floor strftime);
use Date::Manip;    # see http://search.cpan.org/~sbeck/Date-Manip-6.23/lib/Date/Manip/DM6.pod
use Getopt::Long qw(GetOptionsFromArray :config ignore_case auto_abbrev);
use Math::Combinatorics;
use JSON;           # for metadata file
use File::Path qw(remove_tree);
use File::Glob qw(:glob); 
use File::Find;
use File::Temp qw(tempfile tempdir);
use File::Spec::Functions qw(rel2abs splitdir catfile catdir);
use File::Basename;
use Fcntl qw(:flock);
use Scalar::Util qw(looks_like_number);
use IPC::Open3;
use Symbol qw(gensym);
use IO::File;
use Sys::Hostname;
use Carp;
use Data::Dumper;   # only for development and debugging

# Operating system -- assume Linux unless these flags say otherwise ===============================

my $Win = 0;
my $Cygwin = 0;
#print "OS=$^O\n";
# Don't forget: $^O is the OS Perl was compiled for, not what it's running on.
if ($^O =~ /Win/) { 
    $Win = 1;  # TODO if /Win/, look for cygwin environment
} elsif ($^O =~ 'cygwin') { 
    $Win = 1; 
    $Cygwin = 1; 
}
# TODO: if Win but not cygwin, could check for '-d /cygdrive' to see if we're in cygwin env.
#  (but we'll probably never run under non-cygwin Windows)
if ($Win and !$Cygwin) {
    print "Error: Running on Windows without Cygwin is not supported -- stopping\n";
    exit 6;
}

# Work out where we are
my $Cygdrive  = '/cygdrive';    # default
my $CygdriveC = '/cygdrive/c';
if ($Cygwin) {
    chomp(my $cygpath = `cygpath --windir` // '');  # returns e.g. /cygdrive/c/Windows
    if (!$?) {
        ($CygdriveC = $cygpath)   =~ s|/[^/]*$||;    # gets e.g. /cygdrive/c
        ($Cygdrive  = $CygdriveC) =~ s|/[^/]*$||;    # gets e.g. /cygdrive
    }
}

# Handling line endings
my $EOL = '';
$EOL = ':crlf' if $Cygwin;

# Interrupts and other housekeeping ===============================================================

# get a stacktrace: (may get turned off later)
$SIG{__DIE__} = sub { Carp::confess(@_) };

# Make this script robust against interruptions.
# $Interrupted becomes true if the script has been interrupted
my $Interrupted = '';
# Set the process group so that we can tidy up child processes:
# What's the Cygwin way for this?: 
if (!$Cygwin) {
    setpgrp(0, 0);
}
# Trap interrupts: set a flag and make sure any children are killed
sub killgroup {
    my $sig = shift;
    $SIG{$sig} = 'IGNORE'; # don't kill ourselves again
    $Interrupted = $sig; 
    kill($sig, -$$);
};
local $SIG{HUP}  = \&killgroup;
local $SIG{INT}  = \&killgroup;
local $SIG{QUIT} = \&killgroup;
local $SIG{ABRT} = \&killgroup;
local $SIG{TERM} = \&killgroup;

# Turn off buffering on STDOUT to get instant messages
$| = 1;

# Globals and constants ============================================================================

my $Script = 'brandysnap';

# Version of this script
our $VERSION = "0.2.19-next";

# A copy of @ARGV before it gets shifted
my @ARGVcopy = @ARGV;

# Exit codes
use constant EXITOK     => 0;
use constant EXITCONFIG => 1;   # Configuration/option error
use constant EXITSPECS  => 2;   # Spec error
use constant EXITRSYNC  => 3;   # Error running rsync
use constant EXITINT    => 4;   # Interrupted
use constant EXITNOLOCK => 5;   # Can't get lock
my $ExitCode = EXITOK;

# Options -- need some options to start with
our %Opt = ();   
$Opt{debug}    = {}; #{'rc'=>1, 'ap'=>1, 'po'=>1 }; # Set this when debugging processOptions(), or just {}
$Opt{verbose}  = 1;
$Opt{loglevel} = 1;

# Template for snapshot directory names -- the date part:
# (if you change this, existing snapshots will not be found!)
use constant STAMPFMT  => "%Y%m%d-%H%M%S";
use constant STAMPFMT0 => '00000000-000000';

# Hash of snapshots for the current destination, keyed by snapshot Unix time,
# each entry containing these fields:
#  name     - name of the snapshot directory e.g. 'docs-20111130-320234'
#  path     - directory path to name (NOT ending with '/')
#  fullname - same as path/name   
#  unfinished - true if it's an unfinished snapshot
#  totbytes - total size of the snapshot
#  tfrbytes - size of data transferred for this snapshot from rsync stats
#  totfiles - number of files in the snapshot - ditto
#  tfrfiles - number of new files in the snapshot - ditto
#  remote   - true if it's on a remote destination
#  daemon   - true if it's remote and accessed via an rsync daemon
#   (the last two are the same for all snapshots on a destination
#    but it's convenient to store them here)
my %S;

# Date/time constants and globals 

# A value that will be bigger than any value of 'time' or any total of lots of 'time's
use constant MAXTIME => 2**53;  # according to http://www.perlmonks.org/?node_id=718414

# An 'unlimited' number of snapshots
use constant UNLIMITED => 99999;

# Days in the month (ignoring leap years)
my @DiM = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);

# Datecalc deltas for each period:
my @PrevP = (
    '-0:0:-0:0:1:0:0',  # h 
    '-0:0:-0:1:0:0:0',  # d
    '-0:0:-1:0:0:0:0',  # w
    '-0:1:-0:0:0:0:0',  # m
    '-1:0:-0:0:0:0:0',  # y
);

# Date::Manip's period identifiers
# (see http://search.cpan.org/~sbeck/Date-Manip-6.24/lib/Date/Manip/Delta.pod#PRINTF_DIRECTIVES)# 
# indexed by periodn
my @DMperiod = ('h', 'd', 'w', 'M', 'y');

# For converting e.g. 'd' to 1
my %Level = (h => 0, d => 1, w => 2, m => 3, M => 3, y => 4);

my @LevelName = ('hour', 'day', 'week', 'month', 'year');
my %LevelName = ('h' => 'hour',
                 'd' => 'day',
                 'w' => 'week',
                 'm' => 'month',
                 'M' => 'month',
                 'y' => 'year',
                 ''  => '');    # for 'old' cSpecs

# Number of hours in periods at each level
# (approximate for months and years)
my @Hours = (1, 24, 24*7, 24*7*4, 24*7*4*12);   

# Periods in seconds:
use constant MINUTE => 60;
use constant HOUR   => MINUTE * 60;
use constant DAY    => HOUR * 24;
use constant WEEK   => DAY * 7;
# months and years aren't fixed in terms of seconds!
use constant MONTH  => DAY * 28;    # shortest possible month
use constant YEAR   => DAY * 365;   # non-leap year

# Error codes trapped in systemCall()
my %ErrorCodes = (
    'diskfull'    => 'no space left on device',
    'nofileordir' => 'no such file or directory',
    'nohost'      => 'could not resolve hostname',
    'interrupted' => 'interrupted',
    'timedout'    => 'connection timed out',
    'permission'  => 'permission denied',
    'readonly'    => 'read-only file system',
);

# Regexp used for parsing a spec, e.g. 1d or 1d7 or 0-2d31
my $specRegex = 
           '\s*(?<freqmin>\d+)
            \s*(-\s*(?<freqmax>\d+))?
            \s*(?<period>[hdwmy])
            \s*(?<count>\d*)
            \s*';

# An empty temporary directory for use in deleteSnapshot(), rsyncMkdir(), etc.
# (yes, I know, this is a bit of a kludge)
my $EmptyDir = tempdir(CLEANUP => 1);

# Flags for use in displaySummary()
my $AllDestsFailed = 1;
my $AnyDestFailed  = 0;

# Summary of results for each destination/source
# (initialised in processOptions())
my %Summary;

# Arrays and hashes defining types of options
# All options
my @AllOpt = qw(
    debug verbose verbosity loglevel test
    hbest dbest wbest mbest ybest
    safe calendar strict
    config destination specs template source
    snapshot delete delete-cp
    dry-run dryrun version help
    weekstart
    logfile lockfile 
    rsync-cmd rsync-opts rsync-xopts remote-rsync-cmd
    include include-from exclude exclude-from filter ief
    expire-old
    bwlimit latest latest-copy
    status compress restart
    allow-restart ldcount ldmin
    all-failed some-failed
    min-interval hostname
    timeout-retries
    email-prog email-to email-from email-if email-test
    );
my %AllOpt = (map {$_ => 1} @AllOpt);
# Required options (not including those that have a default value)
# also not including DestReqOpt ones
my @ReqOpt = qw(destination);
my %ReqOpt = (map {$_ => 1} @ReqOpt);
# Multi-value options (are also all string options)
my %MultiOpt = (map {$_ => 1} qw(source include include-from
    exclude exclude-from filter ief destination debug email-to));
# Boolean options
my @BoolOpt = qw(safe calendar snapshot delete delete-cp dry-run help strict 
    version expire-old status compress restart allow-restart
    email-test latest latest-copy);
my %BoolOpt = (map {$_ => 1} @BoolOpt);
# String options (NOT the multi-value ones, which are dealt with separately)
my @StringOpt = qw(config lockfile logfile template
    rsync-cmd rsync-opts rsync-xopts remote-rsync-cmd
    all-failed some-failed hostname
    email-from email-prog);
my %StringOpt = (map {$_ => 1} @StringOpt);
# Numeric options
my @NumericOpt = qw(verbose loglevel test
    hbest dbest wbest mbest ybest 
    weekstart bwlimit timeout-retries 
    ldcount ldmin min-interval);
my %NumericOpt = (map {$_ => 1} @NumericOpt);
# Level options (take values 0..9)
my @LevelOpt = qw(verbose loglevel);
my %LevelOpt = (map {$_ => 1} @LevelOpt);
# Include/Exclude/Filter options (dealt with internally as ief)
my @IEFOpt = qw(include exclude include-from exclude-from filter);
my %IEFOpt = (map {$_ => 1} @IEFOpt);

# Contexts
# --------
# A context is a section of the options structure which relates to a particular
# destination or source.
# Each context is a hash: {location=><string>, options=><options hash>}
# The options which can occur within a context are defined by the matrix below.
# The global context is called 'general'.
# Contexts can be nested, as defined below: currently the only nesting allowed
# is of sources within a destination.
# Each destination or source option is an array of contexts.

# Valid contexts and nesting thereof:
my %ValidContext = (general=>1, destination=>1, source=>1);
my %AllowedContext = (
    general     => {source=>1, destination=>1},
    destination => {source=>1},
    source      => {},
);
# Matrix defining which contexts each option is allowed in
my %Matrix = (
    general => {map {$_ => 1} @AllOpt},      # all allowed
    destination => {map {$_ => 1} qw(
        hbest dbest wbest mbest ybest
        safe calendar strict
        source template specs
        include include-from exclude exclude-from filter
        snapshot delete delete-cp
        weekstart
        rsync-cmd rsync-opts rsync-xopts remote-rsync-cmd
        expire-old
        bwlimit latest latest-copy
        compress restart
        allow-restart ldcount ldmin timeout-retries
        all-failed some-failed
        min-interval hostname
        verbose loglevel debug
    )},
    # some dest-related options can be specified per-source
    # so that each dest-source combination can be different
    source => {map {$_ => 1} qw(
        rsync-cmd rsync-opts rsync-xopts remote-rsync-cmd
        include include-from exclude exclude-from filter
        bwlimit
        compress restart
        allow-restart timeout-retries
        min-interval hostname
        verbose loglevel debug
    )},
);
# Required options for each destination
# (not including those that have a default value)
my @DestReqOpt = qw(source template specs);
my %DestReqOpt = (map {$_ => 1} @ReqOpt);

# Error and warning messages, collected for emailing
my $Messages = '';

#===================================================================================================
# Logging

sub underline ($$) {
    # Underline a string with the given character
    my $string = shift;
    my $char   = shift;
    (my $lnl, $string, my $tnl) = ($string =~ /^(\n*)(.*?)(\n*)$/);
    return $lnl . $string . "\n" . $char x length($string) . $tnl;
}

# --------------------------------------------------------------------------------------------------

sub under1 ($) {
    return underline(shift, '-');
}

# --------------------------------------------------------------------------------------------------

sub under2 ($) {
    return underline(shift, '=');
}

# --------------------------------------------------------------------------------------------------

sub chomps ($) {
    # A bit like chomp, but removes all new-lines from end of the line
    # and returns the number removed.
    my $textR = shift;
    $$textR =~ s/(\n*)$//;
    my $count = length($1) // 0;
    return $count;
}

# --------------------------------------------------------------------------------------------------

sub prechomps ($) {
    # A bit like chomp, but removes all new-lines from beginning of the line
    # and returns the number removed.
    my $textR = shift;
    $$textR =~ s/^(\n*)//;
    my $count = length($1) // 0;
    return $count;
}

# --------------------------------------------------------------------------------------------------

sub printit ($;$) {
    # Print depending on the level of verbosity
    # (trailing newline to be supplied if required)
    state $prevnl = 0;  # no. of newlines at end of previous line
    state $buffer = '';
    my $text  = shift;
    my $level = shift // 1;
    return if $level > $Opt{verbose};
    my $lnl = prechomps(\$text);    # no. of leading newlines
    my $tnl = chomps(\$text);       # no. of trailing newlines
    $lnl -= max($prevnl-1, 0);      # merge newlines from previous line
    if ($tnl == 0) {
        # text is not complete -- just buffer it
        $buffer .= "\n"x$lnl . $text;
        $prevnl = 0;
    } else {
        print $buffer . "\n"x$lnl . $text . "\n"x$tnl;
        $buffer = '';
        $prevnl = $tnl;
    }
}

# --------------------------------------------------------------------------------------------------

sub logit ($;$) {
    # Simple logging to a text file, preserving newlines in the text while adding a timestamp
    # (trailing newline to be supplied if required)
    state $prevnl = 0;  # no. of newlines at end of previous line
    state $buffer = '';
    state $oldnow = 0;  # timestamp from last call
    return if !defined $Opt{validLogfile};
    my $text  = shift;
    my $level = shift // 1;
    return if $level > $Opt{loglevel};
    my $lnl = prechomps(\$text);    # no. of leading newlines
    my $tnl = chomps(\$text);       # no. of trailing newlines
    $lnl -= max($prevnl-1, 0);      # merge newlines from previous line
    if ($tnl == 0) {
        # text is not complete -- just buffer it
        $buffer .= "\n"x$lnl . $text;
        $prevnl = 0;
    } else {
        my $spaces = ' 'x21;    # same length as strftime format below
        $text = $buffer . $text;
        $text =~ s/\n/\n$spaces/gs;
        my $now = time();
        my $tstamp = $spaces;
        $tstamp = strftime "%Y-%m-%d %H:%M:%S  ", localtime($now) if $now > $oldnow;
        print LOGFILE "\n"x$lnl . "${tstamp}${text}" . "\n"x$tnl;
        $buffer = '';
        $prevnl = $tnl;
        $oldnow = $now;
    }
}

# --------------------------------------------------------------------------------------------------

sub printlog ($;$$); 
sub printlog ($;$$) {
    # Print and log depending on the level of verbosity
    my $text   = shift;
    my $plevel = shift // 1;
    my $llevel = shift // $plevel;
    state $introPrinted = 0;
    if (!$introPrinted) {
        $introPrinted = 1;
        printlog under2("\n$Script version $VERSION starting at " . 
            (strftime "%H:%M:%S", localtime) . "\n\n"), 1,1;
    }
    printit $text, $plevel;
    logit $text, $llevel;
}

# --------------------------------------------------------------------------------------------------

sub debug ($;$) {
    # Print debugging information to STDOUT and log depending on the type of debugging
    my $text  = shift;
    my $level = shift // '';
    my $prefix = '';
    $prefix = "$level: " if $level;
    if ($Opt{debug}->{lc($level)}) {
        (my $leadingnl, $text) = ($text =~ m/^(\n*)(.*)$/s); 
        chomp $text;
        printlog "${leadingnl}dbg: $prefix$text\n", 0,0;
    }
}

# --------------------------------------------------------------------------------------------------

sub printEWN ($$$;$) {
    # Print an error/warning/note message with fancy formatting
    # FIXME this only indents the second line properly, not the third...
    my $text   = shift;
    my $prefix = shift;
    my $plevel = shift;
    my $llevel = shift // $plevel;
    (my $leadingnl, $text, my $trailingnl) = ($text =~ m/^(\n*)(.*?)(\n*)$/s); 
    my $spaces = ' ' x length($prefix);
    $text =~ s/(\n+)/$1$spaces/;
    $Messages .= "$leadingnl$prefix$text$trailingnl" if $plevel <= 2;
    printlog "$leadingnl$prefix$text$trailingnl", $plevel,$llevel;
}

# --------------------------------------------------------------------------------------------------

sub printError ($;$$) {
    # Print an error messsage, by default at level 1
    my $text   = shift;
    my $plevel = shift // 1;
    my $llevel = shift // $plevel;
    printEWN $text, 'ERROR: ', $plevel,$llevel;
}

# --------------------------------------------------------------------------------------------------

sub printWarning ($;$$) {
    # Print a warning messsage, by default at level 2
    my $text   = shift;
    my $plevel = shift // 2;
    my $llevel = shift // $plevel;
    printEWN $text, 'WARNING: ', $plevel,$llevel;
}

# --------------------------------------------------------------------------------------------------

sub printNote ($;$$) {
    # Print a note, by default at level 3
    my $text   = shift;
    my $plevel = shift // 3;
    my $llevel = shift // $plevel;
    printEWN $text, 'NOTE: ', $plevel,$llevel;
}

# --------------------------------------------------------------------------------------------------

sub printMsg ($) {
    # Print a message that may already start with 'ERROR' or 'WARNING'
    my $text = shift;
    if ($text =~ /^\s*ERROR/) {
        $Messages .= $text;
        printlog $text, 1,1;
    } elsif ($text =~ /^\s*WARNING/) {
        $Messages .= $text;
        printlog $text, 2,2;
    } else {
        printlog "$text", 3,3;
    }
}

#===================================================================================================

# Useful stuff

# Simple min/max routines for use with numbers
sub min ($$) {
    my $a = shift;
    my $b = shift;
    return ($a < $b) ? $a : $b;
}
sub max ($$) {
    my $a = shift;
    my $b = shift;
    return ($a > $b) ? $a : $b;
}

#---------------------------------------------------------------------------------------------------

sub round ($) {
    # Simplistic integer rounding
    my $float = shift;
    return int($float - 0.5) if $float < 0;
    return int($float + 0.5);
}

#---------------------------------------------------------------------------------------------------

my @Suffix = ('B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB');
        # see http://physics.nist.gov/cuu/Units/binary.html
sub bytes ($) {
    # Simple routine for displaying a file size
    # (it could be -1 for a new snapshot during a dry-run)
    my $n = shift;
    return '' if (!defined $n) or ($n eq '') or ($n < 0);
    return '0 B' if $n == 0;
    my $base = 1024;
    my $mult = 0;
    #debug "n=$n mult=$mult\n", 'bytes';
    while ($n >= $base) { 
        $n /= $base;
        $mult += 1;
        #debug "n=$n mult=$mult\n", 'bytes';
    }
    my $dp = 0; # number of decimal places
    if ($mult > 0) {
        # minimal code for displaying 3 significant figures:
        my $intn = int($n + 0.5);   # $n is always positive
        if ($intn >= 100) {
            $dp = 0;
        } elsif ($intn >= 10) {
            $dp = 1;
        } else {
            $dp = 2;
        }
        #debug "intn=$intn   dp=$dp\n", 'bytes';
    }
    return sprintf ("%4.*f %s", $dp, $n, $Suffix[$mult]);
}

#---------------------------------------------------------------------------------------------------

sub superchomp ($) {
    # Chomp that also removes trailing \015 -- why is this needed??
    # - because in cygwin \n is just \012, but files (such as the
    # configuration file) have possibly been edited with Windows' \015\012 newlines
    # That doesn't explain why this is only need for 'spec' though.
    foreach (@_) {
        s/\r?\n?$//;
    }
}

#---------------------------------------------------------------------------------------------------

sub combinations ($@) {
    # Return all ways of choosing $n items from @list
    my $n    = shift;  
    my @list = @_;
    my @combs;
    my $generator = Math::Combinatorics->new(count => $n, data => [@list],);
    while (my @combo = $generator->next_combination) {
        # (elements in @combo are in same order as in @list)
        push @combs, [@combo];
    }
    return @combs;
}

#---------------------------------------------------------------------------------------------------

sub stripQuotes ($) {
    # If the user has enclosed the option in single or double quotes,  
    # we'll strip them off (and add single quotes later).
    # If there are more than one set, e.g. '"string"' or "'string'",
    # assume that the string is really supposed to have the inner
    # set as part of its value.
    # Any other quotes, such as abc'def or xyz" will also be treated
    # as part of the value.
    # And double quotes will be escaped, ready for the string to
    # be wrapped in double quotes when used in the rsync command.
    # Also strips surrounding white-space, e.g. | str ing  | -> |str ing|
    my $string = shift;
    die "stripQuotes -- $string is a reference!!" if ref($string);
    my $temp = $string; # just for debugging
    $string =~ s/^\s+//;                # strip leading white-space
    $string =~ s/\s+$//;                # strip trailing white-space
    if (!($string =~ s/^'(.*)'$/$1/)) { # strip single quotes
        $string =~ s/^"(.*)"$/$1/;      # strip double quotes if no singles
    }
    $string =~ s/^\s+//;                # strip white-space again
    $string =~ s/\s+$//;
    $string =~ s/\"/\\\"/g;             # escape double quotes
    debug "|$temp| -> |$string|\n", 'sQ';
    return $string;
}

#---------------------------------------------------------------------------------------------------

sub empty ($) {
    # Check whether something is 'empty'
    my $item = shift;
    return 1 if !defined($item);
    if (ref($item) eq 'ARRAY') {
        # not empty if any array element is not empty
        my $rc = 1;
        foreach (@$item) {
            $rc = 0 if $_;
        }
        return $rc;
    } elsif (ref($item) eq 'HASH') {
        # not empty if there are any entries
        return (scalar keys %$item == 0) ? 1 : 0;
    } else {    # scalar
        return 1 if $item;
    }
}

#---------------------------------------------------------------------------------------------------

sub dumpSnapshot ($) {
    # Return a printable version of a %S entry.
    my $s = shift;
    return "$s (" . time2stamp($s) . ") => {" . 
        join(' ', 
            map {"$_=>" . (defined $S{$s}{$_} ? "'$S{$s}{$_}'" : 'null')} sort keys %{$S{$s}}) ."}";
}

#---------------------------------------------------------------------------------------------------

sub dumpSnapshots (@) {
    # Return a list of snapshots' timestamps as a string for printing.
    my @S = @_; 
    return join(', ', map {time2stamp($_)} @S);
}

#---------------------------------------------------------------------------------------------------

sub dumpSnapshots2 (\@) {
    # Return a list of snapshots' timestamps as a string for printing.
    # This version also uses %S to mark snapshots as good or bad.
    my @S = @{(shift)};
    return join(', ', map {time2stamp($_) . ($S{$_}{unfinished} ? '-b' : '-g')} @S);
}

#---------------------------------------------------------------------------------------------------

sub dumpSnapshotFullnames () {
    # Return a list of all snapshots' timestamps and their full names
    my @S = sort keys %S;
    return join("\n", map {time2stamp($_) . '  ' . ($S{$_}{fullname} // 'none!')} @S);
}

#---------------------------------------------------------------------------------------------------

sub rsort (@) {
    # Simple numeric reverse sort
    return sort {$b <=> $a} @_;
}

#---------------------------------------------------------------------------------------------------

sub fmtFreq ($$) {
    # Format the frequency as either a range or a single number
    my $freqmin = shift;
    my $freqmax = shift;
    if ($freqmin == $freqmax) {
        return "$freqmin";
    } else {
        return "$freqmin-$freqmax";
    }
}

#---------------------------------------------------------------------------------------------------

sub fmtSpec ($$$$) {
    # Format a spec from its parts
    my ($freqmin, $freqmax, $period, $count) = @_;
    return fmtFreq($freqmin, $freqmax) . "$period$count";
}

#---------------------------------------------------------------------------------------------------

sub diskSpace ($) {
    # Convert a file size to the space used on the disk
    # by rounding it up to a multiple of the block size
    # NOTE: we assume a blocksize of 512 -- see 'man 2 stat'
    my $size = shift;
    my $blocksize = 512;
    return ceil($size / $blocksize) * $blocksize; 
}

#---------------------------------------------------------------------------------------------------

sub checkInterruption ($) {
    # Check if we've been interrupted: if so, print a message and exit
    my $msg = shift // '';
    if ($Interrupted) {
        printError "\nInterrupted with signal '$Interrupted' $msg\n", 1;
        exit EXITINT;
    }
}

#---------------------------------------------------------------------------------------------------

sub isHostOrFQDN {
    # Returns 1 if the given string is a simple hostname (e.g. 'fred') or
    # a fully-qualified domain name (e.g. 'fred.co.uk')
    # It does NOT allow internationalised domain names.
    # And it doesn't check that each segment is 63 chars or less.  etc.  Not my problem.
    # From http://www.perlmonks.org/index.pl?node_id=33357
    my $name = shift;                                
    if ($name =~ m/
        ^(([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9]+)\.)*   # 0 or more bits ending with '.'
          ([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$       # final bit with no '.'
        /x) {
        return 1;
    } else {
        return 0;
    }
}

# Date/time routines ===============================================================================

sub hms ($) {
    # Format a number of seconds as hh:mm:ss
    return strftime("\%H:\%M:\%S", gmtime(shift));
}

#---------------------------------------------------------------------------------------------------

sub fmtSeconds ($) {
    # Pretty-print a time period given in seconds
    my $period = shift;
    return '0 seconds' if int($period) == 0;
    use integer;
    my $s = $period % 60;
    $period /= 60;
    my $m = $period % 60;
    $period /= 60;
    my $h = $period % 24;
    $period /= 24;
    my $d = $period % 7;
    $period /= 7;
    my $w = $period % 4;
    $period /= 4;
    my $M = $period % 12;
    my $y = $period / 12;
    my $result = '';
    $result .= "$y years "   if $y != 0;
    $result .= "$M months "  if $M != 0; 
    $result .= "$w weeks "   if $w != 0; 
    $result .= "$d days "    if $d != 0; 
    $result .= "$h hours "   if $h != 0; 
    $result .= "$m minutes " if $m != 0; 
    $result .= "$s seconds " if $s != 0; 
    chop($result);  # trim final space    
    return $result;
}

#---------------------------------------------------------------------------------------------------

sub fmtHours ($) {
    # Pretty-print a time period given in hours
    my $period = shift;
    return '0 hours' if int($period) == 0;
    return fmtSeconds($period * 3600);
}

#---------------------------------------------------------------------------------------------------

sub elapsed ($$) {
    # Pretty-print the difference between two Unix times
    my $start = shift;
    my $stop  = shift;
    return fmtSeconds(abs($stop - $start));
}

#---------------------------------------------------------------------------------------------------

sub time2date ($) {
    # Convert a Unix timestamp to a Date::Manip date
    my $ts = shift;
    #my $date = new Date::Manip::Date;
    #my $err  = $date->parse("epoch $ts");
    #return $date;
    # this suddenly stopped working:
    return ParseDateString("epoch $ts");
}

#---------------------------------------------------------------------------------------------------

sub date2time ($) {
    # Convert a Date::Manip date to a Unix timestamp
    my $date = shift;
    return UnixDate($date, '%s');
}

#---------------------------------------------------------------------------------------------------

sub leapYear ($) {
    # Simple routine that assumes we're running sometime
    # between 2001 and 2099.
    # Returns 1 for a leap year, else 0
    my $moment = shift;
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($moment);
    return (($year+1900 % 4) == 0);
}

#---------------------------------------------------------------------------------------------------

sub daysInYearMonth ($$) {
    # Return the number of days in the month specified by year and month number (0..11)
    my $y = shift;
    my $m = shift;
    my $days = $DiM[$m];
    $days += 1 if ($m == 1 and leapYear($y));
    return $days;
}

#---------------------------------------------------------------------------------------------------

sub daysInMonth ($) {
    # Return the number of days in the month in which 
    # the specified moment falls
    my $moment = shift;
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($moment);
    return daysInYearMonth($year+1900, $mon);
}

#---------------------------------------------------------------------------------------------------

sub daysInYear ($) {
    # Return the number of days in the year 
    # in which the specified moment falls.
    my $moment = shift;
    return leapYear($moment) ? 366 : 365;
}

#---------------------------------------------------------------------------------------------------

sub aligned ($$) {
    # Return true if timesofar is a multiple of the given period
    # (taking a month as 4 weeks)
    my $timesofar = shift;
    my $periodn   = shift;
    return ($timesofar % $Hours[$periodn]) == 0;
}

#---------------------------------------------------------------------------------------------------

# Timestamp format for snapshots is YYYYMMDD-hhmmss
# as defined by STAMPFMT and hard-coded in the following subroutine.

sub stamp2time ($) {
    # convert filename-type timestamp to Unix time
    my $stamp = shift;
    return 0 if $stamp eq STAMPFMT0; 
    if ($stamp =~ /(?<Y>\d\d\d\d)(?<M>\d\d)(?<D>\d\d)-(?<h>\d\d)(?<m>\d\d)(?<s>\d\d)/) {
        return timelocal($+{s},$+{m},$+{h},$+{D},$+{M}-1,$+{Y});
    }
    debug "WARNING -- invalid stamp '$stamp' -- returning 0\n", 's2t';
    return 0;
}

#---------------------------------------------------------------------------------------------------

sub time2stamp ($) {
    # convert Unix time to filename timestamp
    my $time = shift;
    return STAMPFMT0 if !$time or $time == 0;
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($time);
    return strftime(STAMPFMT, localtime($time));
}

#---------------------------------------------------------------------------------------------------

sub time2stampz ($) {
    # convert Unix time to filename timestamp, including timezone
    my $time = shift;
    return STAMPFMT0.'+0000' if !$time or $time == 0;
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($time);
    return strftime(STAMPFMT.'%z', localtime($time));
}

#---------------------------------------------------------------------------------------------------

sub pair2range ($$) {
    # Convert a beginning/end pair of Unix times to a readable range
    my $beg = shift;
    my $end = shift;
    return time2stamp($beg) . '--' . time2stamp($end);
}

#---------------------------------------------------------------------------------------------------

sub fullName ($) {
    # Return the full version of an option name
    my $name = lc(shift);
    my @matches;
    foreach my $fullname (@AllOpt) {
        return $name if $name eq $fullname; # exact match
        push @matches, $fullname if $fullname =~ /^$name/i;
    }
    return $name if @matches == 0;
    return $matches[0] if @matches == 1;
    printError "Option '$name' is ambiguous, matching any of " .
        join(', ', @matches) . "\n";
    return '!*ambiguous';
}

#===================================================================================================
# Email stuff

sub emailSend ($$) {
    # Minimal email sending process: all the modules I could find are either
    # broken or too complex.  So this relies on the system having an email setup.
    # TODO Cygwin: not tested at all yet
    my $subject = shift;
    my $body    = shift;
    #debug "email-to="Opt{'email-to'} 
    debug "emailSend -- no email-to", 'eS' if !$Opt{'email-to'};
    return 0 if !$Opt{'email-to'};
    debug "email-to=@{$Opt{'email-to'}} body=$body\n", 'eS';
    my $rc = 0;
    if (open MAIL, '|-', $Opt{'email-prog'}) {
        print MAIL "From: $Opt{'email-from'}\n";
        print MAIL "To: " . join(',', @{$Opt{'email-to'}}) . "\n";
        print MAIL "Subject: $subject\n";
        print MAIL "\n$body\n";
        close(MAIL);
    } else {
        printError "Failed to run '$Opt{'email-prog'}' to send email (rc=$rc)\n";
        $rc = 1;
    }
    return $rc;
}

#---------------------------------------------------------------------------------------------------

sub emailTest () {
    # Send a test email
    if (!$Opt{'email-to'}) {
        printError "Unable to send the test message: no email-to option given\n";
    }
    my $msg = "This is a test message from backup script '$Script', running on '" . 
        hostname . "'.\n\n";
    $msg   .= "The command-line options specified were: \n";
    $msg   .= "    @ARGVcopy";
    if (emailSend("$Script test message from " . hostname, $msg)) {
        printError "Unable to send the test message: please check the 'email-xxx' options\n";
    } else {
        printNote "Email test message has been sent to @{$Opt{'email-to'}}\n";
    }
}

#---------------------------------------------------------------------------------------------------

sub emailConfigError ($$) {
    # Send an email message reporting the configuration problem
    my $e    = shift;
    my $w    = shift;
    return if !($Opt{'email-to'});
    my $text = "This is an error message from backup script '$Script', running on '" . 
        hostname . "'.\n\n";
    $text .= "There was a problem with the configuration, " . 
        "and backup script '$Script' did not run.\n\n";
    $text .= $Messages;
    $text .= "\n($e errors, $w warnings)\n\n";
    $text .= "Command line options: \n$0 @ARGVcopy\n";
    $text .= "\nConfiguration file: '" . hostname . ":$Opt{config}'\n\n" if $Opt{config};
    #$text .= formatOptions();
    # Errors in config, so better to not print options summary,
    # just command line, config file, and error messages
    my $rc = emailSend("$Script error on " . hostname, $text);
    if ($rc) {
        printWarning "\nCould not send email to @{$Opt{'email-to'}}.\n", 1;
    } else {
        printNote "\nEmail sent to @{$Opt{'email-to'}}\n", 1;
    }
}

#===================================================================================================
# Filing system stuff

sub remote ($) {
    # Returns 'true' if the path is considered by rsync to be remote
    # (via daemon or just ssh)
    # (See rsync's man page re the significance of ':')
    my $path = shift;
    if ($Cygwin) {
        # On Windows, ':' can also indicate a drive letter.
        # NOTE: if you have remote hosts with single-letter host names, you'll have to use
        #       'rsync://C/path' syntax instead of 'C:/path'.
        # NOTE: 'C:/something' is an absolute path
        #       'C:another' just means 'another' in the current dir on drive c:
        #       the use of which would be silly, so we won't worry about it.
        return 0 if $path =~ m{^[A-Za-z]:(\\|\/)};
    }
    return 1 if index($path, ':') > -1;
    return 0;
}

#---------------------------------------------------------------------------------------------------

sub remoteDaemon ($) {
    # Returns 'true' if the path is considered by rsync to be remote
    # via the rsync daemon
    # (See rsync's man page re the significance of '::' and 'rsync://')
    my $path = shift;
    return 1 if $path =~ m|^rsync://|;
    return 1 if index($path, '::') > -1;
    return 0;
}

#---------------------------------------------------------------------------------------------------

sub anyDestRemoteDaemon () {
    # Returns 'true' if any of the destinations are using an rsync daemon
    foreach my $dest (@{$Opt{destination}}) {
        return 1 if remoteDaemon($dest);
    }
    return 0;
}

#---------------------------------------------------------------------------------------------------

sub absPath ($) {
    # Convert a file or directory name into an absolute
    # path, with '~' (home directory) expansion.
    my $path = shift;
    debug "orig: $path\n", 'aP';
    return $path if remote($path);  # yes, that handles drive letters too
    # Expand leading '~' to user's home path.
    # NOTE: This is Unix-specific (but works with cygwin too) 
    # See http://stackoverflow.com/questions/4404628/abs-path-with-the-home-directory
    # and http://docstore.mik.ua/orelly/perl4/cook/ch07_04.htm
    $path =~ s{^~([^/]*)}{$1?(getpwnam($1))[7]:($ENV{HOME} || $ENV{LOGDIR} || (getpwuid($<))[7])}ex;
    debug "after ~: $path\n", 'aP';
    if ($Cygwin) {
        $path = Cygwin::win_to_posix_path($path, 1);
        debug "after cygwin: $path\n", 'aP';
    }
    $path = rel2abs($path);
    debug "after rel2abs: $path", 'aP';
    return $path;
}

#---------------------------------------------------------------------------------------------------

sub sourceDir ($) { 
    # Remote sources require an enclosing directory on the destination
    # to ensure that there is no overlap.
    # For example, two sources chris@host1:~/home and chris@host2:~/home
    # would both put files into /home on the destination without this.
    #
    # rsync deals with remote sources in the following formats:
    #   [USER@]HOST::MODULE/SRC
    #   rsync://[USER@]HOST[:PORT]/MODULE/SRC
    #   [USER@]HOST:SRC
    # The enclosing directory will be HOST[-MODULE]
    my $source = shift;
    return '' if !remote($source);
    my $dir = '';
    if (($source =~ m{^((?<u>[^@]*)@)?(?<h>[^:/]+)::(?<m>[^/]+)}) or 
        ($source =~ m{^rsync://((?<u>[^@]*)@)?(?<h>[^:/]+)(:(?<p>\d+))?/(?<m>[^/]+)})) {
        # daemon
        $dir = "$+{h}-$+{m}";
    } elsif ($source =~ m{^((?<u>[^@]*)@)?(?<h>[^:/]+):}) {
        # non-daemon
        $dir = $+{h};
    } else {
        # shouldn't happen -- return ''
        printWarning "Unparseable source '$source'", 1,1;
    }
    return $dir;
}

#---------------------------------------------------------------------------------------------------

sub stdArgs ($) {
    # Return the standard arguments for rsync calls
    my $sending = shift;  # True for sending, false for receiving  !! not used at present
    my $args = '';
    if ($Opt{'remote-rsync-cmd'}) {
        $args .= "--rsync-path '$Opt{'remote-rsync-cmd'}' ";
    }
    #if ($sending) {
    #    $args .= "--bwlimit=$Opt{'bwlimit-out'} ";
    #} else {
    #    $args .= "--bwlimit=$Opt{'bwlimit-in'} ";
    #}
    return $args;
}

#---------------------------------------------------------------------------------------------------

sub getSnapshotSize ($) {
    # Get the current size of a snapshot by getting the directory
    # listing via rsync and adding up the numbers.
    # 
    # rsync returns directory listings thusly (even for recent dates, and even on Cygwin):
    #    -rwxr-xr-x         149 2008/06/13 13:56:30 textsmart
    #    drwxr-xr-x        4096 2011/05/07 17:41:48 40dnamer
    # and gives return code 23 if the directory is not found
    #                       255 for wrong password, unknown host etc.
    # Note the lack of nlink information, so we can't calculate 'delete size'.
    my $snapshot = shift;
    my $totalBytes = 0;
    my $totalFiles = 0;
    my $dirsOnly = 1;
    # Get rsync listing into an array
    my (@items, @errors);
    debug time2stamp($snapshot) . ": fullname=" . ($S{$snapshot}{fullname} // 'none!'), 'gSS';
    my ($rc, $rc2) = systemCall($Opt{'rsync-cmd'}, 
        stdArgs(0) . " --recursive --list-only '$S{$snapshot}{fullname}/'", 9,9, \@items, \@errors);
    debug "snapshot=$snapshot rc=$rc rc2='$rc2'\n", 'gSS';
    if (!$rc) {
        foreach my $item (@items) {
            debug "item = $item", 'gSS';
            # matching e.g.: drwxr-xr-x        4096 2011/05/07 17:41:48 40dnamer
            # or             -rwxr--r--       12345 2011/05/07 12:13:14 foo
            if ($item =~ m|^
                (?<t>.)
                (?<p>.{9})\s+
                (?<size>\d+)\s\d{4}/\d{2}/\d{2}\s\d{2}:\d{2}:\d{2}\s
                (?<name>.+)$
                |x) {
                debug "matched name=$+{name} size=$+{size}\n", 'gSS';
                next if $+{name} eq '.';
                next if $+{name} eq '..';
                # skip source hostname dir, i.e. top level, i.e. anything without a /
                next if index($+{name}, '/') == -1;
                if ($+{t} eq '-' or $+{t} eq 'l' or $+{t} eq 'd') {
                    # file or symbolic link or directory
                    # (we're not following the symbolic link, 
                    # just counting the space of the link itself)
                    # (and we're counting the directory itself, not its contents)
                    debug "t=$+{t} size=$+{size} name=$+{name}\n", 'gSS';
                    $totalBytes += diskSpace($+{size});
                    $totalFiles += 1;
                    $dirsOnly = 0 if $+{t} eq '-' or $+{t} eq 'l';
                } else {
                    # (ignore anything other than files and directories)
                    debug "ignoring non-file-or-dir $item\n", 'gSS'
                }
            } else {
                # (ignore any non-matching lines)
                debug "ignoring non-matching $item\n", 'gSS'
            }
        }
    } else {
        # Error -- return -1
        printError "Unable to get the size of snapshot $S{$snapshot}{fullname}";
        ($totalBytes, $totalFiles) = (-1, -1);
    }
    # If a snapshot only contains empty directories, consider it empty
    if ($dirsOnly) {
        printWarning "Snapshot $S{$snapshot}{name} has only empty directories -" .
        " its size will be set to zero\n";
        return (0, 0);
    }
    return ($totalBytes, $totalFiles);
}

#---------------------------------------------------------------------------------------------------

sub updateSnapshotSizes () {
    # Make sure that each snapshot in %S has size information
    foreach my $snapshot (keys %S) {
        next if (defined $S{$snapshot}{totbytes});  # info is already there 
        my ($totalBytes, $totalFiles) = getSnapshotSize($snapshot);
        if ($totalBytes >= 0) { 
            $S{$snapshot}{totbytes} = $totalBytes;
            $S{$snapshot}{totfiles} = $totalFiles; # FIXME why was this commented out?
            debug "adding size information for $S{$snapshot}{name}, bytes=$totalBytes\n", 'uSS';
        } else {
            # couldn't get the size, leave it undefined
        }
    }
}

#---------------------------------------------------------------------------------------------------

sub rsyncMkdir ($) { 
    # Use rsync to create a directory.
    # Returns rsync return code -- zero if successful.
    my $newdir = shift;  # full path of dir to be created
    my @output;
    my @errors;
    # FIXME ? --chmod may only work with --perms -- is --perms needed here?
    my ($rc, $rc2) = systemCall($Opt{'rsync-cmd'},
        stdArgs(1) . " -v --recursive --chmod=ug=rwx,o=rx $EmptyDir/ $newdir", 
        9,9, \@output, \@errors);
    debug "newdir='$newdir' rc=$rc rc2=$rc2 output='@output' errors='@errors'\n", 'rMd';
    # Note: no error if it's already there
    return $rc;
}

#---------------------------------------------------------------------------------------------------

sub rsyncRmdir ($$) {
    # Use rsync to remove a directory.  (seems to work on files too)
    # Returns rsync return code -- zero if successful.
    my $dir    = shift;  # full path of containing directory
    my $subdir = shift;  # subdir within dir to be deleted
    my @output;
    my @errors;
    my ($rc, $rc2) = systemCall($Opt{'rsync-cmd'},
        stdArgs(1) . "--dirs -f '-!r $subdir' --delete $EmptyDir/ $dir",
        9,9, \@output, \@errors);
    debug "dir='$dir' subdir='$subdir' rc=$rc rc2=$rc2 output='@output' errors='@errors'\n", 'rRm';
    return $rc;
}

#---------------------------------------------------------------------------------------------------

sub rsyncExists ($) {
    # Use rsync to check if a directory or file exists.
    my $item = shift;   # full path of directory or file
    my @output;
    my @errors;
    my ($rc, $rc2) = systemCall($Opt{'rsync-cmd'},
        stdArgs(1) . " --list-only $item", 
        9,9, \@output, \@errors);
    debug "item='$item' rc=$rc rc2=$rc2 output='@output' errors='@errors'\n", 'rEx';
    # rc=23 if it doesn't exist.
    # FIXME what about other errors?
    return ($rc, $rc2);
}

sub rsyncExistsTest ($) {
    # True/false version of rsyncExists
    my $item = shift;   # full path of directory or file
    my ($rc, $rc2) = rsyncExists($item);
    return ($rc == 0 ? 1 : 0);
}

#---------------------------------------------------------------------------------------------------

sub rsyncMakeLocal ($) {
    # Make sure a file is local: if not, make a local copy of it
    # and return the local file name (or '' on error)
    # (note the hacky way we override the --dry-run option)
    my $origPath = shift;
    if (!remote($origPath)) {
        if (rsyncExistsTest($origPath)) {
            debug "not remote, exists, returning origPath=$origPath\n", 'rML';
            return $origPath;
        } else {
            debug "no such local file: $origPath", 'rML';
            return '';
        }
    }
    my ($origBase, $origDir, undef) = fileparse($origPath);
    my $tempdir = tempdir(CLEANUP => 1);  
    debug "tempdir is $tempdir\n", 'rML';
    my (@output, @errors);
    my $dryrun = $Opt{'dry-run'};
    $Opt{'dry-run'} = 0;
    my ($rc, $rc2) = systemCall($Opt{'rsync-cmd'}, 
        stdArgs(0) . " '$origPath' '$tempdir/'", 9,9, \@output, \@errors);
    $Opt{'dry-run'} = $dryrun;
    debug "rc=$rc rc2='$rc2' newfile='$tempdir/$origBase' output: '@output' errors: @errors\n", 'rML';
    if ($rc == 0) {
        return "$tempdir/$origBase";
    } else {
        return '';
    }
}

#---------------------------------------------------------------------------------------------------

sub XrsyncReadable ($) {  # THIS IS NOT USABLE
    # Use rsync to check if a file or directory is readable
    # FIXME I think this only works if it's a directory
    # -- for a file, need to read it, i.e. copy it to a local file i.e. back it up!!
    # NO, look at the permissions in the listing!
    #  -- but it's too hard to know which is the relevant uid/gid
    # PLAN: if it's a directory (first char of first line of output is 'd'),
    #   then ... it still might not have read permissions.
    # All we can do is see if it exists...
    my $item = shift;
    my @output;
    my @errors;
    my ($rc, $rc2) = systemCall($Opt{'rsync-cmd'},
        stdArgs(0) . "--list-only $item",
        9,9, \@output, \@errors);
    debug "item='$item' rc=$rc rc2=$rc2 output='@output' errors='@errors'\n", 'rRd';
    return ($rc, $rc2); 
}

#---------------------------------------------------------------------------------------------------

sub rsyncWritable ($) {
    # Use rsync to check if a destination is writable
    my $dest = shift;
    my $tempdir = "$Script-temp-dir";    # is this unique enough?
    my @output;
    my @errors;
    if ($Opt{'dry-run'} or $Opt{status}) {
        # --dry-run: can't write to dest: just see if it's readable
        # --status : don't need to write to dest: ditto
        return rsyncExists($dest);
    }
    my ($rc, $rc2) = systemCall($Opt{'rsync-cmd'},
        stdArgs(1) . "--recursive $EmptyDir/ $dest/$tempdir/", 
        9,9, \@output, \@errors);
    debug "dest='$dest' tempdir='$tempdir' rc=$rc rc2=$rc2 output='@output' errors='@errors'\n", 
        'rW';
    return ($rc, $rc2) if $rc;  # non-zero - it's not writable
    # temp dir was created, so delete it
    rsyncRmdir($dest, $tempdir);
    return (0, '');
}

#---------------------------------------------------------------------------------------------------

sub rsyncFixPermsC ($) {
    # Tweak the permissions of /cygdrive/c  (this is for cygwin only, obviously).
    # See e.g. http://tinyurl.com/dxucxg and http://tinyurl.com/2e7q6z8
    # for a discussion of the problem.
    # An alternative would be to set 'noacl' in cygwin's /etc/fstab, but that results in every
    # file being owned by the user who ran brandysnap.
    my $destdir = shift;
    return if $Opt{'dry-run'};
    my $tempdir = tempdir(CLEANUP => 1);
    mkdir "$tempdir/c";
    debug "destdir='$destdir' tempdir='$tempdir'\n", 'rFPC';
    my ($rc, $rc2) = systemCall($Opt{'rsync-cmd'},
        "-pr $tempdir/c $destdir$Cygdrive/",  9,9);
    debug "rsync rc=$rc/$rc2\n", 'rFPC';
    if ($rc) {
        printNote "\nCould not set the permissions of $destdir$CygdriveC\n" . 
            "to sensible values: manual intervention will be required to access this snapshot\n", 
            1,1
    }
}

#---------------------------------------------------------------------------------------------------

sub lockName ($) {
    # Construct the name of a lock directory, given a pid
    my $pid = shift;
    return "$Opt{template}-lock-$pid";
}

#---------------------------------------------------------------------------------------------------

sub rsyncLockDest ($) {
    # Use rsync to create a lock directory on the destination, marking it as 'in use'.
    # The directory's name is '<template>-lock-<pid>', with the pid of the brandysnap process.
    # If any lock directories already exist and the pid is not running,
    # then delete the lock directory first.
    # If the pid is still running, then return 0 meaning "can't lock"
    my $dest = shift;
    my $locked = 0;
    my @output;
    my @errors;
    my ($rc, $rc2) = systemCall($Opt{'rsync-cmd'},
        stdArgs(0) . "--list-only $dest/",
        9,9, \@output, \@errors);
    debug "dest='$dest' rc=$rc rc2=$rc2 output='@output' errors='@errors'\n", 'rLD';
    return 0 if $rc;   # Can't get directory list, so fail
    # Loop through listing, and deal with any lock dirs
    # looking for -rw-r--r--           0 2012/11/21 16:32:44 bstest-lock-123
    my $stillrunning = 0;
    foreach (@output) {
        my $lockdirpattern = lockName('(?<pid>\d+)');
        if (/$lockdirpattern/) {
            if (kill 0, $+{pid}) {
                # process is still running
                $stillrunning = 1;
            } else {
                # no process - remove the lock dir
                rsyncRmdir($dest, lockName($+{pid}));
                # (if that fails, the lock directory will be left there untidily,
                # but we can carry on with a new lock directory)
            }
        } 
    }
    if (!$stillrunning) {
        # Create a new lock directory with our pid
        if (rsyncMkdir("$dest/" . lockName($$))) {
            printError "Failed to create lock directory " . lockName($$) . "\n";
        } else {
           $locked = 1;
        }
    }
    return $locked;
}

#---------------------------------------------------------------------------------------------------

sub rsyncUnlockDest ($) {
    # Use rsync to remove our lock directory from a destination.
    my $dest = shift;
    return rsyncRmdir($dest, lockName($$));
}

#===================================================================================================
# Handlings specs

sub calcPadding ($$$) {
    # Given a period level and a higher level and a time so far,
    # return the number of low-levels needed to get to the next high-level
    # e.g. ('d', 'm', 23days) returns 5 (days)
    # except that the levels are given numerically
    # Note that 'months' are always 28 days here.
    my $level1    = shift;
    my $level2    = shift;
    my $timesofar = shift;  # Time, counting backwards from 'now' in hours,
                            # that is already accounted for by previous specs
    my $length1 = $Hours[$level1];
    my $length2 = $Hours[$level2];
    my $result = ($length2 - ($timesofar % $length2)) / $length1;
    debug "l1=$level1 l2=$level2 tsf=$timesofar; returning $result\n", 'cP';
    if ($result != floor($result)) {
        debug "auto-padded spec is not aligned!\n", 'cP';
    }
    return floor($result);
}

#---------------------------------------------------------------------------------------------------

sub parseSpecs ($) {
    # Parse the user's requested snapshot regime, 
    # e.g. '0-4d7,1d7,2-7w,1m6'
    #
    # The letter specifies a period, and can be
    #   h - hour 
    #   d - day
    #   w - week
    #   m - month
    #   y - year
    # The first number ('freq') specifies how many snapshots should occur
    # within the period, the second how many periods.
    # The frequency can also be specified as a minimum-maximum range.
    # If the second number ('count') is omitted, it fills up the time
    # until the next spec; on the last spec, omitting the count
    # requests an 'unlimited' number of backups -- i.e. until the
    # backup disk is full.

    my $rawspecs = lc(shift);
    debug "rawspecs = $rawspecs\n", 'pS';

    my @rawspecs = split /,/, $rawspecs;
    my @specs = ();
    my $warningcount = 0;
    my $errorcount   = 0;

    foreach my $spec (@rawspecs) {
        #print "pS: before chomp: spec='$spec'  len=".length($spec)."\n";
        superchomp($spec);
        debug "spec = '$spec'\n", 'pS';
        #print "pS: after superchomp: spec='$spec'  len=".length($spec)."\n";
        if ($spec =~ /^$specRegex$/x) {
            my $freqmin = int($+{freqmin});
            my $freqmax = $freqmin;
            if ($+{freqmax}) {
                # min-max frequency specified
                $freqmax = int($+{freqmax});
            }
            if ($freqmax == 0) {
                printError "Frequency 0 in spec '$spec' is not allowed\n";
                $errorcount += 1;
                next;
            }
            if ($freqmax < $freqmin) {
                printError "Maximum frequency must be greater than minimum: \n" . 
                           "'$freqmin-$freqmax' in spec '$spec' does not make sense\n";
                $errorcount += 1;
            }
            my $period = $+{period};
            my $count; 
            if ($+{count} ne '') { 
                $count = int($+{count});
                if ($count == 0) {
                    printError "Count 0 in spec '$spec' will make no snapshots\n";
                    $errorcount += 1;
                    next;
                }
            } else {
                # no count specified -- will use padding; set to 0 for now
                $count = 0;
            }   
            push @specs, {
                rawspec => $spec, 
                freqmin => $freqmin, 
                freqmax => $freqmax, 
                period  => $period, 
                periodn => $Level{$period}, # for convenience
                count   => $count,
            };  
        } else {
            printError "Invalid spec '$spec'\n";
            $errorcount += 1;
        }
    }

    return ($warningcount, $errorcount, $rawspecs, @specs) if $errorcount;

    debug "Parsed specs: " . join(',', map {$_->{rawspec}} @specs)."\n", 'pS';

    # Check that the specs make sense
    debug "Checking specs...\n", 'pS';
    my $timesofar = 0; # in hours (because they're the smallest interval that we use)
    my $i = 0; # index into @specs
    foreach my $spec (@specs) {
        debug "Spec0: $spec->{freqmin}-$spec->{freqmax} $spec->{period} $spec->{count}\n", 'pS';
        if ($spec->{count} == 0) {
            # Pad spec to fill next period
            # e.g. 1d,1w4 -- the daily period gets padded to a week, i.e. 1d7,1w4
            # This is done even if --calendar is false.
            if ($i == $#specs) {
                # last spec -- can't pad, so set count to lots
                #printNote "Last spec padded forever\n";
                $spec->{count} = UNLIMITED; 
            } elsif ($specs[$i+1]->{periodn} <= $spec->{periodn}) {
                #printWarning "Cannot pad spec $spec->{rawspec} because next spec is " .
                #    "not at a higher level; count set to 1\n";
                #$warningcount += 1;
                $spec->{count} = 1;
            } else {
                my $padding = calcPadding($spec->{periodn}, $specs[$i+1]->{periodn}, $timesofar);
                debug "padding $spec->{rawspec} to $LevelName[$specs[$i+1]->{periodn}]\n", 'pS';
                if ($padding == 0) {
                    # already at a multiple, so just do either 0 or a whole
                    # set of the next spec 
                    # leave at 0 for now
                    debug "No padding -- stay at 0\n", 'pS';
                } else {
                    # timesofar is not a whole multiple of speclevel+1, add some padding
                    debug "padding by setting count to $padding\n", 'pS';
                    $spec->{count} = $padding;
                }
            }
            # Include the padded count in the rawspec
            $spec->{rawspec} = 
                fmtSpec($spec->{freqmin}, $spec->{freqmax}, $spec->{period}, $spec->{count});
        }
        debug "Spec1: $spec->{freqmin}-$spec->{freqmax} $spec->{period} $spec->{count}\n", 'pS';
        # Check alignment (calendar mode only)
        if ($Opt{calendar} and !aligned($timesofar, $spec->{periodn})) {
            printWarning "Spec at $LevelName[$spec->{periodn}] level is not aligned - " 
                . "it starts at " . fmtHours($timesofar) . "\n";
            $warningcount += 1;
        }
        $i += 1;
        $timesofar += $Hours[$spec->{periodn}] * $spec->{count};
    }

    # Check that interval increases 
    my $lastint  = 0;
    $i = 0;
    foreach my $spec (@specs) {
        next if $spec->{freqmax} == 0;
        my $int = $Hours[$spec->{periodn}] / $spec->{freqmax};  # yes, use max
        if ($int < $lastint) {
            printWarning "Interval is smaller for spec " . ($i+2) . 
                " ($spec->{rawspec}) than for " .  "previous one ($specs[$i-1]->{rawspec})\n";
            $warningcount += 1;
        }
        $lastint = $int;
        $i += 1;
    }

#    if (!$errorcount) {
#        printlog "Validated specs: " . join(',', 
#            map {fmtFreq($_->{freqmin}, $_->{freqmax}) . $_->{period} . $_->{count}} @specs) . 
#            "\n", 3;
#        my $TotalSnapshotsMin = 0; 
#        my $TotalSnapshotsMax = 0; 
#        foreach my $spec (@specs) {
#            $TotalSnapshotsMin += $spec->{freqmin} * $spec->{count};
#            $TotalSnapshotsMax += $spec->{freqmax} * $spec->{count};
#        }
#        if ($specs[-1]->{count} == UNLIMITED) {
#            printlog "which will create an unlimited number of snapshots\n", 3;
#        } else {
#            if ($TotalSnapshotsMin == $TotalSnapshotsMax) {
#                printlog "which will create a total of $TotalSnapshotsMax snapshots\n", 3;
#            } else {
#                printlog "which will create a total of between $TotalSnapshotsMin and " . 
#                    "$TotalSnapshotsMax snapshots\n", 3;
#            }
#        }
#    }
#    debug "Frequencies: " . 
#        join(', ', map {$_->{freqmax} / $Hours[$_->{periodn}]} @specs) . "\n", 'pS';

    # Return the rawspecs (with padding) to put back into the %Opt hash
    $rawspecs = join(',', map {$_->{rawspec}} @specs);
    debug "returning w=$warningcount e=$errorcount specs=@specs rawspecs=$rawspecs\n", 'pS';
    debug "specs: " . Dumper(\@specs), 'pS';

    return $warningcount, $errorcount, $rawspecs, @specs;  
}

#---------------------------------------------------------------------------------------------------

sub processSpecs ($) {
    # Validate the specs given 
    my $specs = shift;
    my ($warnings, $errors, $rawspecs, @specs) = parseSpecs($specs); 
    #my $msg;
    if ($errors) {
        printError "One or more specs is invalid -- stopping";
    }
    if ($warnings and $Opt{strict}) {
        printError "Warnings when parsing specs, and strict mode in effect -- stopping";
        $errors += 1;
    }
#    if (!@specs) {
#        $msg =  "ERROR: No valid specs found -- stopping";
#    }
    return ($warnings, $errors, $rawspecs, @specs);
}

#===================================================================================================

# Options 
# - defaults are in %defopt
# - then read command line options (including config file name) into %cmdopt
# - then read config file (if any) into %confopt
# - then merge defaults, config file, and command line options
# - then validate

#---------------------------------------------------------------------------------------------------

sub checkOptionSingle ($$) {
    # Check a single option/value for validity, returning the error and warning counts, 
    # and the possibly modified value.
    # Also returns any error/warning messages.
    # Doesn't do any cross-checking.
    my $option = shift;
    my $value  = shift;

    my $e   = 0;    # errors
    my $w   = 0;    # warnings
    my $msg = '';   # message(s)

    debug "option=$option value='$value'\n", 'cOS';
    if ($StringOpt{$option} or $MultiOpt{$option}) {    # Multi options are also strings
        # String options -- sort out any quotes
        $value = stripQuotes($value);
    } elsif ($LevelOpt{$option}) {
        # Output levels
        if (!looks_like_number($value)) {
            $msg .= "WARNING: Option '$option' should be a number from 1 to 9 -- value '$value'" .
               " treated as '1'\n";
            $value = 1;
            $w += 1;
        } else {
            $value = int($value);
            $value = 0 if $value < 0;
        }
    } elsif ($BoolOpt{$option}) {
        # Already converted to 0 or 1
    } elsif ($NumericOpt{$option}) {
        if (looks_like_number($value)) {
            $value = $value + 0;    # make it really numeric
        } else {
            $msg .= "ERROR: Invalid option: '$option' must be numeric, not '$value'\n";
            $e += 1;
        }
    }

    if ($e == 0) {
        # Do option-specific checks
        # 'Best' options
        if ($option eq 'hbest') {
            if (!($value >= 0 and $value <= 59)) {
                $msg .=  "ERROR: Invalid option: 'hbest' must be a whole number between" . 
                    " 0 and 59, not '$value'\n";
                $e += 1;
            }
        } elsif ($option eq 'dbest') {
            if (!($value >= 0 and $value < 24.0)) {
                $msg .=  "ERROR: Invalid option: 'dbest' must be a number between 0 and" . 
                    " 23.9, not '$value'\n";
                $e += 1;
            }
        } elsif ($option eq 'wbest') {
            if (!($value >= 1 and $value <= 7)) {
                $msg .=  "ERROR: Invalid option: 'wbest' must be a whole number between" . 
                    " 1 and 7 (1=Sunday, 7=Saturday), not '$value'\n";
                $e += 1;
            }
        } elsif ($option eq 'mbest') { 
            if (!($value >= 1 and $value <= 31)) {
                # (31 gives the last day of any month)
                $msg .= "ERROR: Invalid option: 'mbest' must be a whole number between" . 
                    " 1 and 31, not '$value'\n";
                $e += 1;
            }
        } elsif ($option eq 'ybest') { 
            if (!($value >= 1 and $value <= 366)) {
                # (366 gives the last day of the year, whether a leap year or not)
                $msg .= "ERROR: Invalid option: 'ybest' must be a whole number between" .
                    " 1 and 366, not '$value'\n";
                $e += 1;
            }
        } elsif ($option eq 'weekstart') {
            # Week start - an integer from 1=Sunday to 7=Saturday
            # (which is the same as $Opt{wbest} but different from localtime's $wday)
            $value = 1 if !defined $value;
            $value = int($value);
            $value = (($value-1) % 7) + 1;  # force it into range
        } elsif ($option eq 'ldcount') {
            # Link-dest count -- max 20 says rsync
            $value = int($value);
            if ($value < 0 or $value > 20) {
                $msg .= "ERROR: Invalid option: 'ldcount' must be a number from 1 to 20, " .
                    "not '$value'\n";
                $e += 1;
            } elsif ($value == 0) {
                $msg .= "WARNING: Option 'ldcount' is zero -- no hard-linking will be done,\n"
                    . "and the snapshot created may be much larger than expected\n";
                $w += 1;
            }
        } elsif ($option eq 'ldmin') {
            # link dest must be at least ldmin (proportion) of the average snapshot size
            if (!looks_like_number($value) or $value < 0 or $value > 1) {
                $msg .= "ERROR: Invalid option: 'ldmin' must be a number from 0.0 to 1.0, " .
                    "not '$value'\n";
                $e += 1;
            }
        } elsif ($option eq 'bwlimit') {
            # Band-width limit (0 = unlimited)
            # when (['bwlimit-in', 'bwlimit-out']) 
            if (!looks_like_number($value) or $value < 0) {
                $msg .= "ERROR: Invalid option: '$option' must be zero or a positive whole" . 
                    " number (in kbps), not '$value'\n";
                $e += 1;
            } else {
                $value = floor($value);
            }
        } elsif ($option eq 'timeout-retries') {
            if (!looks_like_number($value) or $value < 0) {
                $msg .= "ERROR: Invalid option: '$option' must be zero or a positive whole" . 
                    " number, not '$value'\n";
                $e += 1;
            } else {
                $value = floor($value);
            }
        } elsif ($option eq 'all-failed' or $option eq 'some-failed') {
            # Actions to take if some or all sources are not backed up
            if (index('keep', lc($value)) == 0) {   # allow abbreviations
                $value = 'keep';
            } elsif (index('delete', lc($value)) == 0) {    # ditto
                $value = 'delete';
            } else {
                $msg .= "ERROR: Invalid option: '$option' must be either 'keep' or" . 
                " 'delete', not '$value'\n";
                $e += 1;
            }
        } elsif ($option eq 'min-interval') {
            # Minimum interval between snapshots (in minutes)
            if (!looks_like_number($value) or $value < 0) {
                $msg .= "ERROR: Invalid option: 'min-interval' must be a positive number" . 
                    " of minutes, not '$value'\n";
                $e += 1;
            }
        } elsif ($option eq 'hostname') {
            # Source hostname (can be an FQDN) 
            if (!isHostOrFQDN($value)) {
                $msg .= "ERROR: hostname '$value' is not valid\n";
                $e += 1;
            }
        } elsif ($option eq 'specs') {
            # Specs -- just check syntax
            if (!($value =~ /^$specRegex(,$specRegex)*$/x)) {
                $msg .= "ERROR: Spec '$value' is not valid\n";
                $e += 1;
            }
        } elsif ($option eq 'email-if') {
            # Email condition -- failure of any or all destinations
            $value = lc($value);
            if ($value ne 'any' and $value ne 'all') {
                $msg .= "ERROR: Invalid option: '$option' must be either 'any' or" . 
                    " 'all', not '$value'\n";
                $e += 1;
            }
        } elsif ($IEFOpt{$option}) {
            # It's one of the 'IEF' options, which are stored internally 
            # in a single array to maintain their order
            $value = "--$option='$value'";
            # replace and return the name of the option:
            $option = 'ief';
        }

        # Source and destination are done later

        # Options 'include', 'include-from', 'exclude', 'exclude-from', 'filter'
        # - these are not checked at all at this stage

    }
    chomp($msg);
    #debug "returning e=$e w=$w option=$option value='$value' msg=$msg\n", 'cOS';
    return ($e, $w, $option, $value, $msg);
}

#---------------------------------------------------------------------------------------------------

sub checkOptionArray($$) {
    # Check an option or array of options (from the command line)
    my $option = shift;
    my $valref = shift;
    my $errorcount   = 0;
    my $warningcount = 0;
    my $message      = '';
    my $newopt = $option;
    if (ref($valref) eq 'ARRAY') {
        my @values;
        foreach my $value (@$valref) {
            (my $e, my $w, $newopt, my $val, my $msg) = checkOptionSingle($option, $value);
            $errorcount += $e;
            $warningcount += $w;
            push @values, $val;
            $message .= $msg;
        }
        $valref = [@values];
    } else {
        (my $e, my $w, $newopt, my $val, my $msg) = checkOptionSingle($option, $valref);
        $errorcount += $e;
        $warningcount += $w;
        $valref = $val;
        $message .= $msg;
    }
    return ($errorcount, $warningcount, $newopt, $valref, $message);
}  

#---------------------------------------------------------------------------------------------------

sub getOptionsFromArray ($$$) {
    # Process command-line-like array of options into a hash,
    # using the global list of definitions
    my $argRef     = shift;
    my $optRef     = shift;
    my $GOarrayRef = shift;
    debug "args=@$argRef\n", 'gOFA';
    my $rc = 0;
    my @GOFAerrors;
    local $SIG{__WARN__} = sub { push @GOFAerrors, @_; };
    if (!GetOptionsFromArray($argRef, $optRef, @$GOarrayRef)) {
        # Print the error messages
        foreach my $error (@GOFAerrors) {
            printError "Unexpected option error: $error";
        }
        $rc = @GOFAerrors;  # error count
    }
    return $rc;
}

#---------------------------------------------------------------------------------------------------

sub readConfig ($$) { 
    # Read in options from the given configuration filename
    # with a mixture of custom-validation and GetOptionsFromArray.
    # Returns non-zero if there were any errors,
    # and the hash of config file options.

    # Parse the config file, extracting options and values
    # The format is home-made and simple:
    # Definition:
    #   - ignore blank lines, and lines with first non-whitespace '#' (comments)
    #   - strip leading and trailing whitespace of whole line
    #   - option lines are of the form
    #       option  whitespace|:|= value
    #       option
    #       <option whitespace|:|= value>
    #           # options in new context go here
    #       </option>
    #   - option is non-whitespace i.e. a single word, with any leading - or -- stripped
    #   - value has surrounding whitespace stripped, but otherwise is anything
    #   - only 'destination' and 'source' can be used as contexts (see %ValidContext).

    state $cfile      = shift;     # ('state' to allow use in nested sub)
    state $GOarrayRef = shift;
    state $lineno = 0;
    #debug "cfile=$cfile GOarrayRef=$GOarrayRef\n", 'rC';
    
    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

    sub confLine {
        return "\nin configuration file '$cfile' at line $lineno\n";
    }

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

    sub readContext {
        # Read options at the current level/context
        my $context = shift;
        my @options;
        # Hash to receive options from GOFA:
        my %confopt;
        my $rc = 0;
        LINE: while (<CONFIG>) {  # to end of context or end of file
            superchomp($_);
            $lineno += 1;
            debug "config line $lineno is '$_'\n", 'rC';
            next if /^\s*$/;	# Skip blank lines
            next if /^\s*#/;	# Skip comments

            if (/^\s*-*(?<no>no-?)?(?<option>[[:alpha:]-]+)\s*[:=]?\s*(?<value>.+)?\s*$/) {
                # Plain option line with possible 'no' prefix
                my $option = fullName($+{option});
                my $value = $+{value} // '';
                if ($BoolOpt{$option}) {
                    if ($value) {
                        printError "Option '$option' should not have a value; " .
                            "use '--no$option' turn it off" . confLine();
                        $rc += 1;
                        next LINE;
                    }
                    $value = $+{no} ? 0 : 1;
                } else {  # not boolean, so restore the 'no' prefix
                    $option = 'no' . $option if $+{no};
                }
                (my $e, my $w, my $newopt, $value, my $msg) = checkOptionSingle($option, $value);
                #debug "cOS returns $e, $w, '$value', '$msg'\n", 'rC';
                if (!$AllOpt{$option}) {
                    printError "Unknown option '$option'" . confLine()
                        if $option ne '!*ambiguous';
                    $rc += 1;
                } elsif (!$Matrix{$context}{$option}) {
                    printError "Option '$option' not allowed within context '$context'" .confLine();
                    $rc += 1;
                } elsif ($e) {
                    printMsg $msg . confLine();
                    $rc += $e; 
                } elsif ($ValidContext{$option}) {
                    # These are treated separately so that, for example,
                    #   destination d1
                    # is treated as
                    #   <destination d1></destination>
                    if (!$value) {
                        printError "Option '$option' must have a value " . confLine();
                        $rc += 1;
                    } else {
                        push @{$confopt{$option}}, {location => $value, options => {}};
                        debug "adding simple source/dest '$value'\n", 'rC';
                    }
                } else {
                    # Simple option -- just add it to the list
                    # First, print any warnings
                    printMsg $msg . confLine() if $w;
                    if ($BoolOpt{$option}) { # newopt not needed here
                        debug "restoring no?: option=$option value=$value\n", 'rC';
                        push @options, '--' . ($value ? '' : 'no') . $option;
                    } else {
                        debug "storing option=$newopt($option) value=$value\n", 'rC';
                        push @options, "--$newopt";
                        push @options, $value;
                    }
                    debug "$option = $value, now options=@options\n", 'rC';
                }

            } elsif (/^\s*<\s*(?<option>[[:alpha:]-]+)\s*[:=]?\s*(?<value>.+)?\s*>/) {
                # Start of new context
                my $option = fullName($+{option});
                my $value = $+{value} // '';
                debug "\n>>>>>> new context=$option  \n", 'rC';
                (my $e, my $w, undef, $value, my $msg) = checkOptionSingle($option, $value);
                if (!$ValidContext{$option}) {
                    printError "Unknown context '$option' -- context skipped" . confLine();
                    $rc += 1;
                } elsif (!$AllowedContext{$context}{$option}) {
                    printError "Context '$option' not allowed within context '$context'" . 
                        " -- context skipped" . confLine();
                    $rc += 1;
                } elsif ($e) {
                    printMsg $msg . confLine();
                    $rc += $e; 
                } else {
                    #if (!$value) {
                    #    printError "Option '$option' must have a value" . 
                    #        confLine() . "\n";
                    #    $rc += 1;
                    #} else {
                    # First, print any warnings
                    printMsg $msg . confLine() if $w;
                    # OK, it's a valid context (source or destination) - recurse
                    my ($newrc, $newConfRef) = readContext($option);
                    push @{$confopt{$option}}, {location => $value, options => $newConfRef};
                    debug "adding complex destination '$value'\n", 'rC';
                    $rc += $newrc;
                    #}
                }
            } elsif (/^\s*<\/\s*(?<option>[[:alpha:]]*)[^>]*>/) {
                # End of context: ignore the name -- just match on any </...>
                if ($context eq 'general') {
                    # end of context is an error 
                    printError "Unmatched end-of-context: '$+{option}'" . confLine();
                    $rc += 1;
                } else {
                    # Finish this level of recursion
                    debug "<<<<<< end of context (option=$+{option})\n\n", 'rC';
                    last;
                }

            } else {
                printError "Invalid line: '$_'" . confLine();
                $rc += 1;
            }

        } # while

        # Call GOFA to merge @options with %confopt
        debug "gofa gets: @options\n", 'rC';
        my $gofarc = getOptionsFromArray(\@options, \%confopt, $GOarrayRef);
        debug "gofarc = $gofarc\n", 'rC';
        $rc += $gofarc;

        return ($rc, \%confopt);

    } # end of readContext()

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

    if (!open CONFIG, '<', $cfile) {
        # Shouldn't happen as we've already tested for readability 
        printError "Failed to open configuration file '$cfile'\n";
        return (1, {});
    }
    my ($rc, $confoptRef) = readContext('general');
    close CONFIG;

    debug "confopt:\n", 'rC';
    debug Dumper($confoptRef), 'rC';
    return ($rc, %$confoptRef);
}

#---------------------------------------------------------------------------------------------------

sub mergeOpts (@) {
    # Merge option hashes together
    my %Opt = %{(shift)};
    foreach my $nextoptref (@_) {
        foreach my $k (keys %$nextoptref) {
            $Opt{$k} = $nextoptref->{$k};
        }
    }
    return %Opt;
}

#---------------------------------------------------------------------------------------------------

sub checkInExcludeFrom ($) {
    # Check that exclude-from, include-from, and filter files are readable.
    # These options are now stored in the single ief option as an array.
    my $optR = shift;   # reference to an options hash (depending on context)
    #debug "optR: " . Dumper($optR), 'cIEF';
    if (defined $optR->{ief}) {
        my @tempief;
        foreach my $entry (@{$optR->{ief}}) {  # $entry is e.g. "--include-from='inc.txt'"
            # (the single quotes will always be there having been added by checkOptionSimple)
            debug "entry: $entry\n", 'cIEF';
            if ($entry =~ /(?<opt>include-from|exclude-from|filter)='(?<filename>.*)'$/) {
                my $opt = $+{opt};
                my $rule = '';
                my $filename = $+{filename};
                if ($opt eq 'filter') {
                    # strip off the filter rule before the whitespace
                    ($rule, $filename) = ($filename =~ /^(\S+\s+)(.*)$/)
                }
                my $file1 = absPath($filename);
                my $file2 = rsyncMakeLocal($file1);
                debug "file2 = $file2\n", 'cIEF';
                if ($file2 eq '' or !-r $file2) {
                    printWarning 
                        "$opt file '$filename' is not readable -- it will be ignored\n", 1;
                } else {
                    push @tempief, "--$opt='$rule$file2'";
                    if ($file1 ne $file2) {
                        printNote "Remote $opt file '$filename'\n" .
                            "has been copied to temporary local file '$file2'\n";
                    }
                }
            } else {
                # just keep the non-file option unchanged
                push @tempief, $entry;
            }
            # copy the temporary array back to the real one
            $optR->{ief} = \@tempief;
        }
    }
}

# FIXME this is obsolete
sub checkInExcludeFrom0 ($) {
    # Check that exclude-from, include-from, and filter files are readable.
    # These options are now stored in the single ief option as an array.
    my $optR = shift;   # reference to an options hash (depending on context)
    #debug "optR: " . Dumper($optR), 'cIEF';
    foreach my $opt ('exclude-from', 'include-from', 'filter') {
        if (defined $optR->{$opt}) {
            debug "$opt array: " . Dumper(@{$optR->{$opt}}), 'cIEF';
            my @tempOpt;
            foreach my $file (@{$optR->{$opt}}) {
                my $file2 = rsyncMakeLocal(absPath($file));
                if ($file2 eq '' or !-r $file2) {
                    printWarning "$opt file '$file' is not readable -- it will be ignored\n", 1;
                } else {
                    push @tempOpt, $file2;
                    if ($file ne $file2) {
                        printNote "Remote $opt file '$file'\n" .
                            "has been copied to temporary local file '$file2'\n";
                    }
                }
            }
            # copy the temporary array back to the real one
            $optR->{$opt} = \@tempOpt;
        }
    }
}

#---------------------------------------------------------------------------------------------------

sub checkHardLinksAvailable () {
    # Check that each destination's file system supports hard links, and warn otherwise.
    # So far, this is only done for Windows (i.e. cygwin), and just distinguishes NTFS
    # from everything else.
    # The mount table looks something like this (an array of arrays)
    #   /usr/bin C:/cygwin/bin ntfs binary,auto
    #   /usr/lib C:/cygwin/lib ntfs binary,auto
    #   / C:/cygwin ntfs binary,auto
    #   /cygdrive/c C: ntfs binary,posix=0,user,noumount,auto
    #   /cygdrive/f F: vfat binary,posix=0,user,noumount,auto
    # We'll match the beginning of each destination against entries in that table.
    my $warnings = 0;
    if ($Cygwin) {
        # Get the list of mounted file systems
        my @mounts = Cygwin::mount_table();
        # Match each destination's location
        foreach my $dest (@{$Opt{destination}}) {
            my $location = $dest->{location};
            if ($location =~ m|^(/cygdrive/[A-Za-z])/|) {
                my $drive = $1;
                debug "checking location $location  drive=$drive\n", 'cHLA';
                foreach my $mnt (@mounts) {
                    debug "against @$mnt\n", 'cHLA';
                    debug " [0]=$$mnt[0]  [2]=$$mnt[2]\n", 'cHLA';
                    if ($$mnt[0] eq $drive) {
                        if ($$mnt[2] ne 'ntfs') {
                            printWarning "Destination '$location' does not support hard links.\n" .
                                "Its file system type is '$$mnt[2].'\n" .
                                "Snapshot sizes will be larger than normal.\n", 1;
                            $warnings += 1;
                        }
                        last;
                    }
                }
            } else {
                # no drive letter found: it's probably remote, so can't check for hard links.
            }
        }
    }
    return $warnings;
}

#---------------------------------------------------------------------------------------------------

sub processOptions () {

    # Default options hard-coded here
    # -------------------------------
    my %defopt = ();    # default options
    # output: for each of these, 0 means no output, 1 gives errors only, 2 adds warning,
    # 3 adds notes... (higher values for debugging only)
    $defopt{verbose}        = 3;
    $defopt{loglevel}       = 3;
    #
    $defopt{debug}          = '';
    $defopt{test}           = 0;          # a non-zero value indicates which test to run
    # xbest options to prefer one part of a period, e.g. 5pm, Fridays
    # defaults are at the end of the period (calendar mode only!)
    $defopt{hbest}          = 59;         # preferred minute within an hour 0-59, integer
    $defopt{dbest}          = 23.99;      # preferred hour within a day 0-23.99, float
    $defopt{wbest}          = 7;          # preferred day within a week 1-7, integer, 1=Sun 7=Sat
    $defopt{mbest}          = 31;         # preferred day within a month 1-31  
    $defopt{ybest}          = 366;        # preferred day in the year 1-366
    # 
    $defopt{'all-failed'}   = 'delete';
    $defopt{'allow-restart'} = 1;   
    $defopt{bwlimit}        = 0;
    $defopt{calendar}       = 1;
    $defopt{compress}       = 1;
    $defopt{delete}         = 1;
    $defopt{'delete-cp'}    = 1;
    $defopt{'dry-run'}      = 0;
    $defopt{'expire-old'}   = 0;          # expire oldest S's to make room, even when not unlimited
    $defopt{help}           = 0;
    $defopt{ief}            = [];
    $defopt{latest}         = 0;
    $defopt{'latest-copy'}  = 0;
    $defopt{ldcount}        = 1;          # no. of link-dest options to create
    $defopt{ldmin}          = 0.0;        # proportion of average snapshot size that counts for link dest
    $defopt{'min-interval'} = 0;          # minutes between snapshots
    $defopt{restart}        = 0;
    $defopt{'rsync-cmd'}    = 'rsync';    # Should it be '/usr/bin/rsync'?
    $defopt{'rsync-opts'}  = '--hard-links --numeric-ids --archive --one-file-system --timeout=300';
    $defopt{'rsync-xopts'}  = '';
    $defopt{safe}           = 1;        
    $defopt{snapshot}       = 1;
    $defopt{'some-failed'}  = 'keep';
    $defopt{status}         = 0;
    $defopt{strict}         = 0;
    $defopt{'timeout-retries'} = 0;
    $defopt{version}        = 0;
    $defopt{weekstart}      = 1;          # 1=Sunday
    $defopt{'email-to'}     = '';
    $defopt{'email-from'}   = (getpwuid($<))[0];
    $defopt{'email-prog'}   = '/usr/sbin/sendmail -t -oi';
    $defopt{'email-if'}     = 'any';
    $defopt{'email-test'}   = 0;
    # The following deliberately do not have defaults:
    #   template   source  logfile   config  destination  specs
    #   include include-from exclude exclude-from filter 
    #   remote-rsync-cmd  hostname

    my %confopt = ();   # config file options
    my %cmdopt = ();    # command line options

    my @GOarray = (     # array to pass to GetOptions and GetOptionsFromArray
            'all-failed=s',
            'allow-restart!',
            'bwlimit=f',
            'calendar!',
            'compress!',
            'config=s',
            'dbest=f',
            'debug=s',      
            'delete!',
            'delete-cp!',
            'destination=s@',
            'dry-run|dryrun!',
            'email-from=s',
            'email-if=s',
            'email-prog=s',
            'email-test!',
            'email-to:s@',
            'exclude-from=s@',
            'exclude=s@',
            'expire-old!',
            'filter=s@',
            'hbest=i',
            'help!',
            'hostname=s',
            'ief=s@',
            'include-from=s@',
            'include=s@',
            'latest!',
            'latest-copy!',
            'ldcount=i',
            'ldmin=f',
            'lockfile=s',
            'logfile=s',
            'loglevel=i',
            'mbest=i',
            'min-interval=f',
            'restart!',
            'rsync-cmd=s',
            'rsync-opts=s',
            'rsync-xopts=s',
            'remote-rsync-cmd=s',
            'safe!',
            'snapshot!',
            'some-failed=s',
            'source=s@',
            'specs=s',
            'status!',
            'strict!',
            'template=s',
            'test=i',
            'timeout-retries=i',
            'verbose=s',
            'version',
            'wbest=i',
            'weekstart=i',
            'ybest=i',
    );

    my $errorcount = 0;
    my $warningcount = 0;

    # Block to limit the scope of the SIGWARN override which traps warnings from GetOptions
    {
        # Get command line options -- give up if any errors.
        my @GOerrors;
        local $SIG{__WARN__} = sub { push @GOerrors, @_; };
        my $GOok = GetOptions(\%cmdopt, @GOarray);
        if (!$GOok) {
            foreach my $error (@GOerrors) {
                printError "On command line: " . $error;
            }
            $errorcount += @GOerrors;
        }
        if (@ARGV) {
            printError "Unexpected word(s) on the command line: " .
                join(', ', map {"'$_'"} @ARGV) . "\n";
            $errorcount += @ARGV;
        }
#        return ($errorcount, $warningcount) if $errorcount;
    }

    # Validate command-line options 
    foreach my $option (sort keys %cmdopt) {
        my ($e, $w, $newopt, $value, $msg) = checkOptionArray($option, $cmdopt{$option});
        debug "cOA for $option returns $e, $w, '$newopt', '$value', '$msg'\n", 'pO';
        $errorcount += $e;
        $warningcount += $w;
        if ($msg) {
            printMsg "$msg (on command line)\n";
        }
        $cmdopt{$option} = $value;
        if ($newopt ne $option) {
            # currently only for ief which is an array option
            # -- add the values to the 'new option' array
            push @{$cmdopt{$newopt}}, @$value;
            delete $cmdopt{$option};
            debug "newopt $newopt is now " . Dumper($cmdopt{$newopt}) . "\n", 'pO';
        }
#        # TEMP
#        if ($option eq 'email-to' and !$value) {
#            print "email-to is blank -- delete it";
#            ... no, we need to delete it from $Opt, not cmdopt
    }

    # Tweak context options from command line to make them into config-file structures
    foreach my $context (keys %ValidContext) {
        if ($cmdopt{$context}) {
            my @temp;
            foreach my $c (@{$cmdopt{$context}}) {
                push @temp, {location => $c, options => {}};
            }
            $cmdopt{$context} = \@temp;
        }
    }

    # If config file specified, check it and read it
    if ($cmdopt{config}) {
        $cmdopt{config} = absPath($cmdopt{config});
        if (-f $cmdopt{config} && -r _) {
            (my $rc, %confopt) = readConfig($cmdopt{config}, \@GOarray);    
            return (1,0) if $rc;
        } else {
            printError "Configuration file '$cmdopt{config}' cannot be read\n";
            return (1,0);
        }
    }

    debug "def  options: " . join(' ', 
        map {$_ . '=' . $defopt{$_}}  sort keys %defopt)  . "\n", 'pO';
    debug "conf options: " . join(' ', 
        map {$_ . '=' . $confopt{$_}} sort keys %confopt) . "\n", 'pO';
    debug "cmd  options: " . join(' ', 
        map {$_ . '=' . $cmdopt{$_}}  sort keys %cmdopt)  . "\n", 'pO';
    
    # Merge options, so that config file options override the defaults,
    # and command-line options override everything else
    %Opt = mergeOpts(\%defopt, \%confopt, \%cmdopt);

    # Split comma-separated debug values into a hash
    $Opt{debug} = {map {lc($_) => 1} split(/,/, $Opt{debug})};
    
    debug "Partially validated final options: " . join(' ', 
        map {$_ . '=' . $Opt{$_}} sort keys %Opt) . "\n", 'pO';
    
    # If user asked for help or version, or is running test mode,
    # don't do any more validation
    if ($Opt{help} or $Opt{version} or $Opt{test}) {
        return (0,0);
    }

    # Check for missing options at general level
    foreach my $ropt (@ReqOpt) {
        unless ($Opt{$ropt}) {
            printError "Required option '$ropt' is missing\n";
            $errorcount += 1;
        }
    }

    # Logging (check this next, so that we can log later errors).
    # Note that, once validated, the 'logfile' option is copied to
    # $Opt{validLogfile}, which is what is used by logit().
    # The logfile must be local.
    if (!$Opt{logfile}) {
        # No logfile, so no logging
        $Opt{loglevel} = 0;
    } else {
        $Opt{logfile} = absPath($Opt{logfile});
        # Open and lock the logfile
        if (open LOGFILE, ">>$EOL", $Opt{logfile}) {
            if (flock(LOGFILE, LOCK_EX | LOCK_NB)) {
                $Opt{validLogfile} = $Opt{logfile};
                # Make the logfile unbuffered
                my $oldfh = select LOGFILE;
                $| = 1;
                select $oldfh;
            } else {
                printit "\nCannot lock logfile '$Opt{logfile}'.\n" .
                    "$Script is probably already running with that logfile.\n\n", 1;
                close LOGFILE;
                exit EXITNOLOCK;
            } 
        } else {
            printError "Logfile '$Opt{logfile}' (option 'logfile') cannot be written\n";
            $Opt{loglevel} = 0;
            $errorcount += 1;
        }
    }

    logit "\nCommand line: $0 @ARGVcopy\n", 3;

    # lockfile option is obsolete
    if ($Opt{lockfile}) {
        printWarning "Option 'lockfile' is no longer used, and will be ignored.\n" .
            "It will become invalid in the future: please remove it.\n";
        delete $Opt{lockfile};
    }

    # Check for required options per destination
    foreach my $dest (@{$Opt{destination}}) {
        foreach my $ropt (@DestReqOpt) {
            #debug "checking $ropt for dest $dest->{location}\n", 'pO';
            unless ($Opt{$ropt} or ${$dest->{options}}{$ropt}) {
                printError "Required option '$ropt' is missing " .
                    "for destination '$dest->{location}'\n";
                $errorcount += 1;
            }
        }
    }
    
    # Email options
    if ($Opt{'email-to'}) {
        # Set up emailing -- some options have defaults.
        # Note that we don't attempt to validate any of the email settings --
        # that's what the email-test option is for.
    } elsif ($Opt{'email-test'}) {
        printError "Option 'email-to' (and possibly other 'email-xxx' options) " .
            "must be given when using 'email-test'\n";
        $errorcount += 1;
    }

    # Parse general-level specs
    if ($Opt{specs}) {
        my ($w, $e, $rawspecs, @pspecs) = processSpecs($Opt{specs});
        $errorcount += $e;
        $warningcount += $w;
        #plpo "$msg\n" if $msg;
        $Opt{pspecs} = \@pspecs if !$e;
        $Opt{specs} = $rawspecs if !$e;
    }
    # Check general-level include-from, exclude-from, and filter options
    checkInExcludeFrom(\%Opt);

    # Sources, with extra options for each (there may be no sources at general level)
    if ($Opt{source}) {
        foreach my $src (@{$Opt{source}}) {
            $src->{location} = absPath($src->{location});
            my ($rrrc, $rrrc2) = rsyncExists($src->{location});
            if ($rrrc == 0) {
                $src->{readable} = 1;
            } else {
                printWarning "Source '$src->{location} cannot be read" .
                    ($rrrc2 eq '' ? '' : " ($ErrorCodes{$rrrc2})") .
                    "\n";
                $warningcount += 1;
                $src->{readable} = 0;
            }
            # Check source-level include-from, exclude-from, and filter options
            checkInExcludeFrom($src->{options});
            #
            return ++$errorcount, $warningcount if $Interrupted;
        }
    }

    # Destination directories (with extra options for each)
    # and create summary structure
    my $destError = 0;
    my $writableDests = 0;
    foreach my $dest (@{$Opt{destination}}) { 
        $dest->{location} = absPath($dest->{location});
        $Summary{$dest->{location}}{result} = 'not attempted';
        my $destInfo = $Summary{$dest->{location}};
        my $options = $dest->{options};
        if ($options->{source}) {
            # This destination has its own source(s) which
            # will override any at the general level
            foreach my $src (@{$options->{source}}) {
                $src->{location} = absPath($src->{location});
                $destInfo->{source}{$src->{location}}{result} = 'not attempted';
                my ($rrrc, $rrrc2) = rsyncExists($src->{location});
                if ($rrrc != 0) {
                    printWarning "Source '$src->{location}' cannot be read" .
                        ($rrrc2 eq '' ? '' : " ($ErrorCodes{$rrrc2})") .
                        "\n";
                    $warningcount += 1;
                    $destInfo->{source}{$src->{location}}{result} = 'not readable';
                    $AnyDestFailed = 1;
                }
                # Check source-level include-from, exclude-from, and filter options
                checkInExcludeFrom($src->{options});
                return ++$errorcount, $warningcount if $Interrupted;
            }
        } else {
            # This destination has no sources of its own -- use the general-level ones
            foreach my $src (@{$Opt{source}}) {
                if ($src->{readable}) {
                    $destInfo->{source}{$src->{location}}{result} = 'not attempted';
                } else {
                    $destInfo->{source}{$src->{location}}{result} = 'not readable';
                    $AnyDestFailed = 1;
                }
            }
        }
        # Check that destination is writable
        my ($rwrc, $rwrc2) = rsyncWritable($dest->{location});
        if ($rwrc == 0) {
            $writableDests += 1;
            # It's a good destination, so parse any destination-specific specs
            if ($options->{specs}) {
                my ($w, $e, $rawspecs, @pspecs) = processSpecs($options->{specs});
                $errorcount += $e;
                $destError = 1 if $e;
                $warningcount += $w;
                #plpo "$msg\n" if $msg;
                $options->{pspecs} = \@pspecs if !$e;
                $options->{specs} = $rawspecs if !$e;
            }
            # Check destination-level include-from, exclude-from, and filter options
            checkInExcludeFrom($options);
        } else {
            printWarning "Destination '$dest->{location}' is not available\n" .
                    "as a writable directory" .
                    ($rwrc2 eq '' ? '' : " ($ErrorCodes{$rwrc2})") .
                    "\n";
            $warningcount += 1;
            $Summary{$dest->{location}}{result} = 'not available';
            $AnyDestFailed = 1;
        }
        return ++$errorcount, $warningcount if $Interrupted;
    }
    if ($writableDests == 0) {
        printError "None of the destinations specified is available\n";
        $errorcount += 1;
        $destError = 1;
    }

    if (!$destError) {
        # Cross-check sources and destinations -- they can't all be remote
        # 1. for each destination
        #       if local sources, check them
        #       else check top-level sources
        #          i.e. override top-level temporarily if any
        my $somethingToDo = 0;
        #debug "opt-dest = " . Dumper($Opt{destination}), 'pO';
        foreach my $dest (@{$Opt{destination}}) {
            #debug "checking $dest->{location}\n", 'pO';
            my $remoteDest = remote($dest->{location});
            my $source;
            #debug "dest sources = " . Dumper($dest), 'pO';
            if (exists $dest->{options}->{source}) {
                $source = $dest->{options}->{source};
                #debug "dest sources = " . Dumper($source), 'pO';
            } else {
                $source = $Opt{source};
                #debug "global sources = " . Dumper($source), 'pO';
            }
            foreach my $src (@{$source}) {
                #debug "x-checking $dest->{location} -- $src->{location}", 'pO';
                my $remoteSrc = remote($src->{location});
                if (!remote($src->{location}) or !$remoteDest) {
                    $somethingToDo = 1;
                    #debug " -- OK\n", 'pO';
                } else {
                    #debug " -- Not\n", 'pO';
                }
            }
        }
        if (!$somethingToDo) {
            printError "All destination/source combinations are remote<->remote -- " . 
                "cannot continue\n";
            $errorcount += 1;
        }
    }
    
    if ($errorcount == 0) {
        $warningcount += checkHardLinksAvailable();
    }
    
    # --restart implies --snapshot and --min-interval=0
    $Opt{snapshot} = 1 if $Opt{restart};
    $Opt{'min-interval'} = 0 if $Opt{restart};

    # $Opt{specs} is checked later

    return $errorcount, $warningcount;
}

#---------------------------------------------------------------------------------------------------

sub printableOption ($$;$) {
    # Return a printable version of an option and its value,
    # with the option aligned right in the given width.
    # (arrays are dealt with by the caller)
    my $opt   = shift;
    my $val   = shift;
    my $width = shift // 0;
    debug "opt=$opt  val=$val  width=$width\n", 'prO';
    my $val2 = '';
    # special case: ief
    if ($opt eq 'ief') {
        # 'value' is e.g. "--exclude-from='exc.file'"
        if ($val =~ /--(.*)=(.*)/) {
            return sprintf("%*s: %s", $width, $1, $2);
        }
    }
    # other options
    if (ref($val) eq 'HASH') {
        # hash option -- just 'debug' so far
        if (keys %$val) {
            $val2 = join(',', map {"$_"} sort keys %$val); 
        } else {
            $val2 = '(none)';
        }
    } elsif ($BoolOpt{$opt}) {
        # boolean options
        $val2 = $val ? 'yes' : 'no';
        $opt = ($val ? '' : 'no') . $opt;
        undef $val2;
    } elsif ($StringOpt{$opt} or $MultiOpt{$opt}) {
        # string option, add quotes
        $val2 = "'$val'";
    } else {
        # else it's numeric, no quotes
        $val2 = $val;
    }
    if (defined $val2) {
        return sprintf("%*s: %s", $width, $opt, $val2);
    } else {
        return sprintf("%*s", $width, $opt);
    }
}

#---------------------------------------------------------------------------------------------------

sub displayContext ($$$);   # pre-declaration required for recursion
sub displayContext ($$$) {
    # Display the sub-options for a single context
    my $context = shift;    # the name of the context option
    my $contRef = shift;    # the context's sub-options
    my $indent  = shift;    # for pretty-printing
    my $text = '';
    foreach my $cref (@{$contRef->{$context}}) {
        if (keys %{$cref->{options}}) {
            $text .= sprintf("%*s: '%s'>\n", $indent+16, "<$context", $cref->{location});
            my $copts = $cref->{options};
            my $text2 = '';    # put the sub-contexts last
            foreach my $subopt (sort keys %$copts) {
                next if $subopt eq 'pspecs';       # for internal use only
                if ($AllowedContext{$context}{$subopt}) {
                    $text2 .= displayContext($subopt, $copts, $indent+13);
                } else {
                    if (ref($copts->{$subopt}) eq 'ARRAY') {
                        foreach my $val (@{$copts->{$subopt}}) {
                            $text .= printableOption($subopt, $val, $indent+16+13) . "\n";
                        }
                    } else {
                        $text .= printableOption($subopt, $copts->{$subopt}, $indent+16+13) . "\n";
                    }
                }
            }
            $text .= $text2;
            $text .= sprintf("%*s\n", $indent+16+2, "</$context>");
        } else {
            # No sub-options, just display as a simple option
            $text .= sprintf("%*s: '%s'\n", $indent+16, "$context", $cref->{location});
        }
    }
    return $text;
}
 
#---------------------------------------------------------------------------------------------------

sub formatOptions () {
    # Return the options nicely formatted
    my $text = '';
    $text .= "\nConfiguration file: '" . hostname . ":$Opt{config}'\n" if $Opt{config};
    $text .= "\nOptions Summary:\n";
    foreach my $opt (sort keys %Opt) {
        next if $opt eq 'validLogfile'; # for internal use only
        next if $opt eq 'pspecs';       # for internal use only
        next if ($opt =~ /^email-/ and !$Opt{'email-to'});  # skip email options if no email-to
        if ($ValidContext{$opt}) {
            $text .= displayContext($opt, \%Opt, 0);
        } else {
            if (ref($Opt{$opt}) eq 'ARRAY') {
                foreach my $val (@{$Opt{$opt}}) {
                    $text .= printableOption($opt, $val, 16) . "\n";
                }
            } else {
                $text .= printableOption($opt, $Opt{$opt}, 16) . "\n";
            }
        }   
    }
    return "$text\n";
}
 
#---------------------------------------------------------------------------------------------------

sub displayOptions () {
    printlog formatOptions(), 1,1;
}

#===================================================================================================

# Help

sub showLicence () {
    printit <<EOT;
$Script version $VERSION

rsync-based backup snapshot creation and management        
Copyright (C) 2011-2013 Chris Dennis, chris\@starsoftanalysis.co.uk        
                                                                       
This program is free software: you can redistribute it and/or modify  
it under the terms of the GNU General Public License as published by  
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.                              
                                                                  
This program is distributed in the hope that it will be useful,     
but WITHOUT ANY WARRANTY; without even the implied warranty of     
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        
GNU General Public License for more details.                          
                                                                      
You should have received a copy of the GNU General Public License     
along with this program.  If not, see <http://www.gnu.org/licenses/>. 

EOT
}

#---------------------------------------------------------------------------------------------------

sub showHelp () {
    printit <<EOT;

Usage: $Script [option]...

Options can be specified on the command line or in the configuration file.
Main options
--config       file          configuration file name 
--source       file/dir !*d  local or remote file or directory to add to snapshot
--destination  dir      !*   local or remote snapshot destination
--template     name     ! d  prefix for snapshot directories 
--specs        ...      !    snapshot-keeping specification 
--logfile      file          file used for logging 
Tuning options
--[no]calendar            d  use calendar mode (default: calendar)
--[no]safe                d  use safe mode (default: safe)
  Note: --<x>best options only apply to calendar mode.
--hbest        0..59      ds favoured minute within hour (default: 59) 
--dbest        0..23.9    ds favoured hour within day in hours (default: 23.9) 
--mbest        1..31      ds favoured day within month (default: 31) 
--wbest        1..7       ds favoured day within week, 1=Sunday (default: 1) 
--ybest        1.366      ds favoured day within year (default: 366) 
--min-interval 0..        d  minimum number of minutes between snapshots (default: 0) 
--weekstart    1..7       d  first day of week, 1=Sunday (default: 1) 
Helpful options
--help                       display this help message and stop
--version                    display version number only stop
--verbose      0..9       ds amount of output displayed (default: 3) 
--loglevel     0..9       ds amount of logging information (default: 3) 
--[no]dry-run                make no actual changes (default: nodry-run) 
Rsync options (see rsync documentation)
--rsync-cmd    file       ds location of the rsync programme (default: rsync) 
--[no]compress            ds enable rsync compression for remote transfers 
                              (default: compress) 
--include      pattern   *ds rsync inclusion
--include-from filename  *ds rsync inclusions (can be remote) 
--exclude      pattern   *ds rsync exclusion
--exclude-from filename  *ds rsync exclusions (can be remote)
--filter 'rule filename' *ds rsync filter (can be remote)
--bwlimit      n          ds bandwidth limit in kbps (default: 0) 
                              (set to 0 for no limit) 
--rsync-opts   options    ds standard options to pass to rsync 
                              (default: -aHx --numeric-ids) 
--rsync-xopts  options    ds extra options for rsync (in addition to --rsync-opts)
                              (default: none)
--remote-rsync-cmd file   ds location of the rsync programme on the remote
                               computer (optional, no default) 
--timeout-retries n       ds number of times to retry rsync after a time-out error (default: 0)
Email options.  --email-to is required for any emails to be sent
--email-to     address   *   email recipient for error messages (no default)
--email-from   address       email address for From: header of email (default: current user)
--email-prog   progname      email sending program and options 
                              (default: /usr/sbin/sendmail -t -oi)
--email-if     all|any       send email if all or any destinations failed (default: all)
--[no]email-test             send a message to test the other email settings (default: no)
Advanced options
--all-failed  keep|delete d  (default: delete) 
--some-failed keep|delete d  (default: keep) 
                             what to do with the snapshot if all or some of the 
                              sources are not copied successfully
                              (values can be abbreviated)
--[no]allow-restart       ds keep the unfinished snapshot if brandysnap was
                              interrupted (e.g. by ctrl-C or system shutdown)
                              (default: allow-restart)
--[no]delete              d  delete no-longer-required snapshots (default: delete) 
--[no]delete-cp           d  delete even in current period (default: delete-cp)
--[no]expire-old          d  delete oldest snapshots when disk is full (default: noexpire-old)
--hostname     host/FQDN  ds hostname or FQDN of source to use in snapshot path 
                              (default: source computer)
--[no]latest              d  create a <template>-latest snapshot (default: nolatest)
--[no]latest-copy         d  latest snapshot is a full copy (not linked) (default: nolatest-copy)
--ldcount      n          d  number of --link-dest options to create (default: 1, max: 20) 
                              ignoring unfinished and too-small (see --ldmin) snapshots
--ldmin        0.0..1.0   d  minimum proportion of the average snapshot size that qualifies
                              a snapshot as a --link-dest destination (default: 0.0)
--[no]restart             ds continue snapshot(s) from previous run (default: norestart)
                              (implies --snapshot) 
--[no]snapshot            d  create new snapshots (default: snapshot)
--status                     print a status report only
--[no]strict              d  use strict mode (default: nostrict)
Development options
--debug    code[,code...] ds sections in which to enable debugging (default: none) 
--test         n             run test case 'n' 
Options marked with '!' are required -- others have sensible default values.
Options marked with '*' can be specified more than once.
Options marked with 'd' can be specified within a <destination> section.
Options marked with 's' can be specified within a <source> section.

Please see the $Script documentation for full details, including the use of
'contexts' in the configuration file to allow, for example, an exclude
option to apply to one particular source.

EOT
    showLicence();
}
#===================================================================================================

# Snapshot stuff 

#---------------------------------------------------------------------------------------------------

sub longestName () {
    # Return the length of the longest snapshot name (including any notes)
    my $l = 0;
    foreach my $s (keys %S) {
        $l = max($l, length($S{$s}{name}));
    }
    return $l;
}

#---------------------------------------------------------------------------------------------------

sub averageSnapshotBytes () {
    # Get average size of previous snapshots
    my ($count, $totsize) = (0,0);
    foreach my $s (sort keys %S) {
        if (defined $S{$s}{totbytes} and 
            $S{$s}{totbytes} > 0     and   # only count non-empty ones
            !$S{$s}{unfinished}          ) # and only finished ones
        {
            $count += 1;
            $totsize += $S{$s}{totbytes};
        }
    }
    my $sAvBytes = 0;
    $sAvBytes = round($totsize / $count) if $count > 0;
    return $sAvBytes;
}

#---------------------------------------------------------------------------------------------------

sub status ($\@) {
    # Print a status report on existing snapshots for a single destination
    my $dest   = shift;
    my @cSpecs = @{(shift)};

    my $fcount = 0; # finished snapshots
    my $ucount = 0; # unfinished snapshots
    my $ci = 0;     # index into @cSpecs
    my $pi = -1;    # index into $Opt{pspecs}
    debug "pspecs: " . Dumper($Opt{pspecs}), 'status';

    my $plevel = 1; # only output at this level or above
    my $llevel = 1;
    if ($Opt{status}) {
        # User has asked for status, so make sure it's printed and not logged
        $plevel = 1;
        $llevel = 9;
    }

    printlog under1("\nStatus report for $dest\n"), $plevel,$llevel;
    if (!%S) {
        printlog "No snapshots found\n", $plevel,$llevel;
    } else {
        # Report layout: (plus the 'Period' column at level 3)
        #                                    ------ Size ------   ----- Files ------
        # Snapshots (most recent first)         Total       New      Total       New   Spec
        # --------------------------------   ------------------   ------------------   -----------
        # template-20121024-123456-note      1.23 MiB  1023 MiB    9999999      9999   98-99h23:21
        # --------------------------------   ------------------   ------------------
        #   Total:  (+999 unfinished) 9999   28.0 MiB  28.0 GiB   12345678  12345678   
        # Average:                            123 MiB       0 B     234234    234234 
        # <-------- $nameLength --------->
        my $nameLength = max(longestName()+4, 32); # +4 to allow for ' (u)'
        printlog sprintf("%-*s   ------ Size ------   ----- Files ------\n", $nameLength, ''), 
            $plevel,$llevel;
        printlog sprintf("%-*s   %8s  %8s   %8s  %8s   %-11s", $nameLength, 
            'Snapshots (most recent first)', 'Total', 'New', 'Total', 'New', 'Spec'), 
            $plevel,$llevel;
        printlog '   Period', max($plevel,3),max($llevel,3);
        printlog sprintf("\n%-*s   %8s--%8s   %8s--%8s   %-11s", 
            $nameLength, '-'x$nameLength, '-'x8, '-'x8, '-'x8, '-'x8, '-'x11), 
            $plevel,$llevel;
        printlog '   '.'-'x33, max($plevel,3),max($llevel,3);
        printlog "\n", $plevel,$llevel;
        # Totals and counts for each column
        my (%total, %count, %value, %avrag);
        my @cols = qw(totbytes tfrbytes totfiles tfrfiles);
        foreach my $col (@cols) {
            #$total{$col} = '';    # will stay undefined if nothing is added
            $count{$col} = 0;
            $avrag{$col} = '';
        }
        foreach my $s (rsort keys %S) {
            # Print period details if we've got to a new spec
            #debug "pi=$pi", 'status';
            while ($pi < 0 or 
                   ($pi <= $#{$Opt{pspecs}} and ${$Opt{pspecs}}[$pi]->{beg} > $s)) {
                $pi += 1;
                if ($pi > $#{$Opt{pspecs}}) {
                    # no more parsed specs -- we're dealing 'old' snapshots
                    printlog "Snapshots no longer covered by specs\n", 1; 
                } else {
                    printlog "Period covered by spec ${$Opt{pspecs}}[$pi]->{rawspec} is " .
                        fmtRange(${$Opt{pspecs}}[$pi]->{beg}, ${$Opt{pspecs}}[$pi]->{end}) . 
                        "\n", 1;
                }
            }
            my $name = $S{$s}{name};
            my $label = '';
            my $period = '';
            if ($S{$s}{unfinished}) {
                $name .= ' (u)';
                $ucount += 1;
            } else {
                $fcount += 1;
            }
            # Find which cSpec applies (finished snapshots only)
            if (@cSpecs and !$S{$s}{unfinished}) {
                while ($cSpecs[$ci]->{beg} > $s and $ci < $#cSpecs) {
                    # (The second test is necessary for case where oldest spec is unfinished 
                    # and therefore not counted as part of a period.)
                    $ci += 1; 
                };
                if ($ci <= $#cSpecs) { 
                    $label = $cSpecs[$ci]->{label};
                    # 'old' snapshots (only kept if there's a note) belong
                    # to neither spec nor period
                    $label = '' if $label eq 'old';
                    $period = fmtRange($cSpecs[$ci]->{beg}, $cSpecs[$ci]->{fullend}) if $label;
                    # snapshots in incomplete periods belong to a period but not to a spec
                    $label = '' if $label =~ /incomplete/;
                }
            }
            # Get values for each column and add to totals
            foreach my $col (@cols) {
                $value{$col} = '';
                if (defined $S{$s}{$col} and $S{$s}{$col} >= 0) {
                    $value{$col}  = $S{$s}{$col};
                    $total{$col} += $S{$s}{$col};
                    $count{$col} += 1;
                }
            }
            printlog sprintf("%-*s   %8s  %8s   %8s  %8s   %-11s", $nameLength, $name, 
                bytes($value{totbytes}), bytes($value{tfrbytes}),
                $value{totfiles}, $value{tfrfiles}, $label),
                $plevel, $llevel;
            printlog "   $period", max($plevel,3),max($llevel,3);
            printlog "\n", $plevel,$llevel;
        }
        # --------------------------------   ------------------   ------------------
        #   Total:  (+999 unfinished) 9999   28.0 MiB  28.0 GiB   12345678  12345678   
        # Average:                            123 MiB       0 B     234234    234234 
        printlog sprintf("%-*s   %8s--%8s   %8s--%8s\n", $nameLength, '-'x$nameLength, 
            '-'x8, '-'x8, '-'x8, '-'x8), 
            $plevel,$llevel;
        my $unfinished = '';
        $unfinished = "(+$ucount unfinished)" if $ucount;
        printlog sprintf("%8s %s %17s %4d   %8s  %8s   %8s  %8s\n", 
            'Total:', ' 'x($nameLength-32), $unfinished, $fcount, 
            bytes($total{totbytes}), bytes($total{tfrbytes}), 
            $total{totfiles}, $total{tfrfiles}), 
            $plevel,$llevel;
        foreach my $col (@cols) {
            $avrag{$col} = round($total{$col} / $count{$col}) if $count{$col} > 0;
        }
        printlog sprintf("%-*s   %8s  %8s   %8s  %8s\n", $nameLength, 'Average:', 
            bytes($avrag{totbytes}), bytes($avrag{tfrbytes}), 
            $avrag{totfiles}, $avrag{tfrfiles}), 
            $plevel,$llevel;
        printlog sprintf("%-*s   %8s  %8s   %8s  %8s\n", $nameLength, '  Count:', 
            $count{totbytes}, $count{tfrbytes}, 
            $count{totfiles}, $count{tfrfiles}), 
            $plevel,$llevel if $Opt{debug}->{status};
    }
}

#---------------------------------------------------------------------------------------------------

sub displaySummary () {
    # Print out the results summary and send email if there were problems.
    my $text = '';
    $text .= "\n\nResults Summary\n";
    $text .=     "===============\n";
    foreach my $dest (sort keys %Summary) {
        $text .= "Destination $dest\n";
        my $destInfo = $Summary{$dest};
        foreach my $source (sort keys %{$destInfo->{source}}) {
            my $srcInfo = $destInfo->{source}{$source};
            $text .= "\tSource $source\n";
            my $timing = '';
            if (defined $srcInfo->{stop}) {
                $timing = ", time taken: " . elapsed($srcInfo->{start}, $srcInfo->{stop});
            }
            $text .= "\t\t$srcInfo->{result}$timing\n";
        }
        my $timing = '';
        if (defined $destInfo->{stop}) {
            $timing = ", time taken: " . elapsed($destInfo->{start}, $destInfo->{stop});
        }
        $text .= "\t$destInfo->{result}$timing\n";
    }
    printlog $text, 1;
    # Send email if any or all destinations failed.
    if ($Opt{'email-to'} and 
        ($AllDestsFailed or ($Opt{'email-if'} eq 'any' and $AnyDestFailed))) {
        my $rc = emailSend("$Script error on " . hostname, 
            "This is an error message from backup script '$Script' running on '" . 
            hostname . "'." .
            $text .
            formatOptions() .
            $Messages .
            ($Opt{validLogfile}  
                ? "\nFor more details see the logfile (" . hostname .  ":$Opt{validLogfile}).\n" 
                : "\n")
        );
        if ($rc) {
            printWarning "\nCould not send email to @{$Opt{'email-to'}}.\n";
        } else {
            printNote "\nEmail sent to @{$Opt{'email-to'}}\n";
        }
    }
}

#===================================================================================================

# Periods
# NB periods end on the beginning of the next one

sub getPeriod ($$) {
    # Return the beginning and end of the period containing the moment specified
    # e.g. if the period is 1 (day), return the midnights before and after the moment
    # (If $moment is already the beginning of the period,
    # then stay in that period - don't skip back one)
    # Note: this is for use in calendar mode only
    my $moment  = shift; # as Unix time
    my $periodn = shift;
    my ($beg, $end);
    debug "periodn=$periodn moment=$moment (" . time2stamp($moment) . ")\n", 'gP';
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime($moment);
    if ($periodn == 0) {
        $beg = timelocal(0,0,$hour,$mday,$mon,$year+1900);
        $end = $beg + HOUR;
    } elsif ($periodn == 1) {
        $beg = timelocal(0,0,0,$mday,$mon,$year+1900);
        $end = $beg + DAY;
    } elsif ($periodn == 2) {
        # localtime() returns weekday as 0=Sunday, 6=Saturday
        # $opt{weekstart} is 1..7
        $beg = timelocal(0,0,0,$mday,$mon,$year+1900);  # beginning of today
        my $beg1 = $beg; # for debugging only
        $beg -= (($wday- ($Opt{weekstart}-1) + 7) % 7) * DAY;   # adjust for weekday
        $end = $beg + DAY*7;
        debug "mday=$mday mon=$mon year=$year wday=$wday ws=$Opt{weekstart} beg1=$beg1/" . 
            time2stamp($beg1) . " beg=$beg/" . time2stamp($beg) . 
            " end=$end/" . time2stamp($end) ."\n", 'gP';
    } elsif ($periodn == 3) {
        $beg = timelocal(0,0,0,1,$mon,$year+1900);
        $end = date2time(DateCalc(time2date($beg), '0:1:0:0:0:0:0')); # +1month
    } elsif ($periodn == 4) {
        $beg = timelocal(0,0,0,1,0,$year+1900);
        $end = timelocal(0,0,0,1,0,$year+1901);
    } else {
        die "Invalid period number '$periodn' passed to getPeriod";
    }
    return ($beg, $end);
}

#---------------------------------------------------------------------------------------------------

sub prevPeriod ($$) {
    # Given the beginning of one period, 
    # and the period number of the previous one, 
    # return the beginning and end of the previous one.
    # Note: this does not 'align' the period to whole weeks or months etc.,
    # e.g. month before 20110622-234400 is 20110522-234400--20110622-234400
    # This copes with DST and leap years (as far as I can tell).
    my $beg     = shift;
    my $periodn = shift;
    #my $end = $beg;
    my $newbeg;
    if ($periodn == $Level{h}) {
        # When going back an hour, just subtract the relevant number 
        # of seconds.  (If we use DateCalc, it does clever stuff with
        # the change to or from daylight savings, which we don't want.)
        $newbeg = $beg - HOUR;
    } else {
        # For all other periods, use DateCalc, with mode set to 1
        # for 'approximate' mode, e.g. a day is a whole day, and
        # not always 24 hours (if DST starts or ends).
        $newbeg = date2time(DateCalc(time2date($beg), $PrevP[$periodn], 1));
    }
    debug "$LevelName[$periodn] before " . time2stamp($beg) . " starts at " . 
        time2stamp($newbeg) . "\n", 'pP';
    return ($newbeg, $beg);
}

#---------------------------------------------------------------------------------------------------

sub fullPeriod ($$$) {
    # Returns true if the beg,end pair given are a full period
    # Note: this does not 'align' the period to whole weeks or months etc.,
    # e.g. 20110522-234400--20110622-234400 is a full month
    my $beg     = shift;
    my $end     = shift;
    my $periodn = shift;
    my ($beg2, $end2) = prevPeriod($end, $periodn);
    return ($beg == $beg2 && $end == $end2) ? 1 : 0;
}

#---------------------------------------------------------------------------------------------------

sub fmtRange ($$;$) {
    # Format a timestamp range to make it readable
    # using Date::Manip objects to cope with DST and leap years
    my $beg = shift;
    my $end = shift;
    my $modeOverride = shift;    # optional
    my $range = $end - $beg;
    my $begStamp = time2stamp($beg);
    my $err = 0;
    my $begdate = new Date::Manip::Date;
    my $enddate = new Date::Manip::Date;
    $err = $begdate->secs_since_1970_GMT($beg);
    debug "beg: " . $begdate->printf("%Y-%m-%d %H:%M:%S %Z"), 'fR';
    $err = $enddate->secs_since_1970_GMT($end);
    debug "end: " . $enddate->printf("%Y-%m-%d %H:%M:%S %Z"), 'fR';
    # NB: 'semi' and 'exact' modes are not available in older versions of 
    #     Date::Manip, so we trap the error and default to printing the range.
    my $mode = 'semi';                      # 'semi' works mostly...    
    $mode = 'exact' if ($range <= HOUR);    # ...but not for hours...
    $mode = 'approx' if ($range >= MONTH);  # ...nor months and years
    $mode = $modeOverride if $modeOverride;
    debug "mode: '$mode'\n", 'fR';
    my $delta = $begdate->calc($enddate, $mode);
    my $deltaerr = $delta->err();
    debug "deltaerr: $deltaerr\n", 'fR';
    my $deltastring = $delta->value();  
    $deltastring = 'broken' if !$deltastring;
    debug "delta: $deltastring\n", 'fR';
    if      ($deltastring eq '0:0:0:0:0:0:0')     {
        return "";
    } elsif ($deltastring =~ /(\d+):0:0:0:0:0:0/) {
        return "$1 year(s) from " . $begStamp;
    } elsif ($deltastring =~ /0:(\d+):0:0:0:0:0/) {
        return "$1 month(s) from " . $begStamp;
    } elsif ($deltastring =~ /0:0:(\d+):0:0:0:0/) {
        return "$1 week(s) from " . $begStamp;
    } elsif ($deltastring =~ /0:0:0:(\d+):0:0:0/) {
        return "$1 day(s) from " . $begStamp;
    } elsif ($deltastring =~ /0:0:0:0:(\d+):0:0/) {
        return "$1 hour(s) from " . $begStamp;
    } else {
        return time2stamp($beg) . ' - ' . time2stamp($end);
    }
}

#---------------------------------------------------------------------------------------------------

sub countPeriods ($$$) {
    # Return the number of periods between two dates
    # (which may not be an integer)
    my $beg     = shift;
    my $end     = shift;
    my $periodn = shift;
    my $delta = DateCalc(time2date($beg), time2date($end));
    my $count = Delta_Format($delta, "%$DMperiod[$periodn]ys");
    return sprintf(($count == floor($count)) ? "%d" : "%.1f", $count);  # 1dp if not an integer
}

#===================================================================================================

sub writeMetadata ($) {
    # Store information from %S in the metadata file via rsync using JSON 
    my $dest = shift;

    return if !%S;

    my $mdfile = "$Opt{template}.status";

    # Create subset of %S to store
    my @metadata;
    foreach my $s (sort keys %S) {
        push @metadata, {
            timestamp  => time2stamp($s), 
            unfinished => $S{$s}{unfinished}, 
            totbytes   => $S{$s}{totbytes}, 
            tfrbytes   => $S{$s}{tfrbytes},
            totfiles   => $S{$s}{totfiles},
            tfrfiles   => $S{$s}{tfrfiles},
        };
    }
    my $json = to_json(\@metadata, {pretty => 1});
    debug "json is '$json'\n", 'wM';

    # Write to a temporary local file
    my ($tempfh, $tempfilename) = tempfile(UNLINK => 1);
    debug "tempfilename is '$tempfilename'", 'wM';
    my $succeeded = 0;
    print $tempfh "# Status of $Script backups for '$Opt{template}' on '$dest' as at " . 
        time2stamp(time()) . "\n";
    print $tempfh "# Do not edit or delete this file\n";
    print $tempfh $json;
    close $tempfh;

    # Send the file via rsync
    my (@output, @errors);
    #my $remPath = $Opt{'remote-rsync-cmd'} ? "--rsync-path '$Opt{'remote-rsync-cmd'}'" : '';
    # FIXME ? --chmod may only work with --perms -- is --perms needed here?
    my ($rc, $rc2) = systemCall($Opt{'rsync-cmd'}, 
        stdArgs(1) . " --chmod=ug=rw,o=r '$tempfilename' '$dest/$mdfile'", 
        9,9, \@output, \@errors);    
    debug "rc=$rc output: '@output'\n", 'wM';
    $succeeded = 1 if !$rc;

    if (!$succeeded) {
        printWarning "Unable to create metadata file '$mdfile' (@errors)\n" . 
        "Metadata is:\n" . "$json\n\n";
    }
}

#---------------------------------------------------------------------------------------------------

sub readMetadata ($) {
    # Read the metadata into an array
    my $dest = shift; 

    my $mdArrayRef = (); 
    my $mdfile = "$Opt{template}.status"; 

    # Get the metadata file via rsync to a temporary file
    $mdfile = rsyncMakeLocal("$dest/$mdfile");
    return $mdArrayRef if $mdfile eq '';    # not readable -- carry on without it

    # Read the metadata file
    if (open MDF, '<', "$mdfile") { 
        my $json = ''; 
        while (<MDF>) { 
            $json .= $_; 
        } 
        close MDF;
        $mdArrayRef = from_json($json, {relaxed => 1});
        foreach my $md (@$mdArrayRef) { 
            # 'timestamp' was previously 'snapshot' -- adjust for that
            if (defined $md->{snapshot} and !defined $md->{timestamp}) {
                $md->{timestamp} = $md->{snapshot};
                delete $md->{snapshot};
            }
            # 'size' has been replaced by 'totbytes' etc. -- convert 
            if (defined $md->{size} and !defined $md->{totbytes}) {
                $md->{totbytes} = $md->{size};
                $md->{tfrbytes} = undef;
                $md->{totfiles} = undef;
                $md->{tfrfiles} = undef;
            }
            delete $md->{size};
            $md->{unfinished} = 0 if !defined $md->{unfinished};
            debug "$md->{timestamp} / $md->{unfinished} / $md->{totbytes}\n", 'rM'; 
        } 
    } else { 
        debug "Unable to read temporary metadata file '$mdfile'\n", 'rM';
    }
    return $mdArrayRef; 
}

#===================================================================================================

sub visualise ($$$$$$@) {
    # Draw a pretty picture of the actual and ideal snapshots given pairs of (label, array).
    # Doesn't distinguish good and bad snapshots -- the caller
    # should visualise bad snapshots separately.
    my $beg        = shift;
    my $end        = shift;
    my $showPeriod = shift;
    my $plevel     = shift;
    my $llevel     = shift;
    my $best       = shift; 
    # If plevel/llevel mean there will be no output, just return
    return if $plevel > $Opt{verbose} and $llevel > $Opt{loglevel};
    my $labelwidth = 10;
    #my ($columns, $rows) = Term::Size::chars *STDOUT{IO};
    #$columns = max($columns, 132); # minimum, and also if there's no tty
    my $columns = 100;
    my $size = $columns - $labelwidth - 3;  # - 18; # -18 for log timestamp
    my $scale = ceil(($end - $beg) / $size);    
    debug "beg=$beg end=$end (" . fmtRange($beg,$end) . ") size=$size scale=$scale\n", 'visualise';
    my $period = '';
    $period = fmtRange($beg, $end) if $showPeriod;

    while (@_ > 1) {
        my $label = pack("A$labelwidth", shift);    # force label to specified width
        my @a     = @{(shift)};
        debug "label=$label\n", 'vis';
        my @points = (0) x ($size+1);
        A: foreach my $a (@a) {
            my $pos = floor(($a - $beg) / $scale);
            if ($pos < 0 or $pos > $size) {
                debug "out of range: $pos should be >= 0 and <= $size, a=$a (" . 
                    time2stamp($a) . ")\n", 'vis';
                next A;
            }   
            if ($label eq 'Ideal' and !$points[$pos] and $best == $a) {
                $points[$pos] = 'B';  # this is a nasty hack! what if it later does 'B'+1 ?
            }
            else {
                $points[$pos] += 1;
            }
        }
        printlog "$label|" . join('', 
            map {
                !defined($_) ? '.' : 
                ($_ eq 'B')  ? 'B' :            # 'best' if label is 'Ideal' 
                ($_ < 1)     ? '.' : 
                ($_ > 9)     ? '*' : 
                               $_
            } 
            @points) . "| $period\n", $plevel,$llevel;
        $period = ''; # only show it once
    }
}

#---------------------------------------------------------------------------------------------------

sub arrayDiff (\@\@) {
    # Return elements of X that aren't in Y.
    # This doesn't work if there are duplicates in either array!
    # (That's OK, 'cos we're only using it for arrays of snapshot
    # timestamps which are required to be unique.)
    my @X = @{(shift)};
    my @Y = @{(shift)};
    my %Y = map {$_=>1} @Y; # hash version of @Y
    return grep(!defined $Y{$_}, @X);
}

sub arrayDiffRefs ($$) {    # FIXME not used
    # Return elements of X that aren't in Y (i.e. X - Y)
    # This doesn't work if there are duplicates in either array!
    # (That's OK, 'cos we're only using it for arrays of snapshot
    # timestamps which are required to be unique.)
    my $Xref = shift;
    my $Yref = shift;
    debug "Xref=$Xref Yref=$Yref\n", 'aD';
    my %Y = map {$_=>1} @$Yref; # hash version of @Y
    return grep !defined($Y{$_}), @$Xref;
}

#---------------------------------------------------------------------------------------------------

sub snapshotBefore ($) {
    # Return the snapshot before the one given (if any)
    # For good snapshots, only consider the previous good one.
    # For bad snapshots, any previous one will do.
    my $this = shift;   # the snapshot to compare 
    foreach my $s (rsort keys %S) {
        # skip the bad ones if this one is good:
        next if !$S{$this}{unfinished} and $S{$s}{unfinished}; 
        return $s if $s < $this;
    }
    return 0;   # None found, return 0 which will test as false
}

#---------------------------------------------------------------------------------------------------

sub snapshotAfter ($) {
    # Return the good snapshot after the one given (if any)
    my $this = shift;   # the snapshot to compare 
    my $prevs = 0; # If none found, return 0 which will test as false
    foreach my $s (rsort keys %S) {
        # skip the bad ones if this one is good:
        next if !$S{$this}{unfinished} and $S{$s}{unfinished}; 
        return $prevs if $s <= $this;
        $prevs = $s;
    }
    return $S{$prevs}{unfinished} ? 0 : $prevs; # all snapshots are after the date given, 
                                                # so return the first one (if it's good)
}

#---------------------------------------------------------------------------------------------------

sub snapshotsInPeriod (\@$$;$) {
    # Given a list of snapshot dates in descending order,
    # and a period (beginning and end dates),
    # return the number of snapshots in the period
    # or an array of said snapshots, depending on the last parameter.
    # (Can't use wantarray, because this often gets
    # called in list context even when just the count is needed)
    my @S           = @{(shift)};
    my $beg         = shift;
    my $end         = shift;
    my $returnArray = shift // 0;
    my $count = 0;
    my @SIP;
    foreach my $s (@S) {
        last if $s < $beg;
        if ($s < $end) {
            $count += 1;
            push @SIP, $s;
        }
    }
    debug "$beg..$end " . time2stamp($beg) . '..' . time2stamp($end) . " = $count\n", 'sIP';
    return @SIP if $returnArray;
    return $count;
}

#---------------------------------------------------------------------------------------------------

sub nextOldestSnapshot ($\@) {
    # Return the first snapshot before the given date
    # or 'undef' if there is no such snapshot
    my $time = shift;
    my @S    = @{(shift)};
    my $nextOldest;
    foreach my $s (@S) {
        debug "(" . time2stamp($time) . ") returning " . time2stamp($s) . "\n", 'nOS' if $s < $time;
        return $s if $s < $time;
    }
    debug "(" . time2stamp($time) . ") returning undef\n", 'nOS';
    return undef;
}

#---------------------------------------------------------------------------------------------------

sub deleteSnapshot ($) {
    # Delete a snapshot directory, returning the number of errors encountered.
    # Uses rsync to do the deleting, even for local snapshots, because that
    # avoids problems with permissions.
    # NB This just does the deletion (unless --dry-run) -- the caller must
    #    check for other reasons not to delete the snapshot
    my $snapshot = shift; 
    debug "doing $S{$snapshot}{fullname}\n", 'dS';
    if ($Opt{'dry-run'}) {
        printlog "(dry run: would have deleted '$S{$snapshot}{name}')\n", 1;
        delete $S{$snapshot};   # really delete it from %S though
        return 0;
    }
#    if (!$Opt{delete}) {
#        printNote "Not deleting snapshot '$S{$snapshot}{name}' because of option 'delete=no'\n", 1;
#        return 0;
#    }
#    if ($S{$snapshot}{note}) {
#        printNote "Not deleting snapshot '$S{$snapshot}{name}' because it has a note\n", 1;
#        return 0;
#    }
    # Use some rsync trickery to delete the snapshot
    # (gleaned from http://lists.samba.org/archive/rsync/2010-October/025723.html)
    # This involves copying an empty directory onto the snapshot, and
    # removing the snapshot directory itself with filter cleverness.
    my @output;
    debug "deleting snapshot the new way\n", 'dS';
    #my $remPath = $Opt{'remote-rsync-cmd'} ? "--rsync-path '$Opt{'remote-rsync-cmd'}'" : '';
    my ($rc, $rc2) = systemCall($Opt{'rsync-cmd'}, 
        stdArgs(1) . " --dirs -f 'R /$S{$snapshot}{name}/**' -f '-!r /$S{$snapshot}{name}' " .
        "--delete $EmptyDir/ $S{$snapshot}{path}", 
        9,9, \@output); 
    debug "rsync output: \n@output", 'dS';
    debug "rsync returned $rc, '$rc2'\n", 'dS';
    # This returns no error if the snapshot didn't exist, which is fine
    if ($rc) {
        printError "Failed to delete snapshot '$S{$snapshot}{name}' " .
            "from '$S{$snapshot}{path}' (code $rc/'$rc2')";
        return 1;
    }
    delete $S{$snapshot};   # delete it from %S too
    return 0;
}

#---------------------------------------------------------------------------------------------------

sub deleteSnapshots (\@\@) {
    # Delete the snapshots from the given list (latest first)
    my @D         = @{(shift)}; # list of snapshots to delete
    my @cSpecs    = @{(shift)};
    return if !@D;
    my $ci = 0; # index into @cSpecs
    my $oldci = $ci-1;
    my $errors = 0;
    my @S = rsort keys %S;
    debug "list is: " . (join(' ', map {$S{$_}{name}} @D)) . "\n", 'dS';
    #return 0 if !$Opt{delete};
    foreach my $d (@D) {
        # Find the cSpec matching this snapshot (just for the log message)
        while ($cSpecs[$ci]->{beg} > $d) { 
            $ci += 1; 
        }; 
        my $cs = $cSpecs[$ci];
        debug "ci=$ci  oldci=$oldci\n", 'dS';
        if ($ci > $oldci and $cs->{label} ne 'old') {
            # Visualise the period containing the snapshots-to-be-deleted
            my @s = snapshotsInPeriod(@S, $cs->{beg}, $cs->{fullend}, 1);
            my @d = snapshotsInPeriod(@D, $cs->{beg}, $cs->{fullend}, 1);
            debug "\@s=@s  \@d=@d\n", 'dS';
            if (@d) {
                printlog "\nSnapshots for deletion from $cs->{label},  " . 
                    fmtRange($cs->{beg},$cs->{fullend}) . "\n", 3;
                visualise($cs->{beg}, $cs->{fullend}, 0, 3,3, $cs->{best}, 
                    'All S\'s' => \@s, 
                    'Deleting' => \@d);
                printlog "\n", 3;
            }
        }
        my $unfinished = $S{$d}{unfinished} ? 'unfinished ' : '';
        if ($cs->{label} eq 'old') {
            printNote "Old ${unfinished}snapshot '$S{$d}{name}' is due for deletion\n", 1;
        } else {
            printNote "\u${unfinished}snapshot '$S{$d}{name}' is due for deletion\n" 
            . "because there are too many for spec '" . $cs->{label} . "'\n", 1;
        }
        if (!$Opt{delete}) {
            printNote "Not deleting snapshot '$S{$d}{name}' because of " . 
            "option 'delete=no'\n", 1;
        } elsif ($S{$d}{note}) {
            printNote "Not deleting snapshot '$S{$d}{name}' because it has a note\n", 1;
        } else {
            my $name = $S{$d}{name}; 
            my $rc = deleteSnapshot($d);
            printNote "Snapshot '$name' has been deleted\n", 1 if $rc == 0;
            $errors += $rc;
        }
        $oldci = $ci;
    }
    return $errors;
}

#---------------------------------------------------------------------------------------------------

sub deleteOldSnapshots (\@;$) {
    # Delete $n snapshots from the list of old ones (oldest ones first)
    my $expirablesR = shift;      # use ref, don't copy array, so that it gets popped
    my $n           = shift // 1;
    my $deleted = 0;
    debug "n=$n  expirables=@$expirablesR\n", 'dOS';
    while (@$expirablesR and $n > 0) {
        my $e = pop @$expirablesR;
        $n -= 1;
        printNote "Expiring old snapshot $S{$e}{name}\n";
        if (deleteSnapshot($e) == 0) {  
            $deleted += 1;
        } else {
            debug "Failed to delete snapshot $S{$e}{name}\n", 'dOS';
        }
    }
    debug "deleted $deleted oldest snapshots\n", 'dOS';
    return $deleted;
}

#---------------------------------------------------------------------------------------------------

sub markOrDeleteSnapshot ($$$) {
    # Mark or delete a snapshot, depending on options and errors.
    my $snapshot         = shift; 
    my $sourcesCompleted = shift;
    my $restartable      = shift;

    my $sName = $S{$snapshot}{name};   # for convenience

    my $action; # 'delete' or 'keep'
    # Don't delete if we want to restart (or have already restarted)
    if (($restartable and $Opt{'allow-restart'}) or
        ($Opt{restart})                             ) {
        $action = 'keep';
    } else {
        if ($sourcesCompleted == 0) {
            $action = $Opt{'all-failed'};
            printNote "All sources failed, will $action snapshot\n";
        } else {
            $action = $Opt{'some-failed'};
            printNote "Some sources failed, will $action snapshot\n";
        }
    }
    if ($action eq 'delete') {
        my $rc = deleteSnapshot($snapshot);
        if ($rc == 0) {
            printNote "Snapshot deleted\n";
        } else {
            printWarning "Snapshot could not be deleted (error $rc)\n";
        }
    } else {
        # Mark it as unfinished
        $S{$snapshot}{unfinished} = 1;
    }
}

#---------------------------------------------------------------------------------------------------

sub getSnapshotList ($) {
    # Read in the existing snapshots, storing their details in global hash %S.
    # Uses rsync in case the destination is remote.
    # The 'note' is an optional ending to the directory name that the 
    # user can create manually.
    my $dest = shift;
    my $template = $Opt{template};  
    debug "dest=$dest template=$Opt{template}\n", 'gSL';
    # Start with an empty list
    %S = ();
    my @listing;
    #my $remPath = '';
    #if (remote($dest) and $Opt{'remote-rsync-cmd'}) {
    #   $remPath = "--rsync-path '$Opt{'remote-rsync-cmd'}'";
    #}
    my ($rc, $rc2) = systemCall($Opt{'rsync-cmd'}, 
        stdArgs(0) . " --list-only '$dest/'", 9,9, \@listing);    
    debug "rc=$rc listing: @listing n=" . scalar @listing ."\n", 'gsL';
    return if $rc;
    my $remote = remote($dest);
    my $daemon = remoteDaemon($dest);
    foreach (@listing) {
        chomp;
        debug "listing line: $_\n", 'gSL';
        # matching e.g. 'drwxr-xr-x        4096 2011/08/09 23:01:29 library-20110809-165521-note'
        if (/\d\d:\d\d:\d\d\s+ 
            (?<name>($template)-
              (?<Y>\d{4})(?<M>\d{2})(?<D>\d{2})-
              (?<h>\d{2})(?<m>\d{2})(?<s>\d{2})
              (?<note>.*)?
            )
            $/x) {
            # Skip over any template with an invalid date (should not happen)
            next if $+{M} < 1;
            next if $+{M} > 12;
            next if $+{D} < 1;
            next if $+{D} > daysInYearMonth($+{Y}, $+{M}-1);
            next if $+{h} > 23;
            next if $+{m} > 59;
            next if $+{s} > 60;
            my $s = stamp2time($_); # snapshot time
            # Check for duplicates -- this will only happen if the user has
            # been toying with snapshot folders, and perhaps has mistakenly
            # copied, e.g., template-20121217-145225 to template-2012127-145225-special
            # instead of renaming it.
            # rsync's sorting is a bit strange, so don't rely on the non-special one
            # being first -- always drop the one with the note.
            if (!exists $S{$s}{name} or    # non-duplicate
                $S{$s}{note}           ) { # duplicate, but existing one has a note, so overwrite it
                if ($S{$s}{name}) {
                    printWarning "\nSnapshot $S{$s}{name} is a duplicate of $+{name} -\n" .
                        "$S{$s}{name} will be ignored\n";
                }
                # Add information about the snapshot to the global hash
                $S{$s} = {
                    name     => "$+{name}",     # including any note
                    path     => $dest,
                    fullname => "$dest/$+{name}",
                    unfinished => 0,            # unless metadata says otherwise -- see below
                    remote   => $remote,
                    daemon   => $daemon,
                    note     => $+{note} // '',
                    # (no size information yet -- get it from the metadata)
                };
            } else {
                # New snapshot is a duplicate without a note -- ignore it
                printWarning "\nSnapshot $+{name} is a duplicate of $S{$s}{name} -\n" .
                    "$+{name} will be ignored\n";
            }
        } else {
            debug "unmatched: $_\n", 'gSL';
        }
    }
    # Get the metadata
    my $mdArrayRef = readMetadata($dest);
    debug "md: " . Dumper($mdArrayRef), 'gSL';
    if ($mdArrayRef) {
        debug "mdArrayRef=$mdArrayRef\n", 'gSL';
        # And combine the two:
        # - warn about entries in metadata for which there is no snapshot
        # - add any unfinished and size information for the existing snapshots  NO LONGER
        foreach my $md (@$mdArrayRef) {
            debug "matching md: $md->{timestamp} / $md->{unfinished}\n", 'gSL';
            my $s = stamp2time($md->{timestamp});
            if ($S{$s}) {
                debug "updating metadata for snapshot $md->{timestamp}\n", 'gSL';
                foreach my $key (keys %$md) {
                    debug " $key = " . ($md->{$key} // 'undef'), 'gSL';
                    $S{$s}{$key} = $md->{$key};
                }
                #printlog "S in rM: " . Dumper($S{$s});
            } else {
                printWarning "Snapshot '$template-$md->{timestamp}' is missing\n";
            }
        }
    }
    # Check for zero-size snapshots (from metadata and/or file system) and delete them
    foreach my $s (sort keys %S) {
        #debug "Checking for zero size: s=$s totbytes=$S{$s}{totbytes}", 'gSL';
        if (defined $S{$s}{totbytes} and $S{$s}{totbytes} == 0) {
            # empty snapshot -- check that it really is empty
            my ($totbytes, $totfiles) = getSnapshotSize($s);
            if ($totbytes == 0) {
                # delete it
                printWarning "Deleting empty snapshot $S{$s}{name}\n";
                deleteSnapshot($s);
            } elsif ($totbytes > -1) { # (it will be -1 if couldn't get the size)
                # update the metadata
                printNote "Correcting size of snapshot $S{$s}{name} from 0 to " . 
                    bytes($totbytes) . "\n";
                debug "Updating size for $S{$s}{name}, totbytes = $totbytes", 'gSL';
                $S{$s}{totbytes} = $totbytes;
                $S{$s}{totfiles} = $totfiles;
            }
        }
    }
    debug "Snapshots: \n" . dumpSnapshotFullnames(), 'gSL';
}

#---------------------------------------------------------------------------------------------------

# Plan for new gMS:  array, elect, shrink range unless current period; this should eliminate
# need to closeness factors.  The 'electing' bit is the hard part.  
#
# Calculate array of distances from ideals to snapshots, and scan to mark each snapshot's
# nearest I with ()
#
#     0....+....1....+....2....+....3....+....4....+....5....+....6....+....7
#  I:           0                   1                   2 
#  S:                     0                            1 2 
#          I0    I1   I2   ...
#   S0     10    10   30 
#   S1     39    29    1
#   S2     41    31    1
#
# If 2 or more S's are have the same nearest I, e.g. S0 and S1 both have I1 as their nearest I,
# then pick the best one, mark with [], and set the values for the others to a high value so that they are
# eliminated. 
# If two or more I's have the same nearest S, choose one with lowest score for others -- that haven't
# already been marked as nearest an I
# So:
#  1) find the lowest score in the matrix, mark it e.g. I2/S1
#  2) repeat that...  or just mark the best for each I as a first guesss?
#     !! There will be times to undo an assignment for the greater good...
#
#          I0    I1   I2   ...
#   S0    (10)  (10)  30 
#   S1     39    29   (1)
#   S2     41    31    1
#
#  3) I0, I1 both near S0; S1 is second nearest, but already spoken for.  
#     Out of remaining Ss (S0 and S2), S2/I1 has lowest score for any of
#     I0,I1, so use that, and S0/I0:
#
#          I0    I1   I2   ...
#   S0    (10)   10   30 
#   S1     39    29   (1)
#   S2     41   (31)   1
#
# Which doesn't prove much with 3 out of 3 to choose from
#
#

sub getMatchingSnapshots ($$$$\@) {
    # Get a list of snapshots in the given period that
    # are the best match for the ideal/expected snapshots
    # FIXME 26/9/12  Bad snapshots are no longer considered for deletion
    # (see getDeleteList), so this code could be simplified.
    my $beg     = shift;         # beginning of period 
    my $end     = shift;         # end of period
    my $best    = shift;         # seconds from $beg to preferred snapshot time
    my $freqmax = shift;         # maximum number of snapshots in period
    my @S       = @{(shift)};    # array of timestamps of existing snapshots (just those in range)
                                 # in descending order

    my $range  = $end - $beg;   # the length of the period in seconds
    debug "beg=$beg end=$end range=$range best=$best freqmax=$freqmax\n", 'gMS';
    debug "period: " . fmtRange($beg, $end) . "  range: " . fmtSeconds($range) . 
        "  best time: " . time2stamp($beg + $best) . "\n", 'gMS'; 
    debug " (first S = $S[0]    last S = $S[-1]  -- in descending order)\n", 'gMS' if @S;
    debug "snapshots: \n", 'gMS';
    foreach my $si (0..$#S) {
        debug "\t$si\t$S[$si]\t" . time2stamp($S[$si]) . "\n", 'gMS';
    }

    # Special case: if freqmax is zero, delete all snapshots (i.e. keep none)
    if ($freqmax == 0) {
        debug "freqmax==0 -- deleting all\n", 'gMS';
        return ();
    }

    # Special case: if freqmax is UNLIMITED, keep all snapshots
    if ($freqmax == UNLIMITED) {
        debug "freqmax==UNLIMITED -- keeping all\n", 'gMS';
        return @S;
    }

    # Calculate closeness factor for each snapshot
    # so that snapshots with near neighbours are more likely to be deleted
    # from formula closeness=w/(p+n)
    # where p = distance to previous snapshot (or r if none)
    #       n = distance to next snapshot (or n if none)
    #       w = weighting (for tuning how much effect closeness has)
    my $closenessWeighting = $range;    # scaled to current period
    # First and last snapshots have no neighbour on one side,
    # so use these tunable values instead:
    my $firstCloseness = $range * 0.5;  # 
    my $lastCloseness  = $range * 2.0;  # last snapshot is usually valued 
    # Note that only good snapshots are considered when calculating closeness
    # -- this is handled by snapshotBefore/After
    my $totalC = 0;
    my @closeness;
    my @closeness2; # For test30 etc: arithmetic closeness i.e. distance to nearests   probably obsolete
    my @closenessq; # closeness p*q instead of p+q
    for my $s (0..$#S) {
        # Get distance to previous/next good snapshot 
        # (may be beyond current period)
        my $previous = snapshotBefore($S[$s]);
        my $next     = snapshotAfter($S[$s]);
        # If previous/next don't exist, use the end factor
        my $p = $previous ? abs($S[$s] - $previous) : $firstCloseness;
        my $n = $next     ? abs($next  - $S[$s])    : $lastCloseness;
        #
        my $closeness = $closenessWeighting / ($p + $n);
        debug "this=" . time2stamp($S[$s]) . " previous=" . time2stamp($previous) . 
            " next=" . time2stamp($next) . " p=$p n=$n c=$closeness\n", 'gMS';
        push @closeness, $closeness;
        push @closeness2, min($p, $n); # the smaller of the two  
        my $closenessq = ($closenessWeighting / $p) * ($closenessWeighting / $n);   # too big?
        #my $closenessq = $closenessWeighting / ($p * $n);   # too small?
        push @closenessq, $closenessq;
        $totalC += $closeness;
    }
    my $averageC = $totalC / scalar @S;
    debug "closeness=@closeness   closeness2=@closeness2\n", 'gMS';
    debug "average closeness = $averageC\n", 'gMS';
    
    my $bestTime = $beg + $best;    # best as Unix time, not offset from $beg

    # $beg, $end, and $range may get adjusted, so keep the original ones
    my $oldBeg = $beg;
    my $oldEnd = $end;
    my $fullRange = $end - $beg;

    # 'Shelf-bracket factor' is the size of the extra space
    # between the bracket and the end of the shelf, as
    # a proportion of the distance between brackets:
    #            
    # Shelf:     ====================================
    # Brackets:       \/          \/          \/
    #            <-f1-><----i----->            <-f2->
    # 
    # In terms of snapshots, the shelf represents the range
    # under consideration, and the ideal snapshot times are the brackets.
    #
    # Set each factor to 1/2, assuming the other half will appear
    # in the adjoining period:
    my $sbFactor1 = 0.5;
    my $sbFactor2 = 0.5;

    # Adust beg...end range around a 'close' group of snapshots
    # (i.e. ones that are not near snapshots in previous and next periods)
    # for better spacing of the 'ideals'.
    # A sequence of snapshots is considered a 'group' if either
    # the first or last has a closeness less than 50% (tunable)
    # of the average closesness.
    my $groupFactor = 0.50;     # tuning 
    # (don't forget that @closeness is in descending order by time)
    if ($closeness[0] < ($averageC * $groupFactor)) {
        # Adjust end of range 
        # (+1 to make sure last snapshot is IN the range)
        $end = $S[0];
        debug "adjusting end of range for closeness, now $end (".time2stamp($end).")\n",'gMS';
        $sbFactor2 = 0;
    }
    if ($closeness[-1] < ($averageC * $groupFactor)) {
        # Adjust beginning of range
        $beg = $S[-1];
        debug "adjusting beg of range for closeness, now $beg (".time2stamp($beg).")\n",'gMS';
        $sbFactor1 = 0;
    }

    # Further adjustment to weighting of unfinished snapshots
    # as a 'distance' in time -- makes unfinished snapshots always a bad match
    # Factor may need tuning -- currently it's arbitrarily large at 10000 to make 
    # sure that bad snapshots are deleted first.
    my @badoffset;
    foreach my $s (@S) {
        push @badoffset, ($S{$s}{unfinished} ? $range * 10000 : 0);
    }
    debug "badoffsets: @badoffset\n", 'gMS';

    # Make sure best isn't out of range
    # (this is needed sometimes even if the closeness adjustment above isn't used)
    # (the -1 is to make sure $best is IN the range)
    $bestTime = $beg   if $bestTime <  $beg;
    $bestTime = $end-1 if $bestTime >= $end;
    debug "bestTime is now $bestTime (" . time2stamp($bestTime) . ")\n", 'gMS';

    # Recalculate $best as offset into beg..end range
    $best = $bestTime - $beg;
    # and recalculate $range accordingly
    $range = $end - $beg;   # the length of the period in seconds
    debug "best is now $best, range is now $range, best/range is now ".$best/$range."\n", 'gMS';

    ## Initially space out the ideal snapshots evenly
    ## (these values are used if there is no 'best' time)
    #my @I;
    #for my $i (0..$freqmax-1) {
    #    $I[$i] = $beg + ($i+0.5) * $range/$freqmax;
    #}

    # Space out the ideal snapshots, taking into account the h/d/w/m/ybest options
    my @I;
    # put the best one in first (they get sorted later)
    $I[0] = $bestTime;
    debug "best=$I[0] " . hms($best) . "\n", 'gMS';
    if ($freqmax > 1) {  # more than one ideal to place, not just the best one
        # Calculate how many should go before and after, then spread them out.
        #my $bbyr = $best / $range;
        my $befores = floor(($best              / $range) * $freqmax);
        my $afters  = floor((($range-1 - $best) / $range) * $freqmax);
        # (the '-1' above is to avoid fence-post errors:
        # we don't want to consider the final second of the period)
        debug "befores=$befores  afters=$afters\n", 'gMS';
        if ($befores > 0) {
            # befores
            my $interval = floor($best / ($befores + $sbFactor1));
            debug "befores: interval=$interval " . hms($interval) . "\n", 'gMS';
            my $ptr = $beg + $best;
            for my $i (1..$befores) {
                $ptr -= $interval;
                debug "B - i=$i ideal = $ptr " . time2stamp($ptr) . "\n", 'gMS'; 
                unshift @I, $ptr;
            }
        }
        if ($afters > 0) {
            # afters
            my $interval = floor(($range-$best) / ($afters + $sbFactor2));
            debug "afters : interval=$interval " . hms($interval) . "\n", 'gMS';
            my $ptr = $beg + $best;
            for my $i (1..$afters) {
                $ptr += $interval;
                debug "A - i=$i ideal = $ptr " . time2stamp($ptr) . "\n", 'gMS';
                push @I, $ptr;
            }
        }
    }
    # sort Ideals here (reverse order(?))
    # FIXME this wasn't there before, and it makes a difference!
    # Aha! they short be in ascending order (it says below)
    @I = sort(@I);
    # doesn't matter for new system

    debug "ideals \n", 'gMS';
    foreach my $i (0..$#I) {
        debug "\t$i\t$I[$i]\t" . time2stamp($I[$i]) . "\n", 'gMS';
    }
    #debug "ideals: @I total: " . @I . "\n", 'gMS';

#    if ($Opt{debug}->{'test30'}) {
        # Experimental: another attempt
        # For each snapshot, get time to nearest snapshot
        # (BUT do we need to know WHICH ideal is nearest? No)
        my @n; # array of time to nearest ideal
        my @nplusc; # array of (time to nearest ideal + closeness)
        my @nminusc;
        my @ntimesc;
        my @ntimescsq;
        foreach my $s (0..$#S) {
            $n[$s] = $range; # max possible distance to an ideal
            foreach my $i (@I) {
                my $nearness = abs($S[$s] - $i);
                $n[$s] = $nearness if $nearness < $n[$s];
            }
            # Wrong - nearness is really distance -- so use closeness2
            # # STILL WRONG -- first/last closeness gets messed up
            $nplusc[$s] = $n[$s] + $closeness2[$s];
            $nminusc[$s] = $n[$s] - $closeness2[$s];
            $ntimesc[$s] = $n[$s] * $closeness[$s];
            $ntimescsq[$s] = $n[$s] * $closenessq[$s];
            #debug "s=$s  n=$n[$s]  c=$closeness2[$s]  n+c=$nplusc[$s]  n-c=$nminusc[$s]  n*c=$ntimesc[$s]\n", 'gMS';
            #debug "s=$s  n=$n[$s]  c=$closeness[$s]  n*c=$ntimesc[$s]\n", 'gMS';
            debug sprintf("si=%2d  n=%6d  c=%6.2f  n*c=%9.1f  n*csq=%9.1f\n",
                $s, $n[$s], $closeness[$s], $ntimesc[$s], $ntimescsq[$s]), 'gMS';
        }
        # Pick $freqmax best ones
        ## based on nplusc:
        #my @sorted = sort {$nplusc[$a] <=> $nplusc[$b]} (0..$#S);
        #debug "sorted in nplusc order: @sorted\n", 'test30';
        #my @keepers;
        #for my $i (0..$freqmax-1) {
        #    $keepers[$i] = $S[$sorted[$i]];
        #}
        #visualise($oldBeg, $oldEnd, 1, 1,1, $bestTime, 
        #    'Snapshot' => \@S, 
        #    'Ideal'    => \@I, 
        #    'keepers'    => \@keepers) if ($Opt{debug}->{'test30'});
        # based on ntimesc:
        my @sorted = sort {$ntimesc[$a] <=> $ntimesc[$b]} (0..$#S);
        debug "sorted in ntimesc order: @sorted\n", 'gMS';
        my @keepers;
        for my $i (0..$freqmax-1) {
            my $si = $sorted[$i];
            $keepers[$i] = $S[$si];
            #debug "i=$i  si=$si  n=$n[$si]  c=$closeness[$si]  n*c=$ntimesc[$si]\n", 'gMS';
            debug sprintf("i=%2d  si=%2d  n=%6d  c=%6.2f  n*c=%9.1f\n",
                $i, $si, $n[$si], $closeness[$si], $ntimesc[$si]), 'gMS';
        }
        # based on ntimescsq:
        my @sortedsq = sort {$ntimescsq[$a] <=> $ntimescsq[$b]} (0..$#S);
        debug "sorted in ntimescsq order: @sortedsq\n", 'gMS';
        my @keeperssq;
        for my $i (0..$freqmax-1) {
            my $si = $sortedsq[$i];
            $keeperssq[$i] = $S[$si];
            debug sprintf("i=%2d  si=%2d  n=%6d  csq=%7.2f  n*csq=%10.1f\n",
                $i, $si, $n[$si], $closenessq[$si], $ntimescsq[$si]), 'gMS';
        }
        visualise($oldBeg, $oldEnd, 1, 1,1, $bestTime, 
            'Snapshot' => \@S, 
            'Ideal'    => \@I, 
            'keepers'    => \@keepers, 
            'keeperssq'    => \@keeperssq) if ($Opt{debug}->{'gms'});

    return @keepers;
#    }

    # Generate all combinations of the ideal number of snapshots
    # out of the existing snapshots, then calculate a score for each combination
    # and choose the one with the best (lowest) score
    # (maybe we should leave first and last fixed if they're already aligned?)
    my @combs = combinations(scalar @I, 0..$#S); 
    #debug "\@combs(orig): " . Dumper(\@combs), 'gMS';
    my $minct = MAXTIME;    # smallest combination total so far
    my $mincti = 0;         # index of smallest combination so far 
    for my $ci (0..$#combs) {
        my @comb = @{$combs[$ci]};
        my $combtotal = 0;
        # Note: ideals are already in ascending order, need to sort the comb
        # (in descending order of indexes, i.e. ascending order of dates)
        @comb = sort {$b <=> $a} @comb;
        foreach my $i (0..$#I) { # for each ideal:
            my $c = $comb[$i];  # choose the corresponding existing snapshot
            # The score for each existing snapshot is:
            #    (distance to ideal * closeness) + offset for being bad
            #my $score = abs($I[$i] - $S[$c]) * $closeness[$c] + $badoffset[$c];
            my $score = abs($I[$i] - $S[$c]) * $closeness[$c];
            # Experimental:
            if ($S{$S[$c]}{note}) {
                # Snapshot has a note -- treat it special:
                # - ignore badoffset
                # - reduce the score by a factor (this could be an option perhaps)
                # This makes the special snapshot more likely to be kept
                # (it won't actually be deleted anyway, but this effectively makes
                # a non-special adjacent snapshot more likely to be deleted)
                my $noteFactor = 2;
                debug "note for $S[$c] $S{$S[$c]}{name}: $score ... " . $score/$noteFactor, 'gMS';
                $score /= $noteFactor;
            } else {
                # No note -- include badness score
                $score += $badoffset[$c];
            }
            #debug "ci=$ci i=$i comb[i]=$c I[i]=$I[$i] S[c]=$S[$c] I-S=". abs($I[$i]-$S[$c]) .
            #    " clo=$closeness[$c] bo=$badoffset[$c] score=$score\n", 'gMS';
            $combtotal += $score;
        }
        if ($combtotal < $minct) {
            $minct = $combtotal;
            $mincti = $ci;
        }
        #debug "ci=$ci combtotal=$combtotal\n", 'gMS';
    }
    ##debug "\@combs(later): " . Dumper(\@combs), 'gMS';
    #debug "" . @combs . " combinations tested\n", 'gMS';
    #debug "best combination: mincti=$mincti minct=$minct snapshot indexes: " . 
    #    join(' ', sort {$b <=> $a} @{$combs[$mincti]}) . "\n", 'gMS';
    ##debug "combs[mincti]: " . Dumper($combs[$mincti]), 'gMS';
    my @bestMatches = sort(map {$S[$_]} @{$combs[$mincti]});    # convert indexes back to snapshots 
    debug "best matches: @bestMatches count=" . @bestMatches . "\n", 'gMS';
    debug "closenesses (oldest first): " . 
        join(' ', (map {sprintf("%.2f", $_)} reverse @closeness)) . 
        ", average: $averageC\n", 'gMS';
    visualise($oldBeg, $oldEnd, 1, 1,1, $bestTime, 
        'Snapshot' => \@S, 
        'Ideal'    => \@I, 
        'Match'    => \@bestMatches) if ($Opt{debug}->{'gms'});

    return @bestMatches;
}   # getMatchingSnapshots;

#---------------------------------------------------------------------------------------------------

sub bestOffset {
    # Returns the 'best' option for a period as the offset in seconds from 
    # the beginning of the period.
    my $period = shift;
    my $time   = shift; # a time within the period
    my $best;

    return 0 if !$Opt{calendar};    # Silently ignore xbest options in nocalendar mode

    if ($period eq 'h') {
        # Best is a minute from 0-59
        $best = $Opt{hbest} * MINUTE;
    } elsif ($period eq 'd' and $Opt{dbest}) {
        # Best is specified as an hour from 0-23.99
        # so calculate the fraction of day
        $best = $Opt{dbest} * HOUR;
    } elsif ($period eq 'w') {
        # Best is a number from 1 to 7 indicating
        # the day.  Choose the middle of the day (is that OK?)
        # TODO allow e.g. 'Friday 5pm' as supplied by Date::Manip
        $best = ($Opt{wbest}-0.5) * DAY;
    } elsif ($period eq 'm') {
        # Best is the day of the month -- assume noon
        my $mbest = min($Opt{mbest}, daysInMonth($time));
        $best = ($mbest-0.5) * DAY;
    } elsif ($period eq 'y') {
        # Best is the day of the year -- assume noon
        my $ybest = min($Opt{ybest}, daysInYear($time));
        $best = ($ybest-0.5) * DAY;
    } else {
        # Shouldn't happen, but return a usable answer anyway
        $best = 0;  
    }
    return $best;
}

#---------------------------------------------------------------------------------------------------

sub getDeleteList (\@;$) {
    # Using the global hash of existing snapshots,
    # return a list of the ones to be deleted by checking against the list of cSpecs.
    # Plan 
    # - get separate lists of good and bad (unfinished) S's
    # - for each cSpec
    # -   if there are enough good ones, delete all the bad ones
    # -   if more than enough (good+bad), choose as before, but with extra weighting on the bad
    my @cSpecs = @{(shift)};
    my $plevel = shift // 3;    # optional to override print level

    # Separate the complete ('good') from the unfinished ('bad') snapshots
    my @Sgood;
    my @Sbad;
    foreach my $s (rsort keys %S) {
        if ($S{$s}{unfinished}) {
            push @Sbad, $s;
        } else {
            push @Sgood, $s;
        }
    }

    my @allMatches;
    my @D;  # accumulates list of snapshots to delete
    my $firstbeg = MAXTIME; 
    my $lastend = 0;

    debug "\nSgood: " . dumpSnapshots(@Sgood) . "\n", 'gDL';
    debug   " Sbad: " . dumpSnapshots(@Sbad)  . "\n", 'gDL';
    debug "no of cspecs = " . @cSpecs . "\n", 'gDL';

    foreach my $c (@cSpecs) {

        my $beg = $c->{beg};
        my $end = $c->{end};
        my $fullend = $c->{fullend};
        debug "\nprocessing cSpec $c->{label} freq=" 
            . fmtFreq($c->{freqmin},$c->{freqmax}) . " range " 
            . pair2range($beg, $end) . " fullend " . time2stamp($c->{fullend}) . "\n", 'gDL';

        # Find candidate snapshots in that period
        # NOTE: $fullend is the same as $end for a full period,
        #       but later than $end for a partial period.
        #       Snapshots in full period are considered when looking for matches
        #       but only those within $beg-$end will actually be deleted
        my @Cgood     = snapshotsInPeriod(@Sgood, $beg, $end,     1);
        my @Cbad      = snapshotsInPeriod(@Sbad,  $beg, $end,     1);
        my @CgoodFull = snapshotsInPeriod(@Sgood, $beg, $fullend, 1);
        my @CbadFull  = snapshotsInPeriod(@Sbad,  $beg, $fullend, 1);
        debug "good candidates: " . dumpSnapshots(@Cgood) . " total: " . @Cgood . "\n", 'gDL';
        debug "bad  candidates: " . dumpSnapshots(@Cbad) . " total: " . @Cbad . "\n", 'gDL';
        if ($fullend != $end) {
            debug "good candidates (full): ".dumpSnapshots(@CgoodFull)." total: ".@CgoodFull."\n", 
               'gDL';
            debug "bad  candidates (full): ".dumpSnapshots(@CbadFull) ." total: ".@CbadFull ."\n", 
               'gDL';
        }   
        if (@Cgood or @Cbad) {
            # there are snapsnots in this period, so adjust the overall range
            $firstbeg = $beg if $beg < $firstbeg;
            $lastend  = $end if $end > $lastend;
        }
        if (!@CgoodFull and !@CbadFull) {
            # no candidates found
            debug "no candidates found to match $c->{label} for period " . 
                time2stamp($beg) . '...' . time2stamp($fullend) . "\n", 'gDL';
        } elsif (@CgoodFull + @CbadFull <= $c->{freqmax}) {
            debug "no more candidates found than required for $c->{label}\n", 'gDL';
            debug "-- allMatches gets " . dumpSnapshots(rsort(@Cgood, @Cbad)) . "\n", 'gDL';
            push @allMatches, rsort (@Cgood, @Cbad);
        } else {
            if (@CgoodFull >= $c->{freqmax}) {
                # enough good candidates: start by deleting all the bad ones
                debug "enough good -- deleting all bad (" . @Cbad. "\)", 'gDL';
                push @D, @Cbad;
                @Cbad = ();
            }
            # FIXME 26/9/12  Maybe we should only delete things if there
            # are enough GOOD ones i.e. just check @Cgood
            # (so bad ones are never deleted unless there enough good ones)
            # NB if this is reinstated, need to consider that CbadFull may not 
            # have been emptied above
#            if (@Cgood + @Cbad > $c->{freqmax}) {
#                # Still more than enough candidates (including bad ones)
#                # - choose the ones to delete (bad ones will get chosen first)
#                my $extras = $c->{freqmax} - (@Cgood + @Cbad);
#                my @Call = rsort(@Cgood, @Cbad);
#                my @I = getMatchingSnapshots($beg, $end, $c->{best}, $c->{freqmax}, @Call); 
#                push @allMatches, @I;
#                push @D, arrayDiff(@Call, @I);
#                debug "storing keepers and deleters:\n\@Call:   " . 
#                    dumpSnapshots(@Call) . "\n\@I:   " . 
#                    dumpSnapshots(@I) . "\ndiff: " .dumpSnapshots(arrayDiff(@Call, @I))."\n",'gDL';
#                debug "\@D is now: " . dumpSnapshots2(@D) . "\n", 'gDL';
#           }
            if (@CgoodFull > $c->{freqmax}) {
                # Still more than enough good candidates: choose the ones to delete
                #my $extras = $c->{freqmax} - @Cgood;
                my @I = getMatchingSnapshots($beg, $fullend, $c->{best}, $c->{freqmax},@CgoodFull); 
                my @Ipartial = snapshotsInPeriod(@I, $beg, $end, 1);
                # only keep those within $beg-$end, otherwise there will be duplicates
                push @allMatches, @Ipartial;
                # only delete those within $beg-$end
                push @D, arrayDiff(@Cgood, @Ipartial);
                debug "storing keepers and deleters:" . 
                    "\n\@Cgood:    " . dumpSnapshots(@Cgood) . 
                    "\n\@I:        " . dumpSnapshots(@I) . 
                    "\n\@Ipartial: " . dumpSnapshots(@Ipartial) . 
                     "\ndiff:      " . dumpSnapshots(arrayDiff(@Cgood, @I))."\n", 'gDL';
                debug "\@D has now accumulated: " . dumpSnapshots2(@D) . "\n", 'gDL';
            } else {
                debug " no more than required after deleting bad ones\n", 'gDL';
            }
        }
        # Don't reconsider snapshots already marked for deletion in @D
        # (only important when a partial period overlaps the following period)
        @Sgood = arrayDiff(@Sgood, @D);
        @Sbad  = arrayDiff(@Sbad,  @D);

    } # foreach spec

    # sort @D cos may not have been added in order
    @D = rsort @D;

    if ($Opt{debug}->{'gdl'}) {
        # Summarise keepers and deleters over whole period
        printlog "\nSummary of all existing snapshots: " . time2stamp($firstbeg) . ' - ' . 
        time2stamp($lastend) . "\n", 0; 
        printlog "--------------------------------------------------------------------\n", 0;
        printlog((@Sgood+@Sbad) . ' snapshots, ' . @allMatches . ' to be kept, ' . @D . 
            " to be deleted\n", 0);
        visualise($firstbeg, $lastend, 0, 0,0, 0,   
            'Snapshots'  => \@Sgood, 
            'unfinished' => \@Sbad, 
            'Keep'       => \@allMatches, 
            'Del'        => \@D);
    }

    return @D;  # list of timestamps of snapshots to delete
}

#===================================================================================================

## FIXME this is obsolete
sub findGoodPeriodsOld ($$$\@) {
    # Starting with period ($beg, $end) and working backwards in time, 
    # check for $count periods each with at least $freqmin snapshots.
    # Return the [beginning, end, good?, snapshots-in-period, period-count] for each period
    # (including the gaps between the 'good' periods).
    # This version keeps periods aligned to calendar days/weeks/months etc.
    # The ($beg, $end) of the last one is then where we're up to.
    my $beg  = shift;
    my $end  = shift;
    my $spec = shift;
    my @S    = @{(shift)};  # just 'good' ones

    my $gpCount = 0;
    my @good;
    my $oldestSnapshot = $S[-1] // MAXTIME;
    debug "range=" . pair2range($beg, $end) . 
        " freqmin=$spec->{freqmin} periodn=$spec->{periodn} " . 
        "count=$spec->{count} oldestS=" . time2stamp($oldestSnapshot) . "\n", 'fGP';

    # Special case:
    # if this is an 'unlimited' spec, then its count will be (effectively) infinite
    # -- we need to keep filling periods until there are no more snapshots
    # -- if any periods have less than freqmin, then relax, just treat them as full
    # This is all dealt with simply by the condition count==UNLIMITED below.

    my $lastPeriodGood = 1;
    while (($end     > $oldestSnapshot) and
           ($gpCount < $spec->{count} )     )  {
        my $sip = snapshotsInPeriod(@S, $beg, $end);
        if (($spec->{count} == UNLIMITED) or 
            ($sip >= $spec->{freqmin}   )    ) {
            push @good, [$beg, $end, 1, $sip, 1];
            $gpCount += 1;    # count it as good
            $lastPeriodGood = 1;
        } else {
            # This period does not have enough snapshots to be considered 'good'
            if (!$lastPeriodGood) {
                # last one was not good either -- combine them
                $good[-1][0]  = $beg;
                $good[-1][3] += $sip;
                $good[-1][4] += 1;
            } else {
                # this is the first bad one
                push @good, [$beg, $end, 0, $sip, 1];
            }
            $lastPeriodGood = 0;
        }
        ($beg, $end) = prevPeriod($beg, $spec->{periodn});
    }
    debug "returning c=$gpCount, " . (join(' ', 
        map {pair2range(@{$_}[0], @{$_}[1]) . "=@{$_}[2]:@{$_}[3]/@{$_}[4]"} @good)) . "\n", 'fGP';
    return ($gpCount, @good);
}

sub findGoodPeriods ($$$\@) {
    # Starting with period ($beg, $end) and working backwards in time, 
    # check for $count periods each with at least $freqmin snapshots.
    # Return the [beginning, end, good?, snapshots-in-period, period-count] for each period
    # (including the gaps between the 'good' periods).
    # This version keeps periods aligned to calendar days/weeks/months etc.
    # The ($beg, $end) of the last one is then where we're up to.
    my $beg  = shift;
    my $end  = shift;
    my $spec = shift;
    my @S    = @{(shift)};  # just 'good' ones

    my $gpCount = 0;
    my @good;
    my $oldestSnapshot = $S[-1] // MAXTIME;
    debug "\nrange=" . pair2range($beg, $end) . 
        " freqmin=$spec->{freqmin} periodn=$spec->{periodn} " . 
        "count=$spec->{count} oldestS=" . time2stamp($oldestSnapshot) . "\n", 'fGP';

    # Special case:
    # if this is an 'unlimited' spec, then its count will be (effectively) infinite
    # -- we need to keep filling periods until there are no more snapshots
    # -- if any periods have less than freqmin, then relax, just treat them as full
    # This is all dealt with simply by the condition count==UNLIMITED below.

    my $lastPeriodGood = 1;
    my $snapshotsNeeded = $spec->{freqmin};
    debug "snapshotsNeeded initially $snapshotsNeeded", 'fGP';
    while (($end     > $oldestSnapshot) and
           ($gpCount < $spec->{count} )     )  {
        my $sip = snapshotsInPeriod(@S, $beg, $end);
        if (($spec->{count} == UNLIMITED) or 
            #($sip >= $spec->{freqmin}   )    ) 
            ($sip >= $snapshotsNeeded   )    ) {
            # Period has enough snapshots
            push @good, [$beg, $end, 1, $sip, 1];
            $gpCount += 1;    # count it as good
            $lastPeriodGood = 1;
            $snapshotsNeeded = $spec->{freqmin};  # reset it for next period
            debug "snapshotsNeeded reset to $snapshotsNeeded", 'fGP';
        } else {
            # This period does not have enough snapshots to be considered 'good'
            if (!$lastPeriodGood) {
                # last one was not good either -- combine them
                $good[-1][0]  = $beg;
                $good[-1][3] += $sip;
                $good[-1][4] += 1;
            } else {
                # this is the first bad one
                push @good, [$beg, $end, 0, $sip, 1];
            }
            $lastPeriodGood = 0;
            # Snapshots in this period count towards the total,
            # so reduce the number needed
            $snapshotsNeeded -= $sip;
            debug "snapshotsNeeded is down to $snapshotsNeeded", 'fGP';
        }
        ($beg, $end) = prevPeriod($beg, $spec->{periodn});
    }
    debug "returning gps=$gpCount, " . (join("\n\t\t", 
        map {pair2range(@{$_}[0], @{$_}[1]) . "=g?@{$_}[2]:@{$_}[3]/@{$_}[4]"} @good)) . "\n",'fGP';
    return ($gpCount, @good);
}

#---------------------------------------------------------------------------------------------------

sub findGoodPeriodsNoCal ($$$\@) {
    # Starting with period ($beg, $end) and working backwards in time, 
    # check for $count periods each with at least $freqmin snapshots.
    # Return the [beginning, end, good?, snapshots-in-period, period-count] for each period
    # (including the gaps between the 'good' periods).
    # This version does not keep periods aligned to calendar days/weeks/months etc.
    # The ($beg, $end) of the last one is then where we're up to.
    my $beg  = shift;
    my $end  = shift;
    my $spec = shift;
    my @S    = @{(shift)};

    my $gpCount = 0;
    my @good;
    my $oldestS = $S[-1] // MAXTIME;
    debug "\nrange=" . pair2range($beg, $end) . 
        " freqmin=$spec->{freqmin} periodn=$spec->{periodn} " . 
        "count=$spec->{count} oldestS=" . time2stamp($oldestS) . "\n", 'fGPNC';

    while (($end > $oldestS) and
        ($gpCount < $spec->{count})   ) {
        debug "looking for $spec->{freqmin} snapshots in one $spec->{period}\n", 'fGPNC';
        my $sip = snapshotsInPeriod(@S, $beg, $end);
        # Look for a contiguous period first
        if ($sip >= $spec->{freqmin}) {
            push @good, [$beg, $end, 1, $sip, 1];
            $gpCount += 1;    # count it as good
            debug "good one: range=" . pair2range($beg, $end) . " sip=$sip pc=1\n", 'fGPNC';
        } else {
            # No contiguous period --
            # find a group of freqmin snapshots within a period 
            # keeping track of the gap between that group and the last good period
            my $gapend = $end;
            my $skippedSnapshots = 0;
            my $nextS = $end;   # start search where we're up to
            while (($nextS = nextOldestSnapshot($nextS, @S))               and  # yes, '=' not '=='
                   (($beg, $end) = prevPeriod($nextS+1, $spec->{periodn})) and
                   (($sip = snapshotsInPeriod(@S, $beg, $end)) < $spec->{freqmin})) {
                # carry on looking
                $skippedSnapshots += 1;
                debug "skipping nextS=" . time2stamp($nextS) . 
                    ", skipped=$skippedSnapshots\n", 'fGPNC';
            }
            my $pc = countPeriods($end, $gapend, $spec->{periodn});
            if ($nextS) {
                # found a $nextS which marks the end a good period
                push @good, [$end, $gapend, 0, $skippedSnapshots, $pc]; 
                debug "gap: range=" . pair2range($end, $gapend) . 
                    " skippedSnapshots=$skippedSnapshots pc=$pc\n", 'fGPNC';
                push @good, [$beg, $end, 1, $sip, 1];
                debug "good after gap: range=" . pair2range($beg, $end) . 
                    " sip=$sip pc=1\n", 'fGPNC';
                $gpCount += 1;
            } else {
                # ran out of snapshots
                push @good, [$oldestS, $gapend, 0, $skippedSnapshots, $pc];
                debug "gap to oldestS: range=" . pair2range($oldestS, $gapend) . 
                    " skippedSnapshots=$skippedSnapshots pc=$pc\n", 'fGPNC';
            }

        }
        ($beg, $end) = prevPeriod($beg, $spec->{periodn});
    }

    debug "returning c=$gpCount, " . (join(' ', 
        map {pair2range(@{$_}[0], @{$_}[1]) . "=@{$_}[2]:@{$_}[3]/@{$_}[4]"} @good)) . "\n", 
        'fGPNC';
    return ($gpCount, @good);
}

#---------------------------------------------------------------------------------------------------

sub findAllPeriods ($$$\@) {
    # Expand a spec into a list of periods, starting with ($beg, $end).
    # Unlike findGoodPeriods, this doesn't care if the periods
    # have the expected number of snapshots
    my $beg  = shift;
    my $end  = shift;
    my $spec = shift;
    my @S    = @{(shift)};
    return (0, ()) if !@S;
    my @all;
    for my $c (1..$spec->{count}) {
        my $sip = snapshotsInPeriod(@S, $beg, $end);
        # each entry is: [beginning, end, good?, snapshots-in-period, period-count]
        push @all, [$beg, $end, 1, $sip, 1];
        ($beg, $end) = prevPeriod($beg, $spec->{periodn});
    }
    return ($spec->{count}, @all);
}   

#===================================================================================================
# Specs

sub compileSpecs ($$) {  
    # 'Compile' the specs into a list that takes into account
    # the current date and existing snapshots.
    # Works backwards in time from 'now'.
    my $now    = shift;
    my $specsR = shift; # array ref to $Opt{pspecs}

    my $oldestS = $now; # Will be the time of the oldest snapshot
    # List good and bad snapshots separately
    my (@Sgood, @Sbad);
    foreach my $s (rsort keys %S) {
        if ($S{$s}{unfinished}) {
            push @Sbad, $s;
        } else {
            push @Sgood, $s;
        }
        $oldestS = $s if $s < $oldestS; # including the bad ones
    }
    debug "now=" . time2stamp($now) . " specsR=$specsR\n", 'cS';

    my $firstSpec = 1;  # first spec applies to the current period
    my @cSpecs; # compile specs

    #my $end = $now + 1; # +1 to ensure 'now' is within the current period
    my $end;
    # Experimental: set end to end of period containing now
    if ($Opt{calendar}) {
        # end of period containing now
        (undef, $end) = getPeriod($now, $$specsR[0]->{periodn});
    } else {
        $end = $now + 1; # +1 to ensure 'now' is within the current period
    }
    
    debug "starting with oldestS=" . time2stamp($oldestS) . 
        ", end=" . time2stamp($end) . "\n", 'cS';
    debug "specsR: " . Dumper($specsR), 'cS';

    foreach my $spec (@$specsR) {

        my $beg;
        my $p = 1; # count the periods
        my @goodPeriods;
        my $gpCount = 0;

        if ($Opt{calendar}) {
            # beginning of period containing (end-1)   FIXME check -- was end-1 until change above
            ($beg, undef) = getPeriod($end - 1, $spec->{periodn});
            # experimental 27/3/13 -- use whole period containing 'now'  FIXME
            # WRONG!!! ($beg, $end) = getPeriod($end - 1, $spec->{periodn});
        } else {
            # period that ends now
            ($beg, undef) = prevPeriod($end, $spec->{periodn});
        }
        my $sEnd = $end;    # end of all periods covered by $spec 

        debug "[1] spec=$spec->{rawspec} beg,end=" . pair2range($beg,$end) . "\n", 'cS';

        if (!fullPeriod($beg, $end, $spec->{periodn})) { 
            # This is a partial period -- either the current period (if it's the first spec),
            # or because of a change of period type (day to week, for example)
            my $sip = snapshotsInPeriod(@Sgood, $beg, $end);
            if ($firstSpec and $sip >= $spec->{freqmin}) {  
                # This partial period can count as a good one -- do nothing here
                debug "firstSpec and enough S's -- will count as good\n", 'cS';
            } else {
                # Period is partial ...?
                my (undef, $fullend) = getPeriod($beg, $spec->{periodn});
                if ($end <= $oldestS) {
                    debug "not compiling spec $spec->{rawspec} cos it's empty\n", 'cS';
                } else {
                    push @cSpecs, {
                        beg     => $beg, 
                        end     => $end, 
                        freqmin => $spec->{freqmin},
                        # if this is the first period, apply the delete-cp option
                        # by setting freqmax to UNLIMITED so that none will be deleted
                        freqmax => ($firstSpec and !$Opt{'delete-cp'}) ? 
                                        UNLIMITED : $spec->{freqmax},
                        count   => '',
                        period  => $spec->{period},
                        # limit best to partial period:
                        best    => min(bestOffset($spec->{period}, $beg), $end-$beg-1),  
                        rawspec => $spec->{rawspec}, 
                        label   => $spec->{rawspec} . ($firstSpec ? ':current' : ':part'),
                        sgood   => $sip,
                        sbad    => snapshotsInPeriod(@Sbad, $beg, $end),
                        #partial => 1,
                        fullend => $fullend,    # end of period if it weren't partial
                    };  
                    debug "created cSpec [1] " . pair2range($cSpecs[-1]->{beg},$cSpecs[-1]->{end})
                    . " freq=$cSpecs[-1]->{freqmin}-$cSpecs[-1]->{freqmax} " . 
                    "count=$cSpecs[-1]->{count} period=$cSpecs[-1]->{period} best=" . 
                    time2stamp($cSpecs[-1]->{beg}+$cSpecs[-1]->{best}) . 
                    " label=$cSpecs[-1]->{label} " . 
                    "snapshots=$cSpecs[-1]->{sgood}/$cSpecs[-1]->{sbad}\n", 'cS';
                }
                # move to previous complete period
                ($beg, $end) = prevPeriod($beg, $spec->{periodn});   
            }
        }

        debug "[2] spec=$spec->{rawspec} beg,end=" . pair2range($beg,$end) . "\n", 'cS';

        # get list of good periods starting with beg,end
        if ($Opt{safe}) {
            if ($Opt{calendar}) {
                ($gpCount, @goodPeriods) = findGoodPeriods($beg, $end, $spec, @Sgood);
            } else {
                ($gpCount, @goodPeriods) = findGoodPeriodsNoCal($beg, $end, $spec, @Sgood);
            }
        } else {
            # unsafe mode, with or without calendar mode
            ($gpCount, @goodPeriods) = findAllPeriods($beg, $end, $spec, @Sgood);
        }

        foreach my $gpRef (@goodPeriods) {
            ($beg, $end, my $good, my $sip, my $pCount) = @$gpRef;
            if (!$good) { # there's a gap -- either 1 or more incomplete periods, 
                # or (in nocalendar mode) a fractional number of incomplete periods
                push @cSpecs, {
                    beg     => $beg,
                    end     => $end,
                    freqmin => $spec->{freqmin},
                    freqmax => UNLIMITED,    # keep them all  could use freqmax*pCount?
                    period  => $spec->{period},
                    count   => $pCount,   # may be fractional
                    best    => 0,
                    rawspec => $spec->{rawspec}, 
                    label   => 'incomplete ' . $LevelName[$spec->{periodn}] . '(s)',   
                    sgood   => $sip,
                    sbad    => snapshotsInPeriod(@Sbad, $beg, $end), 
                    #partial => 0,
                    fullend => $end,
                };
                debug "created cSpec [3] " . pair2range($cSpecs[-1]->{beg},$cSpecs[-1]->{end})
                    . " freq=$cSpecs[-1]->{freqmin}-$cSpecs[-1]->{freqmax} " . 
                    "count=$cSpecs[-1]->{count} period=$cSpecs[-1]->{period} best=" . 
                    time2stamp($cSpecs[-1]->{beg}+$cSpecs[-1]->{best}) . 
                    " label=$cSpecs[-1]->{label} " . 
                    "snapshots=$cSpecs[-1]->{sgood}/$cSpecs[-1]->{sbad}\n", 'cS';
            } else { # it's a complete period
                push @cSpecs, {
                    beg     => $beg, 
                    end     => $end, 
                    freqmin => $spec->{freqmin},
                    # if this is the first period, apply the delete-cp option
                    # by setting freqmax to UNLIMITED so that none will be deleted
                    freqmax => (($end == $now+1) and !$Opt{'delete-cp'}) ? 
                                    UNLIMITED : $spec->{freqmax}, 
                    period  => $spec->{period},
                    count   => '',
                    best    => bestOffset($spec->{period}, $beg),
                    rawspec => $spec->{rawspec}, 
                    label   => $spec->{rawspec} . ":$p",
                    sgood   => $sip, 
                    sbad    => snapshotsInPeriod(@Sbad, $beg, $end), 
                    #partial => 0,
                    fullend => $end,
                };  
                debug "created cSpec [4] " . pair2range($cSpecs[-1]->{beg},$cSpecs[-1]->{end}) .
                    " freq=$cSpecs[-1]->{freqmin}-$cSpecs[-1]->{freqmax} " . 
                    "count=$cSpecs[-1]->{count} period=$cSpecs[-1]->{period} best=" . 
                    time2stamp($cSpecs[-1]->{beg}+$cSpecs[-1]->{best}) . 
                    "label=$cSpecs[-1]->{label} " . 
                    "snapshots=$cSpecs[-1]->{sgood}/$cSpecs[-1]->{sbad}\n", 'cS';
                $p += 1;
            }
            # Move back a period beyond @goodPeriods
            ($beg, $end) = prevPeriod($beg, $spec->{periodn}); 
        } # foreach $gpRef

        debug "[3] spec=$spec->{rawspec} beg,end=" . pair2range($beg,$end) . "\n", 'cS';

        # We'll get straight here for specs after the one with not enough good periods
        # (or possibly first time if there aren't any snapshots)
        # NOTE -- we're just accessing the array @goodPeriod.
        # If count is UNLIMITED, potentially unlimited specs -- just do one for documentation.
        my $count = ($spec->{count} == UNLIMITED) ? 1 : $spec->{count};
        debug "any left over? gpCount=$gpCount, count=$count \n", 'cS';
        for my $i (($gpCount+1)..$count) {
            # HERE THERE ARE NO MORE SNAPSHOTS.
            # WE'RE JUST ITERATING THE REMAINING PERIODS OF REMAINING SPECS
            debug "not compiling $spec->{rawspec} count=$i\n", 'cS';
#            push @cSpecs, {
#                beg     => $beg,
#                end     => $end,
#                freqmin => $spec->{freqmin},
#                freqmax => $spec->{freqmax},  # no reason for UNLIMITED here (single period)
#                period  => $spec->{period},
#                count   => $spec->{count},    # or 0,  ?
#                best    => 0,
#                rawspec => $spec->{rawspec}, 
#                label   => $spec->{rawspec} . ":$p empty (2)",
#                sgood   => snapshotsInPeriod(@Sgood, $beg, $end), 
#                    # should always be 0 -- we'll check
#                sbad    => snapshotsInPeriod(@Sbad, $beg, $end), 
#                    # should always be 0 -- we'll check
#                #partial => 0,
#                fullend => $end,
#            };  
#            debug "'empty' cSpec is not empty!!!!!!!!!!!!!!!!!!!!\n", 'cS'
#                if snapshotsInPeriod(@Sgood, $beg, $end) > 0 ;
#            debug "didn't create cSpec [5] " . pair2range($cSpecs[-1]->{beg},$cSpecs[-1]->{end}) . 
#                " freq=$cSpecs[-1]->{freqmin}-$cSpecs[-1]->{freqmax} " . 
#                "count=$cSpecs[-1]->{count} period=$cSpecs[-1]->{period} best=" . 
#                time2stamp($cSpecs[-1]->{beg}+$cSpecs[-1]->{best}) . 
#                " label=$cSpecs[-1]->{label} " . 
#                "snapshots=$cSpecs[-1]->{sgood}/$cSpecs[-1]->{sbad}\n", 'cS';
            $p += 1;
            ($beg, $end) = prevPeriod($beg, $spec->{periodn});
        }

        # At this point, beg,end is the next period to consider for the CURRENT spec
        # i.e. its end is OK, but its beg is wrong
        # that's fine, we're working back from that end, so
        # we don't even need now = end -- leave end as it is for next time round loop.
        
        # Store details of complete original spec (into $Opt{pspec})
        $spec->{beg} = $end;
        $spec->{end} = $sEnd;
        debug "status spec=$spec->{rawspec} beg/end " .pair2range($spec->{beg},$spec->{end}), 'cS';

        $firstSpec = 0;

    } # for each spec

    # If there are any snapshots left, they're not needed by any of the specs,
    # and can all be deleted
    if ($end > $oldestS) {
        push @cSpecs, {
            beg     => $oldestS,
            end     => $end,
            freqmin => 0,
            freqmax => 0,     # keep none of them
            period  => '',    # not a proper period -- maps to '' in %LevelName
            count   => '',
            best    => 0,
            rawspec => '',
            label   => 'old',
            sgood   => snapshotsInPeriod(@Sgood, $oldestS, $end), 
            sbad    => snapshotsInPeriod(@Sbad, $oldestS, $end), 
            #partial => 0,
            fullend => $end,
        };  
        debug "created cSpec [6] " . pair2range($cSpecs[-1]->{beg},$cSpecs[-1]->{end}) . 
            " freq=$cSpecs[-1]->{freqmin}-$cSpecs[-1]->{freqmax} " . 
            "count=$cSpecs[-1]->{count} period=$cSpecs[-1]->{period} best=" . 
            time2stamp($cSpecs[-1]->{beg}+$cSpecs[-1]->{best}) . 
            " label=$cSpecs[-1]->{label} snapshots=$cSpecs[-1]->{sgood}/$cSpecs[-1]->{sbad}\n", 
            'cS';
    }

    # Double check that it's ok
    if (@cSpecs) {
        my $lastbeg = $cSpecs[0]->{end};
        foreach my $c (@cSpecs) {
            if ($c->{end} != $lastbeg) {
                debug "skipped " . fmtRange($c->{end}, $lastbeg) . ' with ' . 
                snapshotsInPeriod(@Sgood, $c->{end}, $lastbeg) . " snapshots\n", 'cS';
                debug "!!!!!!!!!!!!! This shouldn't happen any more!\n", 'cS'; 
            }
            if ($c->{beg} > $c->{end}) {
                debug "invalid cSpec -- beg > end: " . fmtRange($c->{beg}, $c->{end}) . "\n", 'cS'; 
                debug "!!!!!!!!!!!!! This shouldn't happen any more!\n", 'cS'; 
            }
            $lastbeg = $c->{beg};
        }
    }

    return @cSpecs;

} # compileSpecs

#---------------------------------------------------------------------------------------------------

sub displayCSpecs (\@) {
    # Display the compiled specs
    my @cSpecs = @{(shift)};

    printlog "\nCompiled specs:\n", 3;  
    printlog   "---------------\n", 3;

    # e.g.  From              To              Spec / Comment       Ss    Us    Ds
    #       20080101-111122 - 20090101-221111 6d7.............23 9999  9999  9999
    printlog sprintf("%-15s - %-15s  %-23s  %4s  %4s  %4s\n",
        'From', 'To', 'Spec / Comment', 'Ss', 'Us', 'Ds'), 3;
    printlog sprintf("%-15s - %-15s  %-23s  %4s  %4s  %4s\n",
        '-'x15, '-'x15, '-'x23, '----', '----', '----'), 3;
    my $totalS = 0;
    my $totalX = 0;
    my $totalD = 0;
    foreach my $c (@cSpecs) { 
        my $excess = max($c->{sgood} + $c->{sbad} - $c->{freqmax}, 0); # how many to delete
        printlog sprintf("%s - %s  %-23s  %4d  %4d  %4.0d\n",
            time2stamp($c->{beg}), 
            time2stamp($c->{end}),
            ($c->{count} eq '' ? '' : sprintf("%g ", $c->{count})) . $c->{label}, 
            $c->{sgood},
            $c->{sbad},
            $excess,
        ), 3;
        $totalS += $c->{sgood};
        $totalX += $c->{sbad};
        $totalD += $excess;
    }
    printlog sprintf("%-15s   %-15s  %23s  %4s  %4s  %4s\n",
        '', '', '-'x23, '----', '----', '----'), 3;
    printlog sprintf("%-15s   %-15s  %23s  %4d  %4d  %4d\n\n",
        '', '', 'Totals:', $totalS, $totalX, $totalD), 3;

    # Visualise each cSpec period
    if ($Opt{debug}->{dcs}) {
        my (@Sgood, @Sbad);
        # Create arrays of good and bad snapshots
        foreach my $s (rsort keys %S) {
            push @Sgood, $s if !$S{$s}{unfinished};
            push @Sbad,  $s if  $S{$s}{unfinished};
        }
        printlog under1("\nDistribution of existing snapshots within each compiled spec\n"), 1;
        foreach my $c (@cSpecs) {
            my @SiP = snapshotsInPeriod(@Sgood, $c->{beg}, $c->{end}, 1);
            visualise($c->{beg}, $c->{end}, 1, 1,1, 0, $c->{label} => \@SiP);
            if (@Sbad) {
                @SiP = snapshotsInPeriod(@Sbad, $c->{beg}, $c->{end}, 1);
                if (@SiP) {
                    visualise($c->{beg}, $c->{end}, 1, 1,1, 0, ' bad' => \@SiP);
                }
            }
        }
    }

}

#===================================================================================================

sub getExpirableSnapshots ($\@$) {
    # Return a list of snapshots that are 'expirable'
    # because they fall within range of the last 'unlimited' spec,
    # or because the expire-old option allows it
    my $specsR = shift;
    my @cSpecs = @{(shift)};
    my $now    = shift;

    my @S = rsort keys %S;
    debug "\@S=@S specsR=$specsR \$now=$now\n", 'gES';
    my @expirable;
    # The current snapshot and any that we're linking to
    # are never expirable, so shift them off the local copy of @S
    # # FIXME this doesn't take --ldmin into account.  nor unfinished snapshots
    for my $i (0..$Opt{ldcount}) {
        shift @S; 
    }
    if (!@S) {
        debug "no \@S, so no expirables\n", 'gES';
        return @expirable;
    }
    # Put unfinished snapshots on the list first
    foreach my $s (@S) {
        if ($S{$s}{unfinished}) {
            unshift @expirable, $s;
        }
    }
    debug "expiring unfinisheds: " . join(' ', map {time2stamp($_)} @expirable) . "\n", 'gES';
    @S = rsort keys %S;  # now with no unfinished snapshots
    # Return if there are none left
    return @expirable if !@S;
    if ($Opt{'expire-old'}) {
        # Any snapshot is expirable so return @S in oldest-first order.
        push @expirable, reverse @S;
        debug "expire-old: they're all expirable EXCEPT the first one(s): \n", 'gES';
        debug "       " . join(' ', map {time2stamp($_)} @expirable) . "\n", 3;
        return @expirable;
    }
    my $lastSpec = @$specsR[-1];
    if ($lastSpec->{count} == UNLIMITED) {
        my $lastraw = $lastSpec->{rawspec};
        my $i = $#cSpecs;
        # Pick out snapshots in the 'unlimited' cSpec, which is always at the end
        while (($i >= 0) and ($cSpecs[$i]->{label} =~ /^($lastraw)/)) {
            debug "lastC is unlimited, getting expirables\n", 'gES'; 
            unshift @expirable, snapshotsInPeriod(@S, $cSpecs[$i]->{beg}, $cSpecs[$i]->{end}, 1);
            $i -= 1;
        }
    }
    debug "returning expirables: " . join(' ', map {time2stamp($_)} @expirable) . "\n", 'gES';
    return @expirable;
}

#===================================================================================================

sub newSnapshot ($$) {
    # Create a new snapshot stamped with the current time,
    # add the entry to the %S hash, and return its time stamp.
    # Also creates the directory for the snapshot to avoid race conditions.
    my $dest         = shift;
    my $lastSnapshot = shift // 0;   # time of last snapshot (or 0 if none)
    my $snapshot = time();
    
    # Avoid having snapshots in the same period that should be in adjacent periods
    # i.e. small differences in the launch time of brandysnap via cron (for example)
    # could result in one run at, say, 5 seconds after the start of an interval,
    # and the next run at 5 seconds before the end of the same interval.
    # So we introduce a small delay to make sure that doesn't happen
    my $fudgetime = 30; # seconds;
    my $delay = 0;
    my $periodn = ${$Opt{pspecs}}[0]->{periodn}; # period of first spec
    if ($lastSnapshot) {
        if ($Opt{calendar}) {
            # Calendar mode - get beginning and end of current period
            my ($beg, $end) = getPeriod($snapshot, $periodn);
            if ( $lastSnapshot         > $beg       and
                ($lastSnapshot - $beg) < $fudgetime and
                ($end - $snapshot)     < $fudgetime     )  {
                # last snapshot is soon after beginning of period
                # so delay the new one until the beginning of the next period
                $delay = ($end - $snapshot);
            }
            debug "calendar: snapshot=" . time2stamp($snapshot) . 
                " last=" . time2stamp($lastSnapshot) . 
                " periodn=$periodn beg/end=" . pair2range($beg, $end) . 
                " delay=$delay\n", 'nS';
        } else {
            # Non-calendar mode - if the last snapshot was slightly less than a period ago,
            # delay the new one until slightly more than a period since the last one.
            debug "non-calendar\n", 'nS';
            my $sinceLast = $snapshot - $lastSnapshot;
            my $periodSecs = $Hours[$periodn] * HOUR;
            if ($sinceLast < $periodSecs                  and
                $sinceLast > ($periodSecs - 2*$fudgetime)     ) {
                $delay = ($lastSnapshot + $periodSecs) - $snapshot;
            }
            debug "non-calendar: snapshot=" . time2stamp($snapshot) . 
                " last=" . time2stamp($lastSnapshot) . 
                " periodn=$periodn periodSecs=$periodSecs" . 
                " sinceLast=$sinceLast delay=$delay\n", 'nS';
        }
    }
    if ($delay) {
        printlog "\nWaiting $delay seconds so that the new snapshot will be at the beginning of " .
            "the next $LevelName[$periodn]\n", 3;
        sleep $delay;
        $snapshot = time();
        debug "delayed $delay seconds, snapshot time is now " . time2stamp($snapshot) . "\n", 'nS';
    }

    my $name = "$Opt{template}-" . time2stamp($snapshot);
    my $fullname = "$dest/$name";

    # Make sure that a snapshot with that name doesn't already exist
    # and create the directory for it.
    while ($S{$snapshot} or rsyncExistsTest($fullname)) { 
        # Yes, we could just add 1 to $snapshot,
        # but then we might end up in the future...
        sleep 1;
        $snapshot = time();
        $name = "$Opt{template}-" . time2stamp($snapshot);
        $fullname = "$dest/$name";
    }
    my $rc = rsyncMkdir($fullname);

    # Create the new entry in the hash
    $S{$snapshot} = {
        name     => $name,
        path     => $dest,
        fullname => $fullname,
        unfinished => 0,
        totbytes => undef,  
        tfrbytes => undef,
        totfiles => undef,
        tfrfiles => undef,
        remote   => remote($dest),
        daemon   => remoteDaemon($dest),
        note     => '',
    };

    return $snapshot;
}

#---------------------------------------------------------------------------------------------------

sub addStats ($$) {
    # Add statistics from one source into the totals for the snapshot
    my $snapshotR = shift;
    my $srcStatsR = shift;
    debug "adding stats: " . Dumper($srcStatsR), 'aS';
    foreach my $key (keys %$srcStatsR) {
        $$snapshotR{$key} += $$srcStatsR{$key};
    }
}

#---------------------------------------------------------------------------------------------------
            
sub fixStats ($) {
    # Work-around for an apparent bug in rsync: with --dry-run, the number and size of
    # files transferred is reported as ALL the files, even if fewer (or none) would
    # really be transferred without --dry-run.  So unset the stats if --dry-run is used.
    my $statsR = shift;
    if ($Opt{'dry-run'}) {
        $statsR->{tfrfiles} = -1;
        $statsR->{tfrbytes} = -1;
    }
}

#---------------------------------------------------------------------------------------------------

sub runRsync ($\@$) {
    # Run rsync to create the snapshot.
    # If it fails for lack of disk space, delete expirable snapshots and try again.
    # Returns 1 for successful creation of a new snapshot, and a flag indicating
    # whether the connection to the destination was lost.
    my $dest               = shift; 
    my @expirableSnapshots = @{(shift)};
    my $snapshot           = shift;
    my @S = rsort keys %S;
    debug "\@eS='@expirableSnapshots' snapshot " . dumpSnapshot($snapshot) . ")\n", 'rR';

    my $remoteDest = remote($dest);

    my $sAvBytes = averageSnapshotBytes();  # average size of previous snapshots

    my $succeeded = 1;          # stays true if ALL sources are copied successfully
    my $sourcesSucceeded = 0;   # count of successfully backed-up sources
    my $restartable = 0;        # becomes true if unfinished snapshot should be kept for restarting
    my $lostDest = 0;           # becomes true if we lose connection to destination

    my $deletionsAllSources = 0;

    # Loop through sources one at a time
    SOURCE:
    foreach my $source (@{$Opt{source}}) {
        
        my $location = $source->{location};

        # Skip this source if it's been marked as unreadable
        if ($Summary{$dest}{source}{$location}{result} ne 'not attempted') {
            printWarning "Skipping source '$location' because it is not readable\n";
            $succeeded = 0;
            next SOURCE;
        }

        # Source and destination cannot both be remote (rsync limitation)
        my $remoteSource = remote($location);
        if ($remoteDest and $remoteSource) {
            printWarning "Source '$location' and destination '$dest' are both remote.\n" . 
                "rsync cannot do that -- the combination has been skipped\n";
            $succeeded = 0;
            next SOURCE;
        }

        my $srcInfo = $Summary{$dest}{source}{$location};
        $srcInfo->{start} = time();
        printlog "\nCopying from source '$location'\n", 1;

        # Override options for this source
        local %Opt = %Opt;
        #debug "override? " . Dumper($source), 'rR';
        foreach my $srcOpt (keys %{$source->{options}}) {
            debug "overriding $srcOpt with '" . Dumper($source->{options}->{$srcOpt}) . "'\n", 'rR';
            $Opt{$srcOpt} = $source->{options}->{$srcOpt};
        }

        # Set up verbosity option
        my $verbose = '';
        $verbose = '--verbose' if $Opt{verbose} > 3;

#        # Add the include/exclude options -- there may be several of each
#        # Note that each file/directory is double-quoted to allow escapes to work
#        # (see stripQuotes()).
#        my $incExcOpts = '';
#        foreach my $opt (qw(include include-from exclude exclude-from)) {
#            debug "adding ie options: " . join(' ', map {"--$opt \"$_\""} @{$Opt{$opt}}) . "\n", 'cIEF';
#            $incExcOpts .= join(' ', map {"--$opt \"$_\""} @{$Opt{$opt}}) . ' ';
#        }
        # Add the filter options
        my $iefOpts = join(' ', @{$Opt{ief}});

        my $destDir = $S{$snapshot}{fullname};    
        # Sub-directory within snapshot path is FQDN of remote source or
        # local hostname for a local source, unless overridden by --hostname
        my $subDir;
        if ($Opt{hostname}) {
            $subDir = $Opt{hostname};
        } elsif ($remoteSource) {
            $subDir = sourceDir($location);
        } else {
            $subDir = hostname;
        }
        $destDir = "$destDir/$subDir";

        # Set up link-dest options if there are any previous snapshots.
        # Loop to create as many link-dests as required.
        # Previous unfinished snapshots are linked in case they contain useful
        # files, but don't count towards the total.
        # Experimental: snapshots less than a % of the average size are linked but not counted
        # Note that rsync limits the number of link-dests to 20.
        # But don't do any of this in --dry-run mode because the new directory won't
        # have been created from which we're creating the relative path.
        my $linkdest = '';
        if (!$Opt{'dry-run'}) {
            my $ld = 0; # number of 'good' link-dests created
            my $s = 1;  # start at snapshot 1 (i.e. skip the 0th one that we're creating now)
            while ($ld < $Opt{ldcount} and $s <= min($#S, 20)) {
                debug "linking: s=$s S[s]=$S[$s] S{S[s]}{name}=$S{$S[$s]}{name}\n", 'rR';
                $linkdest .= "--link-dest='../../$S{$S[$s]}{name}/$subDir' ";
                debug "sAvBytes=$sAvBytes   this totbytes=" . $S{$S[$s]}{totbytes} || 'unset' . "\n", 'rR';
                # count towards the total if...
                if (!$S{$S[$s]}{unfinished}                 or               # ...its a finished snapshot or
                    (defined($S{$S[$s]}{totbytes})      and                  # ...(size is defined and
                     ($S{$S[$s]}{totbytes} > $sAvBytes*$Opt{'ldmin'}))   ) { # ... size is big enough)
                    #($S{$S[$s]}{totbytes} > $sAvBytes*0.3))   ) { # ... size is big enough)
                    debug "snapshot $S{$S[$s]}{name} included in count back\n", 'rR';
                    $ld += 1 
                }
                $s += 1;
            }
        }

        # Set compression option
        my $compression = '';
        $compression = '--compress' if $Opt{compress} and ($remoteSource or $remoteDest);

        # Set bandwidth limit unless dest and source are both local
        my $bwlimit = '';
        $bwlimit = "--bwlimit=$Opt{bwlimit}" if $remoteSource or $remoteDest;

        # Set remote rsync option
        my $rsyncPath = '';
        $rsyncPath = "--rsync-path '$Opt{'remote-rsync-cmd'}'"
            if ($Opt{'remote-rsync-cmd'} and ($remoteSource or $remoteDest));

        printlog "Running rsync from source '$location' to destination '$destDir'\n", 2;
        # Note that rsync-opts and rsync-xopts are put first -- 
        # our own required options will override the user's
        my $args = "$Opt{'rsync-opts'} $Opt{'rsync-xopts'} " .
            "$verbose $linkdest $iefOpts $compression " . 
            "$bwlimit --relative --stats $rsyncPath '$location' '$destDir'";

        my $retriesD = @expirableSnapshots;        # retries after deleting to make space 
        my $retriesT = $Opt{'timeout-retries'};    # retries after time-outs
        my $keepTrying = 1; 
        my $deletions = 0;
        # Run rsync, dealing with various types of error
        while ($keepTrying and !$Interrupted) {

            printlog "Running rsync command: $Opt{'rsync-cmd'} $args\n", 1;
                      #####################
            my $rsyncInterrupted = '';     # only true if interrupted during the main rsync  
            my ($rc, $rc2, $statsR) = systemCall($Opt{'rsync-cmd'}, $args, 4,4);
            $rsyncInterrupted = $Interrupted;
            debug "after rsync rc=$rc rc2='$rc2' rsyncInterrupted='$rsyncInterrupted'\n", 'rR';
            debug "source stats: " . Dumper($statsR), 'rR';
            fixStats($statsR);

            if (($rc == 23) and ($rc2 eq 'nofileordir')) {
                #* source not found
                printError "Source '$location' could not be read -- " . 
                    "will continue with any other sources\n";
                $keepTrying = 0;    # don't try this source again
                $succeeded = 0;
                $srcInfo->{result} = 'source not found';
            }

            elsif (($rc == 23) and ($rc2 eq 'readonly')) {
                #* file system has gone read-only
                printError "The destination's file system has become read-only; " .
                    "this problem must be correct before running $Script again.\n";
                $keepTrying = 0;
                $succeeded = 0;
                $restartable = 0;
                $srcInfo->{result} = 'readonly';
                last SOURCE;
            }

            elsif ($rsyncInterrupted ne '' or $rc2 eq 'interrupted') {
                #* interrupted
                printWarning "rsync was interrupted with signal '$rsyncInterrupted' -- " .
                    "the snapshot will be kept to allow restart\n";
                $keepTrying = 0;
                $succeeded = 0;
                $restartable = 1;
                $srcInfo->{result} = 'interrupted';
                last SOURCE;
            }

            elsif (($rc == 30) or ($rc2 eq 'timedout')) {
                #* timed out -- continue with other sources/destinations
                #               which may use a different route
                if ($remoteDest) {
                    # lost connection to remote destination -- skip any other sources
                    printError "rsync timed out: probably lost connection to destination\n";
                    $lostDest = 1;
                } elsif ($remoteSource) {
                    # lost connection to remote source -- keep trying other sources
                    printError "rsync timed out: probably lost connection to source\n";
                } else {
                    # local-to-local rsync timed out -- why would that happen?
                    # - perhaps when using NFS, for example.
                    printError "rsync timed out\n";
                }
                if ($retriesT > 0) {
                    # try again
                    printNote "Will try again up to $retriesT more time(s)\n", 1;
                    $retriesT -= 1;
                } else {
                    $keepTrying = 0;
                    $succeeded = 0;
                    $restartable = 1;
                    $srcInfo->{result} = 'timed out';
                    last SOURCE if $lostDest;
                }
            }

            elsif (($rc == 12) and ($rc2 eq 'diskfull')) {
                #* disk full
                # Try to make some space before having another go
                printError "Destination '$dest' is full!\n";
                if ($retriesD > 0) { 
                    printNote "Will try to delete an old snapshot to make space\n", 1;
                    my $deleted = deleteOldSnapshots(@expirableSnapshots, 1);
                    if ($deleted >= 1) {
                        # More space freed, so try again
                        printNote "Old snapshot deleted successfully, will try again\n", 1;
                        $deletions += $deleted;
                        $deletionsAllSources += $deleted;
                        $retriesD -= 1;
                    } else {
                        # No snapshots deleted, so stop trying
                        printError "Unable to delete old snapshot to make space\n";
                        $keepTrying = 0;
                        $succeeded = 0;
                        $ExitCode = EXITRSYNC;
                        $srcInfo->{result} = 'failed (not enough space)';
                        last SOURCE;
                    }
                } else {
                    printNote "No old snapshots can be deleted\n", 1;
                    $keepTrying = 0;
                    $succeeded = 0;
                    $ExitCode = EXITRSYNC;
                    $srcInfo->{result} = 'failed (not enough space)';
                    last SOURCE;
                }
            }

            elsif ($rsyncInterrupted ne '' or $rc2 eq 'interrupted') {
                #* interrupted
                printWarning "rsync was interrupted with signal '$rsyncInterrupted' -- " .
                    "the snapshot will be kept to allow restart\n";
                $keepTrying = 0;
                $succeeded = 0;
                $restartable = 1;
                $srcInfo->{result} = 'interrupted';
                last SOURCE;
            }

            elsif ($rc != 0 and $rc != 23 and $rc != 24) {
            #elsif (!($rc ~~ [0, 23, 24])) 
                #* any other error means rename/delete/abandon whole destination
                # 11 e.g. include-from file not found
                # 13 e.g. permission denied
                # 12 with rc2 = 'nofileordir' i.e. bad destination
                # 5 - failed to start rsyncd protocol
                # 255, various, including wrong ssh password, 
                # -1
                # etc.
                printError "rsync reported a serious problem ($rc / '$rc2')\n";
                $keepTrying = 0;
                $succeeded = 0;
                $ExitCode = $rc >= 1000 ? EXITINT : EXITRSYNC;
                $srcInfo->{result} = "failed (error $rc / '$rc2')";
                last SOURCE;
            }

            elsif ($statsR->{totbytes} <= 0) {
                #* source is empty (or apparently so) despite no serious error
                # (test this before [22,23,24] to trap case where all files
                #  have e.g. permission errors so the whole snapshot is empty)
                printError "Source '$location' appears to be empty -- " . 
                    "will continue with any other sources\n";
                $keepTrying = 0;    # don't try this source again
                $succeeded = 0;
                $srcInfo->{result} = 'source is empty';
            }

            else {   
                #* success (0) and errors that can be ignored (23, 24)
                # FIXME used to include 22 here -- why?
                # e.g. errors on some files such as problems with permissions,
                # or files that have vanished -- carry on
                $keepTrying = 0;
                $sourcesSucceeded += 1;
                $srcInfo->{result} = 'succeeded';
                if ($rc != 0) {
                    printWarning "Some errors from rsync have been ignored\n";
                    $srcInfo->{result} .= ' (minor errors ignored)';
                }
                addStats($S{$snapshot}, $statsR);
            }

            debug "No more tries\n", 'rR' if $keepTrying <= 0;

        } # while keep trying for this source

        if ($Cygwin) {
            # Hacky work-around for the fact that /cygdrive/c, aka C:\, 
            # is a special case that gets 000 permissions thanks to Windows' ACL system.
            # This has to be done per-source, because $subDir may be different.
            if ($location =~ m|^/cygdrive/c|) {
                rsyncFixPermsC($destDir);
            }
        }

        if ($deletions) {
            printNote "$deletions expirable snapshots were deleted while " . 
                "processing source '$location'\n";
            printlog "(dry run: no snapshots actually deleted)\n", 3 if $Opt{'dry-run'};
        }

        $srcInfo->{stop} = time();
    } # for each source

    if ($succeeded) {
        printlog "\nSuccessfully created new snapshot '$S{$snapshot}{fullname}'" .   
            ($Opt{'dry-run'} ? "\n(dry run: no snapshot actually created)" : '') . "\n\n", 1;
        if ($deletionsAllSources) {
           
            printNote "$deletionsAllSources expirable snapshots were deleted" . 
                " from destination '$dest'\n";
            printlog "(dry run: no snapshots actually deleted)\n", 3 if $Opt{'dry-run'};
        }
        $Summary{$dest}{result} = 'succeeded';
    } else {
        printWarning "\nrsync did NOT create a complete new snapshot on destination '$dest':\n" .
            "$sourcesSucceeded out of " . @{$Opt{source}} . " sources were completed\n";
        if ($restartable and $Opt{'allow-restart'}) {
            printNote "Unfinished snapshot has been left to allow the run to be restarted\n" .
                "(use the --restart option to do so)\n";
            $Summary{$dest}{result} = 'unfinished (restartable)';
        } else {
            $Summary{$dest}{result} = "failed -- $sourcesSucceeded sources succeeded";
        }
        markOrDeleteSnapshot($snapshot, $sourcesSucceeded, $restartable);
    }

    return ($succeeded, $lostDest);
}

#---------------------------------------------------------------------------------------------------

sub createLatest () {
    # Create a 'latest' copy of the most recent snapshot.
    # i.e. a snapshot with the fixed name '<template>-latest' that can be used for
    # offsite copies or whatever.
    # Prints note/warning/errors messages, but does not return any error code.
    my @S = rsort keys %S;
    my $new = $S{$S[0]};
    my $template = $Opt{template};
    debug "path=$new->{path}  name=$new->{name}, remote=$new->{remote}", 'cL';
    if ($new->{daemon}) {
        printWarning "\nCannot create 'latest' snapshot copy on rsync daemon destination\n\n", 1;
        return;
    }
    if ($Opt{'dry-run'}) {
        printNote "\nNot creating 'latest' snapshot copy because this is a dry-run\n";
        # (can't use --dry-run below because the new snapshot doesn't exist)
        return;
    }
    printlog "\nCreating 'latest' snapshot copy\n";
    my $cmd = '';
    my $args = '';
    # use new snapshot as link-dest unless --latest-copy specified
    my $linkdest = $Opt{'latest-copy'} ? '' : "--link-dest ../$new->{name}";
    if ($new->{remote}) {
        # ssh to remote destination, and run rsync there
        my ($server, $dir) = split(':', $new->{path}, 2);
        $cmd = "ssh";
        my $rsync = $Opt{'remote-rsync-cmd'} || 'rsync';
        $args = "$server $rsync -aHx --numeric-ids --delete $linkdest " .
            "$dir/$new->{name}/ $dir/$template-latest";
    } else {
        # local destination -- just run rsync as usual
        $cmd = $Opt{'rsync-cmd'};
        $args = "-aHx --numeric-ids --delete $linkdest " .
            "$new->{fullname}/ $new->{path}/$template-latest";
    }
    debug "cmd is '$cmd'", 'cL';
    debug "args are '$args'", 'cL';
    my (@items, @errors);
    my ($rc, $rc2) = systemCall($cmd, $args, 9,9, \@items, \@errors);
    debug "items: @items",   'cL' if @items;
    debug "errors: @errors", 'cL' if @errors;
    if ($rc) {
        printError "Unable to create 'latest' snapshot copy ($rc / '$rc2')\n\n";
    } else {
        printlog "Successfully created 'latest' snapshot copy\n\n", 1;
    }
}

#---------------------------------------------------------------------------------------------------

sub processDestination ($) {
    # Do the processing for a single destination
    my $dest  = shift;      

    $Summary{$dest}{start} = time();

    printlog under2("\n\nCreating snapshots on destination $dest\n"), 1;

    # Get list of existing snapshots
    getSnapshotList($dest);
    my @S = rsort keys %S;
    debug "got list of " . @S . " snapshots\n", 'run';

    # If there are no previous snapshots, ignore the 'restart' option
    if ($Opt{restart} and !%S) {
        printNote "No previous snapshots found, so 'restart' option will be ignored\n";
        $Opt{restart} = 0;  # don't worry, this copy of %Opt is local to this destination
    }

    my $now = time();   # Now, and/or timestamp of new snapshot
    if ($Opt{snapshot}) {
        # Check when the last successful snapshot was run
        if ($Opt{'min-interval'} > 0 and @S > 1) {
            # If the last snapshot was unfinished and within min-interval, just restart it
            if ($Opt{'allow-restart'} and 
                $S{$S[0]}{unfinished} and 
                ($now - $S[0]) < ($Opt{'min-interval'} * MINUTE)) {
                if (!$Opt{restart}) {
                    printNote "\nAutomatically restarting recent unsuccessful snapshot";
                    $Opt{restart} = 1;
                }
            } else {
                # No auto-restart -- don't run if successful recently
                if (!$Opt{'dry-run'}) {     # (ignore this check if dry-running)
                    my $s = 0;
                    while ($s < @S and $S{$S[$s]}{unfinished}) {
                        $s += 1;
                    }
                    if ($s < @S and ($now - $S[$s]) < ($Opt{'min-interval'} * MINUTE)) {
                        printNote "\nIt has been less than $Opt{'min-interval'} minutes\n" . 
                            "since the last successful snapshot: skipping this destination\n", 1;
                        $Summary{$dest}{result} = 'skipped';
                        $AllDestsFailed = 0;    # counts as successful
                        return;
                    }
                }
            }
        }
        if ($Opt{restart}) {
            # Restarting the previous snapshot (whether complete or not)
            $now = $S[0];
            debug "restarting with now=$now: " . dumpSnapshot($now) . "\n", 'pD';
            # remove the unfinished flag -- hopefully, we'll complete it
            $S{$now}{unfinished} = 0;
            # and clear the statistics -- rsync will supply the totals
            debug sprintf("clearing stats: %s / %s / %s / %s\n",
                $S{$now}{totbytes} // 'null',
                $S{$now}{tfrbytes} // 'null',
                $S{$now}{totfiles} // 'null',
                $S{$now}{tfrfiles} // 'null'), 'pD';
            $S{$now}{totbytes} = undef;
            $S{$now}{tfrbytes} = undef;
            $S{$now}{totfiles} = undef;
            $S{$now}{tfrfiles} = undef;
            printlog under1("\nRestarting snapshot $S{$now}{name}\n"), 1;
        } else {
            # Normal run, creating a new snapshot.
            # Create the new entry in %S, and get the new time stamp
            $now = newSnapshot($dest, $S[0]);
            # and include it in the list 
            unshift @S, $now;
            printlog under1("\nCreating snapshot $S{$now}{name}\n"), 1;
        }
    }

    # 'Compile' the specs taking account of current time and existing snapshots
    my @cSpecs;
    @cSpecs = compileSpecs($now, $Opt{pspecs});
    displayCSpecs(@cSpecs);
    
    # Get the list of snapshots to be deleted
    my @D;
    @D = getDeleteList(@cSpecs) if $Opt{delete};
    # deleteNew is true if the new snapshot would be one of those to be deleted:
    my $deleteNew = grep {$_ == $now} @D;
    debug "deleteNew=$deleteNew", 'pD';

    if ($Opt{snapshot} or $Opt{delete}) {
        # Set the destination lock, and give up if that failed
        if (!rsyncLockDest($dest)) {
            $Summary{$dest}{result} = 'failed: no lock';
            $AnyDestFailed = 1;
            return;
        }
    }

    my $lostDest = 0;
    if ($Opt{snapshot}) {
        if ($deleteNew and $Opt{delete} and $Opt{'delete-cp'}) {
            printNote "The new snapshot would be immediately deleted,\n" . 
                "so rsync will NOT be run for this destination\n", 1;
            # Tidy up the empty directory we created for it
            deleteSnapshot($S[0]);
            $Summary{$dest}{result} = 'not needed';
            # note that it's not marked as failed
            $AllDestsFailed = 0;
        } else {
            my @expirableSnapshots = getExpirableSnapshots($Opt{pspecs}, @cSpecs, $now);
            # Run rsync to create the new snapshot
            (my $rsyncOK, $lostDest) = runRsync($dest, @expirableSnapshots, $now);  
            if ($rsyncOK) { 
                $AllDestsFailed = 0;
                # Create a 'latest' snapshot if required
                if (!$lostDest and $Opt{latest}) {
                    createLatest();
                }
            } else {
                $AnyDestFailed = 1;
            }
        }
    } else {
        printNote "Option 'nosnapshot' given, so no new snapshot will be created\n", 1;
    }

    if (!$Interrupted) {
        if ($Opt{delete}) {
            # Get the delete list again because the snapshot we've just created (if any)
            # may not be complete (or may not have been created)
            @D = getDeleteList(@cSpecs) if $Opt{snapshot};
            # Now we can actually delete things
            deleteSnapshots(@D, @cSpecs);
        } else {
            printNote "Option 'nodelete' given, so no existing snapshots will be deleted\n", 1;
        }
    }

    if (!$lostDest and ($Opt{snapshot} or $Opt{delete})) {
        # Complete and store the metadata
        updateSnapshotSizes();
        writeMetadata($dest);
    }

    # Display the current situation after recompiling the specs to allow for changes
    @cSpecs = compileSpecs($now, $Opt{pspecs});  
    status($dest, @cSpecs);

    if (!$lostDest) {
        # Clear the destination lock
        # (there's no point trying to unlock it if we've lost the connection to the destination)
        rsyncUnlockDest($dest);
    }

    $Summary{$dest}{stop} = time();
}

#---------------------------------------------------------------------------------------------------
    
sub systemCall ($$$$;$$) {
    # Run a system command, given as a program name and argument string.
    # Return the command's return code and extra info if possible.
    # Elaborate scheme for catching STDOUT and STDERR taken from the PERL FAQ 
    # http://perldoc.perl.org/perlfaq8.html#How-can-I-capture-STDERR-from-an-external-command?
    my $cmd         = shift;
    my $args        = shift;    # as a string
    my $stdoutLevel = shift;
    my $stderrLevel = shift;
    my $stdoutRef   = shift;    # if specified, it's an array reference that will receive lines 
                                # from stdout OR a file handle to store stdout lines in
    my $stderrRef   = shift;    # ditto for stderr
    # TODO ?? combine levels and refs?
    my $rc = 0;
    my $rc2 = '';
    my %stats;
    if ($Opt{'dry-run'}) {
        if ($cmd eq $Opt{'rsync-cmd'}) {
            # Special case: if cmd is 'rsync', pass dry-run to rsync and really run it
            # (added at the beginning because of source and dest)
            $args = '--dry-run ' . $args;
        } else {
            printlog "(dry-run: would have run '$cmd $args')\n", 1;
            return 0;
        }
    }
    debug "cmd=|$cmd| args=|$args|\n", 'sC';
    printlog "Running command: $cmd $args\n", $stdoutLevel;
    {
        local *CATCHERR = IO::File->new_tmpfile;
        my $pid = open3(gensym, \*CATCHOUT, ">&CATCHERR", "$cmd $args");
        # Deal with stdout from $cmd
        my $outputStarted = 0;
        while (<CATCHOUT>) {
            if (!$outputStarted) {
                printlog "------- '$cmd' output starts\n", $stdoutLevel unless $stdoutRef;
                $outputStarted = 1;
            }
            # intercept rsync's stats
            # (Is there a better way?  I don't want to put all of a possibly
            # huge rsync output into an array.  But this is becoming a bit hacky  FIXME)
            # As of rsync 3.1.0, the numbers are displayed with commas, so strip them,
            # and the number of files is split into 'regular files' and directories
            # e.g. Number of files: 745 (reg: 674, dir: 71) 
            if (/Number of files: ([\d,]+) \(reg: ([\d,]+), dir: ([\d,]+)\)/) {  # rsync >= 3.1.0
                ($stats{totfiles} = $2) =~ tr/,//d;
                debug "totfiles=$stats{totfiles} (new)\n", 'sC';
            } elsif (/Number of files: ([\d,]+)/) { # rsync <= 3.0.9
                ($stats{totfiles} = $1) =~ tr/,//d;
                debug "totfiles=$stats{totfiles} (old)\n", 'sC';
            } elsif (/Number of (regular |)files transferred: ([\d,]+)/) {
                ($stats{tfrfiles} = $2) =~ tr/,//d;
                debug "tfrfiles=$stats{tfrfiles}\n", 'sC';
            } elsif (/Total file size: ([\d,]+)/) {
                ($stats{totbytes} = $1) =~ tr/,//d;
                debug "totbytes=$stats{totbytes}\n", 'sC';
            # 'Literal data' is apparently how much is actually sent
            # elsif (/Total transferred file size: (\d+)/) 
            } elsif (/Literal data: ([\d,]+)/) {
                ($stats{tfrbytes} = $1) =~ tr/,//d;
                debug "tfrbytes=$stats{tfrbytes}\n", 'sC';
            }
            # direct the output as required
            if (ref($stdoutRef) eq 'ARRAY') {
                push @$stdoutRef, $_; 
            } elsif (ref($stdoutRef) eq 'GLOB') {
                print $stdoutRef $_;
            } else {
                # FIXME do I ever need to write to stdout AND array/file?
                printlog $_, $stdoutLevel;
            }
        }
        if ($outputStarted) {
            printlog "------- '$cmd' output ends\n", $stdoutLevel unless $stdoutRef;
        }
        waitpid($pid, 0);
        $rc = $?;
        $rc2 = '';
        # Deal with stderr from $cmd
        seek CATCHERR, 0, 0;
        $outputStarted = 0;
        while (<CATCHERR>) {
            if (!$outputStarted) {
                #printlog "------- '$cmd' errors start\n", $stderrLevel unless $stderrRef;
                printError "------- '$cmd' errors start\n" unless $stderrRef;
                $outputStarted = 1;
            }
            # scan for specific errors (see %ErrorCodes)
            # TODO give these rc2 strings names
            if (/No space left on device/i) {    # (this text is not always there)
                $rc2 = 'diskfull';
            } elsif (/No such file or directory/i) {
                $rc2 = 'nofileordir';
            } elsif (/Could not resolve hostname/i) {
                $rc2 = 'nohost';
            } elsif (/received SIGINT/i) {
                $rc2 = 'interrupted';
            } elsif (/timed out/i or /timeout/i) {
                $rc2 = 'timedout';
            } elsif (/Permission denied/i) {
                $rc2 = 'permission';
            } elsif (/Read-only file system/i) {
                $rc2 = 'readonly';
            }
            # direct the output as required
            if (ref($stderrRef) eq 'ARRAY') {
                push @$stderrRef, $_; 
            } elsif (ref($stderrRef) eq 'GLOB') {
                print $stderrRef $_;
            } else {
                # FIXME do I ever need to write to stderr AND array/file?
                printError $_; #, $stderrLevel;
            }
        }
        if ($outputStarted) {
            #printlog "------- '$cmd' errors end\n", $stderrLevel unless $stderrRef;
            printError "------- '$cmd' errors end\n" unless $stderrRef;
        }
    }
    if ($rc == -1) {
        debug "Failed to execute command '$cmd $args': $!\n", 'sC';
    } elsif ($rc & 127) {
        my $sig = $rc & 127;
        debug "Command '$cmd $args' died with signal $sig\n", 'sC';
        #  ($? & 127),  ($? & 128) ? 'with' : 'without';
        $rc = ($rc & 127) + 1000;
    } else {
        $rc = $rc >> 8;
        debug "Command '$cmd $args' exited with value $rc\n", 'sC' if $rc;
    }
    return ($rc, $rc2, \%stats);
}

#===================================================================================================

# Test suite
# Code here can be called by running the script with the '--test n' option.
# This is for developers (i.e. me) only!

sub testSuite { 
    # Load the test suite code from a file
    my $testSuite = dirname($0) . '/bstestsuite.pl';
    open TESTSUITE, '<', $testSuite or die "Can't open test suite file '$testSuite'";
    my $code = do { local $/; <TESTSUITE> };
    close TESTSUITE;
    eval $code;
    die $@ if $@;
}

#===================================================================================================

# Mainline is here

my $startTime = time();

# No options supplied -- display help and exit
if (@ARGV == 0) {
    printError "No options given\n"; 
    showHelp;
    exit EXITCONFIG;
}

# Get and validate options
my ($e, $w) = processOptions();
checkInterruption('while checking options');
if ($e > 0) {
    printError "Problems found in configuration -- stopping\n";
    printlog "Try '$Script --help' or 'man $Script' for help.\n", 1;
    # FIXME if there were config options, email-to may not have been set...
    emailConfigError($e, $w);
    logit '-'x80 . "\n", 1;
    exit EXITCONFIG;
}

# Turn off stacktrace unless we're debugging
if (keys %{$Opt{debug}} == 0) {
    $SIG{__DIE__} = 'DEFAULT';  
} 

# If user has specifically requested output, 
# make sure that --verbosity is at least 1
if ($Opt{help} or $Opt{version} or $Opt{status} or $Opt{test} or $Opt{'email-test'}) {
    $Opt{verbose} = max($Opt{verbose}, 1);
}

# Help requested - display and exit
if ($Opt{help}) {
    showHelp;
    exit EXITOK;
}
delete $Opt{help};  # no longer needed

# Version requested - display and exit
if ($Opt{version}) {
    showLicence;
    exit EXITOK;
}
delete $Opt{version};  # no longer needed

# Just run the test suite if required 
if ($Opt{test}) {
    testSuite();
    exit;
}
delete $Opt{test};  # no longer needed

# Just send a test email if required
if ($Opt{'email-test'}) {
    emailTest();
    exit;
}
delete $Opt{'email-test'};  # no longer needed

displayOptions();

# Deal with each destination
foreach my $dest (@{$Opt{destination}}) {
    last if $Interrupted;
    my $loc = $dest->{location};
    debug "running destination $loc ($Summary{$loc}{result})\n", 'ml';
    next if $Summary{$loc}{result} ne 'not attempted';  # skip it if it's not available
    debug "...yes, really doing it", 'ml';
    local %Opt = %Opt;
    foreach my $destOpt (keys %{$dest->{options}}) {
        debug "overriding $destOpt with '$dest->{options}->{$destOpt}'\n", 'ml';
        $Opt{$destOpt} = $dest->{options}->{$destOpt};
    }
    if ($Opt{status}) {
        getSnapshotList($loc);
        my @cSpecs = compileSpecs(time(), $Opt{pspecs});
        displayCSpecs(@cSpecs) if $Opt{debug}->{status};
        status($loc, @cSpecs);
    } else {
        processDestination($loc);
        checkInterruption("while creating snapshot on destination '$loc'");
    }
}

displaySummary() if !$Opt{status};

#if ($Interrupted) 
#    printlog "\n(Interrupted with signal '$Interrupted')\n", 1;
#    $ExitCode = EXITINT if $ExitCode != EXITOK;
#
my $stopTime = time();
printlog "\n$Script stopping at " . (strftime "%H:%M:%S", localtime) . 
    " with exit code $ExitCode\n", 1,1;
printlog "Total elapsed time: " . elapsed($startTime, $stopTime) . "\n", 2,2;
logit '-' x 80 . "\n\n", 1;

# Free the lock on the logfile
close(LOGFILE);    # closing the file automatically unlocks it

exit $ExitCode;
# That's the end

#===================================================================================================

# vim: tabstop=4 softtabstop=4 shiftwidth=4 expandtab
